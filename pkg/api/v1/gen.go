// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// contextKey provides a type for use with context.WithValue.
type contextKey string

const (
	BasicScopes  contextKey = "Basic.Scopes"
	BearerScopes contextKey = "Bearer.Scopes"
	HeaderScopes contextKey = "Header.Scopes"
)

// Defines values for GroupModPerm.
const (
	GroupModPermAdmin GroupModPerm = "admin"
	GroupModPermOwner GroupModPerm = "owner"
	GroupModPermUser  GroupModPerm = "user"
)

// Defines values for GroupPackPerm.
const (
	GroupPackPermAdmin GroupPackPerm = "admin"
	GroupPackPermOwner GroupPackPerm = "owner"
	GroupPackPermUser  GroupPackPerm = "user"
)

// Defines values for UserGroupPerm.
const (
	UserGroupPermAdmin UserGroupPerm = "admin"
	UserGroupPermOwner UserGroupPerm = "owner"
	UserGroupPermUser  UserGroupPerm = "user"
)

// Defines values for UserModPerm.
const (
	UserModPermAdmin UserModPerm = "admin"
	UserModPermOwner UserModPerm = "owner"
	UserModPermUser  UserModPerm = "user"
)

// Defines values for UserPackPerm.
const (
	UserPackPermAdmin UserPackPerm = "admin"
	UserPackPermOwner UserPackPerm = "owner"
	UserPackPermUser  UserPackPerm = "user"
)

// Defines values for SortOrderParam.
const (
	SortOrderParamAsc  SortOrderParam = "asc"
	SortOrderParamDesc SortOrderParam = "desc"
)

// Defines values for ListFabricBuildsParamsOrder.
const (
	ListFabricBuildsParamsOrderAsc  ListFabricBuildsParamsOrder = "asc"
	ListFabricBuildsParamsOrderDesc ListFabricBuildsParamsOrder = "desc"
)

// Defines values for ListForgeBuildsParamsOrder.
const (
	ListForgeBuildsParamsOrderAsc  ListForgeBuildsParamsOrder = "asc"
	ListForgeBuildsParamsOrderDesc ListForgeBuildsParamsOrder = "desc"
)

// Defines values for ListGroupsParamsOrder.
const (
	ListGroupsParamsOrderAsc  ListGroupsParamsOrder = "asc"
	ListGroupsParamsOrderDesc ListGroupsParamsOrder = "desc"
)

// Defines values for ListGroupModsParamsOrder.
const (
	ListGroupModsParamsOrderAsc  ListGroupModsParamsOrder = "asc"
	ListGroupModsParamsOrderDesc ListGroupModsParamsOrder = "desc"
)

// Defines values for ListGroupPacksParamsOrder.
const (
	ListGroupPacksParamsOrderAsc  ListGroupPacksParamsOrder = "asc"
	ListGroupPacksParamsOrderDesc ListGroupPacksParamsOrder = "desc"
)

// Defines values for ListGroupUsersParamsOrder.
const (
	ListGroupUsersParamsOrderAsc  ListGroupUsersParamsOrder = "asc"
	ListGroupUsersParamsOrderDesc ListGroupUsersParamsOrder = "desc"
)

// Defines values for ListMinecraftBuildsParamsOrder.
const (
	ListMinecraftBuildsParamsOrderAsc  ListMinecraftBuildsParamsOrder = "asc"
	ListMinecraftBuildsParamsOrderDesc ListMinecraftBuildsParamsOrder = "desc"
)

// Defines values for ListModsParamsOrder.
const (
	ListModsParamsOrderAsc  ListModsParamsOrder = "asc"
	ListModsParamsOrderDesc ListModsParamsOrder = "desc"
)

// Defines values for ListModGroupsParamsOrder.
const (
	ListModGroupsParamsOrderAsc  ListModGroupsParamsOrder = "asc"
	ListModGroupsParamsOrderDesc ListModGroupsParamsOrder = "desc"
)

// Defines values for ListModUsersParamsOrder.
const (
	ListModUsersParamsOrderAsc  ListModUsersParamsOrder = "asc"
	ListModUsersParamsOrderDesc ListModUsersParamsOrder = "desc"
)

// Defines values for ListVersionsParamsOrder.
const (
	ListVersionsParamsOrderAsc  ListVersionsParamsOrder = "asc"
	ListVersionsParamsOrderDesc ListVersionsParamsOrder = "desc"
)

// Defines values for ListVersionBuildsParamsOrder.
const (
	ListVersionBuildsParamsOrderAsc  ListVersionBuildsParamsOrder = "asc"
	ListVersionBuildsParamsOrderDesc ListVersionBuildsParamsOrder = "desc"
)

// Defines values for ListNeoforgeBuildsParamsOrder.
const (
	ListNeoforgeBuildsParamsOrderAsc  ListNeoforgeBuildsParamsOrder = "asc"
	ListNeoforgeBuildsParamsOrderDesc ListNeoforgeBuildsParamsOrder = "desc"
)

// Defines values for ListPacksParamsOrder.
const (
	ListPacksParamsOrderAsc  ListPacksParamsOrder = "asc"
	ListPacksParamsOrderDesc ListPacksParamsOrder = "desc"
)

// Defines values for ListBuildsParamsOrder.
const (
	ListBuildsParamsOrderAsc  ListBuildsParamsOrder = "asc"
	ListBuildsParamsOrderDesc ListBuildsParamsOrder = "desc"
)

// Defines values for ListBuildVersionsParamsOrder.
const (
	ListBuildVersionsParamsOrderAsc  ListBuildVersionsParamsOrder = "asc"
	ListBuildVersionsParamsOrderDesc ListBuildVersionsParamsOrder = "desc"
)

// Defines values for ListPackGroupsParamsOrder.
const (
	ListPackGroupsParamsOrderAsc  ListPackGroupsParamsOrder = "asc"
	ListPackGroupsParamsOrderDesc ListPackGroupsParamsOrder = "desc"
)

// Defines values for ListPackUsersParamsOrder.
const (
	ListPackUsersParamsOrderAsc  ListPackUsersParamsOrder = "asc"
	ListPackUsersParamsOrderDesc ListPackUsersParamsOrder = "desc"
)

// Defines values for ListQuiltBuildsParamsOrder.
const (
	ListQuiltBuildsParamsOrderAsc  ListQuiltBuildsParamsOrder = "asc"
	ListQuiltBuildsParamsOrderDesc ListQuiltBuildsParamsOrder = "desc"
)

// Defines values for ListUsersParamsOrder.
const (
	ListUsersParamsOrderAsc  ListUsersParamsOrder = "asc"
	ListUsersParamsOrderDesc ListUsersParamsOrder = "desc"
)

// Defines values for ListUserGroupsParamsOrder.
const (
	ListUserGroupsParamsOrderAsc  ListUserGroupsParamsOrder = "asc"
	ListUserGroupsParamsOrderDesc ListUserGroupsParamsOrder = "desc"
)

// Defines values for ListUserModsParamsOrder.
const (
	ListUserModsParamsOrderAsc  ListUserModsParamsOrder = "asc"
	ListUserModsParamsOrderDesc ListUserModsParamsOrder = "desc"
)

// Defines values for ListUserPacksParamsOrder.
const (
	ListUserPacksParamsOrderAsc  ListUserPacksParamsOrder = "asc"
	ListUserPacksParamsOrderDesc ListUserPacksParamsOrder = "desc"
)

// AuthToken defines model for AuthToken.
type AuthToken struct {
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	Token     *string    `json:"token,omitempty"`
}

// AuthVerify defines model for AuthVerify.
type AuthVerify struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Username  *string    `json:"username,omitempty"`
}

// Build Model to represent build
type Build struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Fabric Model to represent fabric
	Fabric   *Fabric `json:"fabric,omitempty"`
	FabricID *string `json:"fabric_id,omitempty"`

	// Forge Model to represent forge
	Forge   *Forge  `json:"forge,omitempty"`
	ForgeID *string `json:"forge_id,omitempty"`
	ID      *string `json:"id,omitempty"`
	Java    *string `json:"java,omitempty"`
	Latest  *bool   `json:"latest,omitempty"`
	Memory  *string `json:"memory,omitempty"`

	// Minecraft Model to represent minecraft
	Minecraft   *Minecraft `json:"minecraft,omitempty"`
	MinecraftID *string    `json:"minecraft_id,omitempty"`
	Name        *string    `json:"name,omitempty"`

	// Neoforge Model to represent neoforge
	Neoforge   *Neoforge `json:"neoforge,omitempty"`
	NeoforgeID *string   `json:"neoforge_id,omitempty"`

	// Pack Model to represent pack
	Pack   *Pack `json:"pack,omitempty"`
	Public *bool `json:"public,omitempty"`

	// Quilt Model to represent quilt
	Quilt       *Quilt     `json:"quilt,omitempty"`
	QuiltID     *string    `json:"quilt_id,omitempty"`
	Recommended *bool      `json:"recommended,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
}

// BuildVersion Model to represent build version
type BuildVersion struct {
	// Build Model to represent build
	Build     *Build     `json:"build,omitempty"`
	BuildID   string     `json:"build_id"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Version Model to represent version
	Version   *Version `json:"version,omitempty"`
	VersionID string   `json:"version_id"`
}

// Fabric Model to represent fabric
type Fabric struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Forge Model to represent forge
type Forge struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Minecraft *string    `json:"minecraft,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Group Model to represent group
type Group struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// GroupMod Model to represent group mod
type GroupMod struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group   *Group `json:"group,omitempty"`
	GroupID string `json:"group_id"`

	// Mod Model to represent mod
	Mod       *Mod          `json:"mod,omitempty"`
	ModID     string        `json:"mod_id"`
	Perm      *GroupModPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time    `json:"updated_at,omitempty"`
}

// GroupModPerm defines model for GroupMod.Perm.
type GroupModPerm string

// GroupPack Model to represent group pack
type GroupPack struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group   *Group `json:"group,omitempty"`
	GroupID string `json:"group_id"`

	// Pack Model to represent pack
	Pack      *Pack          `json:"pack,omitempty"`
	PackID    string         `json:"pack_id"`
	Perm      *GroupPackPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time     `json:"updated_at,omitempty"`
}

// GroupPackPerm defines model for GroupPack.Perm.
type GroupPackPerm string

// Minecraft Model to represent minecraft
type Minecraft struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Type      *string    `json:"type,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Mod Model to represent mod
type Mod struct {
	Author *string `json:"author,omitempty"`

	// Avatar Model to represent mod avatar
	Avatar      *ModAvatar `json:"avatar,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Donate      *string    `json:"donate,omitempty"`
	ID          *string    `json:"id,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Public      *bool      `json:"public,omitempty"`
	Side        *string    `json:"side,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	Website     *string    `json:"website,omitempty"`
}

// ModAvatar Model to represent mod avatar
type ModAvatar struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	URL       *string    `json:"url,omitempty"`
}

// Neoforge Model to represent neoforge
type Neoforge struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Notification Generic response for errors and validations
type Notification struct {
	Errors  *[]Validation `json:"errors,omitempty"`
	Message *string       `json:"message,omitempty"`
	Status  *int          `json:"status,omitempty"`
}

// Pack Model to represent pack
type Pack struct {
	// Avatar Model to represent pack avatar
	Avatar    *PackAvatar `json:"avatar,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`
	ID        *string     `json:"id,omitempty"`
	Name      *string     `json:"name,omitempty"`
	Public    *bool       `json:"public,omitempty"`
	Slug      *string     `json:"slug,omitempty"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
	Website   *string     `json:"website,omitempty"`
}

// PackAvatar Model to represent pack avatar
type PackAvatar struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	URL       *string    `json:"url,omitempty"`
}

// Profile Model to represent profile
type Profile struct {
	Active    *bool        `json:"active,omitempty"`
	Admin     *bool        `json:"admin,omitempty"`
	Auths     *[]UserAuth  `json:"auths,omitempty"`
	CreatedAt *time.Time   `json:"created_at,omitempty"`
	Email     *string      `json:"email,omitempty"`
	Fullname  *string      `json:"fullname,omitempty"`
	Groups    *[]UserGroup `json:"groups,omitempty"`
	ID        *string      `json:"id,omitempty"`
	Mods      *[]UserMod   `json:"mods,omitempty"`
	Packs     *[]UserPack  `json:"packs,omitempty"`
	Password  *string      `json:"password,omitempty"`
	Profile   *string      `json:"profile,omitempty"`
	UpdatedAt *time.Time   `json:"updated_at,omitempty"`
	Username  *string      `json:"username,omitempty"`
}

// Provider Model to represent auth provider
type Provider struct {
	Display *string `json:"display,omitempty"`
	Driver  *string `json:"driver,omitempty"`
	Icon    *string `json:"icon,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// Quilt Model to represent quilt
type Quilt struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// User Model to represent user
type User struct {
	Active    *bool       `json:"active,omitempty"`
	Admin     *bool       `json:"admin,omitempty"`
	Auths     *[]UserAuth `json:"auths,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`
	Email     *string     `json:"email,omitempty"`
	Fullname  *string     `json:"fullname,omitempty"`
	ID        *string     `json:"id,omitempty"`
	Password  *string     `json:"password,omitempty"`
	Profile   *string     `json:"profile,omitempty"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
	Username  *string     `json:"username,omitempty"`
}

// UserAuth Model to represent user auth
type UserAuth struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Provider  *string    `json:"provider,omitempty"`
	Ref       *string    `json:"ref,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// UserGroup Model to represent user group
type UserGroup struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group     *Group         `json:"group,omitempty"`
	GroupID   string         `json:"group_id"`
	Perm      *UserGroupPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time     `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserGroupPerm defines model for UserGroup.Perm.
type UserGroupPerm string

// UserMod Model to represent user mod
type UserMod struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Mod Model to represent mod
	Mod       *Mod         `json:"mod,omitempty"`
	ModID     string       `json:"mod_id"`
	Perm      *UserModPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time   `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserModPerm defines model for UserMod.Perm.
type UserModPerm string

// UserPack Model to represent user pack
type UserPack struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Pack Model to represent pack
	Pack      *Pack         `json:"pack,omitempty"`
	PackID    string        `json:"pack_id"`
	Perm      *UserPackPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time    `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserPackPerm defines model for UserPack.Perm.
type UserPackPerm string

// Validation General structure to show validation errors
type Validation struct {
	Field   *string `json:"field,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Version Model to represent version
type Version struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// File Model to represent version file
	File *VersionFile `json:"file,omitempty"`
	ID   *string      `json:"id,omitempty"`

	// Mod Model to represent mod
	Mod       *Mod       `json:"mod,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Public    *bool      `json:"public,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// VersionFile Model to represent version file
type VersionFile struct {
	ContentType *string    `json:"content_type,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	MD5         *string    `json:"md5,omitempty"`
	Path        *string    `json:"path,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	URL         *string    `json:"url,omitempty"`
}

// AuthCodeParam defines model for AuthCodeParam.
type AuthCodeParam = string

// AuthProviderParam defines model for AuthProviderParam.
type AuthProviderParam = string

// AuthStateParam defines model for AuthStateParam.
type AuthStateParam = string

// BuildID defines model for BuildParam.
type BuildID = string

// FabricID defines model for FabricParam.
type FabricID = string

// ForgeID defines model for ForgeParam.
type ForgeID = string

// GroupID defines model for GroupParam.
type GroupID = string

// MinecraftID defines model for MinecraftParam.
type MinecraftID = string

// ModID defines model for ModParam.
type ModID = string

// NeoforgeID defines model for NeoforgeParam.
type NeoforgeID = string

// PackID defines model for PackParam.
type PackID = string

// PagingLimitParam defines model for PagingLimitParam.
type PagingLimitParam = int

// PagingOffsetParam defines model for PagingOffsetParam.
type PagingOffsetParam = int

// QuiltID defines model for QuiltParam.
type QuiltID = string

// SearchQueryParam defines model for SearchQueryParam.
type SearchQueryParam = string

// SortColumnParam defines model for SortColumnParam.
type SortColumnParam = string

// SortOrderParam defines model for SortOrderParam.
type SortOrderParam string

// UserID defines model for UserParam.
type UserID = string

// VersionID defines model for VersionParam.
type VersionID = string

// ActionFailedError Generic response for errors and validations
type ActionFailedError = Notification

// AlreadyAttachedError Generic response for errors and validations
type AlreadyAttachedError = Notification

// BadCredentialsError Generic response for errors and validations
type BadCredentialsError = Notification

// BadRequestError Generic response for errors and validations
type BadRequestError = Notification

// BuildResponse Model to represent build
type BuildResponse = Build

// BuildVersionsResponse defines model for BuildVersionsResponse.
type BuildVersionsResponse struct {
	// Build Model to represent build
	Build  *Build `json:"build,omitempty"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`

	// Pack Model to represent pack
	Pack     *Pack          `json:"pack,omitempty"`
	Total    int64          `json:"total"`
	Versions []BuildVersion `json:"versions"`
}

// BuildsResponse defines model for BuildsResponse.
type BuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack `json:"pack,omitempty"`
	Total int64 `json:"total"`
}

// FabricBuildsResponse defines model for FabricBuildsResponse.
type FabricBuildsResponse struct {
	Builds []Build `json:"builds"`

	// Fabric Model to represent fabric
	Fabric *Fabric `json:"fabric,omitempty"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
	Total  int64   `json:"total"`
}

// FabricsResponse defines model for FabricsResponse.
type FabricsResponse struct {
	Limit    int64    `json:"limit"`
	Offset   int64    `json:"offset"`
	Total    int64    `json:"total"`
	Versions []Fabric `json:"versions"`
}

// ForgeBuildsResponse defines model for ForgeBuildsResponse.
type ForgeBuildsResponse struct {
	Builds []Build `json:"builds"`

	// Forge Model to represent forge
	Forge  *Forge `json:"forge,omitempty"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Total  int64  `json:"total"`
}

// ForgesResponse defines model for ForgesResponse.
type ForgesResponse struct {
	Limit    int64   `json:"limit"`
	Offset   int64   `json:"offset"`
	Total    int64   `json:"total"`
	Versions []Forge `json:"versions"`
}

// GroupModsResponse defines model for GroupModsResponse.
type GroupModsResponse struct {
	// Group Model to represent group
	Group  *Group     `json:"group,omitempty"`
	Limit  int64      `json:"limit"`
	Mods   []GroupMod `json:"mods"`
	Offset int64      `json:"offset"`
	Total  int64      `json:"total"`
}

// GroupPacksResponse defines model for GroupPacksResponse.
type GroupPacksResponse struct {
	// Group Model to represent group
	Group  *Group      `json:"group,omitempty"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Packs  []GroupPack `json:"packs"`
	Total  int64       `json:"total"`
}

// GroupResponse Model to represent group
type GroupResponse = Group

// GroupUsersResponse defines model for GroupUsersResponse.
type GroupUsersResponse struct {
	// Group Model to represent group
	Group  *Group      `json:"group,omitempty"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`
	Users  []UserGroup `json:"users"`
}

// GroupsResponse defines model for GroupsResponse.
type GroupsResponse struct {
	Groups []Group `json:"groups"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
	Total  int64   `json:"total"`
}

// InternalServerError Generic response for errors and validations
type InternalServerError = Notification

// InvalidTokenError Generic response for errors and validations
type InvalidTokenError = Notification

// LoginResponse defines model for LoginResponse.
type LoginResponse = AuthToken

// MinecraftBuildsResponse defines model for MinecraftBuildsResponse.
type MinecraftBuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`

	// Minecraft Model to represent minecraft
	Minecraft *Minecraft `json:"minecraft,omitempty"`
	Offset    int64      `json:"offset"`
	Total     int64      `json:"total"`
}

// MinecraftsResponse defines model for MinecraftsResponse.
type MinecraftsResponse struct {
	Limit    int64       `json:"limit"`
	Offset   int64       `json:"offset"`
	Total    int64       `json:"total"`
	Versions []Minecraft `json:"versions"`
}

// ModAvatarResponse Model to represent mod avatar
type ModAvatarResponse = ModAvatar

// ModGroupsResponse defines model for ModGroupsResponse.
type ModGroupsResponse struct {
	Groups []GroupMod `json:"groups"`
	Limit  int64      `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod  `json:"mod,omitempty"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`
}

// ModResponse Model to represent mod
type ModResponse = Mod

// ModUsersResponse defines model for ModUsersResponse.
type ModUsersResponse struct {
	Limit int64 `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod      `json:"mod,omitempty"`
	Offset int64     `json:"offset"`
	Total  int64     `json:"total"`
	Users  []UserMod `json:"users"`
}

// ModsResponse defines model for ModsResponse.
type ModsResponse struct {
	Limit  int64 `json:"limit"`
	Mods   []Mod `json:"mods"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`
}

// NeoforgeBuildsResponse defines model for NeoforgeBuildsResponse.
type NeoforgeBuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`

	// Neoforge Model to represent neoforge
	Neoforge *Neoforge `json:"neoforge,omitempty"`
	Offset   int64     `json:"offset"`
	Total    int64     `json:"total"`
}

// NeoforgesResponse defines model for NeoforgesResponse.
type NeoforgesResponse struct {
	Limit    int64      `json:"limit"`
	Offset   int64      `json:"offset"`
	Total    int64      `json:"total"`
	Versions []Neoforge `json:"versions"`
}

// NotAttachedError Generic response for errors and validations
type NotAttachedError = Notification

// NotAuthorizedError Generic response for errors and validations
type NotAuthorizedError = Notification

// NotFoundError Generic response for errors and validations
type NotFoundError = Notification

// PackAvatarResponse Model to represent pack avatar
type PackAvatarResponse = PackAvatar

// PackGroupsResponse defines model for PackGroupsResponse.
type PackGroupsResponse struct {
	Groups []GroupPack `json:"groups"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack `json:"pack,omitempty"`
	Total int64 `json:"total"`
}

// PackResponse Model to represent pack
type PackResponse = Pack

// PackUsersResponse defines model for PackUsersResponse.
type PackUsersResponse struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack      `json:"pack,omitempty"`
	Total int64      `json:"total"`
	Users []UserPack `json:"users"`
}

// PacksResponse defines model for PacksResponse.
type PacksResponse struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Packs  []Pack `json:"packs"`
	Total  int64  `json:"total"`
}

// ProfileResponse Model to represent profile
type ProfileResponse = Profile

// ProvidersResponse defines model for ProvidersResponse.
type ProvidersResponse struct {
	Providers []Provider `json:"providers"`
	Total     int64      `json:"total"`
}

// QuiltBuildsResponse defines model for QuiltBuildsResponse.
type QuiltBuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`

	// Quilt Model to represent quilt
	Quilt *Quilt `json:"quilt,omitempty"`
	Total int64  `json:"total"`
}

// QuiltsResponse defines model for QuiltsResponse.
type QuiltsResponse struct {
	Limit    int64   `json:"limit"`
	Offset   int64   `json:"offset"`
	Total    int64   `json:"total"`
	Versions []Quilt `json:"versions"`
}

// RefreshResponse defines model for RefreshResponse.
type RefreshResponse = AuthToken

// RemoteUnavailableError Generic response for errors and validations
type RemoteUnavailableError = Notification

// SuccessMessage Generic response for errors and validations
type SuccessMessage = Notification

// TokenResponse defines model for TokenResponse.
type TokenResponse = AuthToken

// UserGroupsResponse defines model for UserGroupsResponse.
type UserGroupsResponse struct {
	Groups []UserGroup `json:"groups"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserModsResponse defines model for UserModsResponse.
type UserModsResponse struct {
	Limit  int64     `json:"limit"`
	Mods   []UserMod `json:"mods"`
	Offset int64     `json:"offset"`
	Total  int64     `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserPacksResponse defines model for UserPacksResponse.
type UserPacksResponse struct {
	Limit  int64      `json:"limit"`
	Offset int64      `json:"offset"`
	Packs  []UserPack `json:"packs"`
	Total  int64      `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserResponse Model to represent user
type UserResponse = User

// UsersResponse defines model for UsersResponse.
type UsersResponse struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Total  int64  `json:"total"`
	Users  []User `json:"users"`
}

// ValidationError Generic response for errors and validations
type ValidationError = Notification

// VerifyResponse defines model for VerifyResponse.
type VerifyResponse = AuthVerify

// VersionBuildsResponse defines model for VersionBuildsResponse.
type VersionBuildsResponse struct {
	Builds []BuildVersion `json:"builds"`
	Limit  int64          `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod  `json:"mod,omitempty"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`

	// Version Model to represent version
	Version *Version `json:"version,omitempty"`
}

// VersionResponse Model to represent version
type VersionResponse = Version

// VersionsResponse defines model for VersionsResponse.
type VersionsResponse struct {
	Limit int64 `json:"limit"`

	// Mod Model to represent mod
	Mod      *Mod      `json:"mod,omitempty"`
	Offset   int64     `json:"offset"`
	Total    int64     `json:"total"`
	Versions []Version `json:"versions"`
}

// BuildVersionBody defines model for BuildVersionBody.
type BuildVersionBody struct {
	Mod     string `json:"mod,omitempty"`
	Version string `json:"version,omitempty"`
}

// CreateBuildBody defines model for CreateBuildBody.
type CreateBuildBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// CreateGroupBody defines model for CreateGroupBody.
type CreateGroupBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// CreateModBody defines model for CreateModBody.
type CreateModBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// CreatePackBody defines model for CreatePackBody.
type CreatePackBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// CreateUserBody defines model for CreateUserBody.
type CreateUserBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// CreateVersionBody defines model for CreateVersionBody.
type CreateVersionBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// FabricBuildBody defines model for FabricBuildBody.
type FabricBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ForgeBuildBody defines model for ForgeBuildBody.
type ForgeBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// GroupModDropBody defines model for GroupModDropBody.
type GroupModDropBody struct {
	Mod string `json:"mod"`
}

// GroupModPermBody defines model for GroupModPermBody.
type GroupModPermBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// GroupPackDropBody defines model for GroupPackDropBody.
type GroupPackDropBody struct {
	Pack string `json:"pack"`
}

// GroupPackPermBody defines model for GroupPackPermBody.
type GroupPackPermBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// GroupUserDropBody defines model for GroupUserDropBody.
type GroupUserDropBody struct {
	User string `json:"user"`
}

// GroupUserPermBody defines model for GroupUserPermBody.
type GroupUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// LoginAuthBody defines model for LoginAuthBody.
type LoginAuthBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// MinecraftBuildBody defines model for MinecraftBuildBody.
type MinecraftBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ModGroupDropBody defines model for ModGroupDropBody.
type ModGroupDropBody struct {
	Group string `json:"group"`
}

// ModGroupPermBody defines model for ModGroupPermBody.
type ModGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// ModUserDropBody defines model for ModUserDropBody.
type ModUserDropBody struct {
	User string `json:"user"`
}

// ModUserPermBody defines model for ModUserPermBody.
type ModUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// NeoforgeBuildBody defines model for NeoforgeBuildBody.
type NeoforgeBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// PackGroupDropBody defines model for PackGroupDropBody.
type PackGroupDropBody struct {
	Group string `json:"group"`
}

// PackGroupPermBody defines model for PackGroupPermBody.
type PackGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PackUserDropBody defines model for PackUserDropBody.
type PackUserDropBody struct {
	User string `json:"user"`
}

// PackUserPermBody defines model for PackUserPermBody.
type PackUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// QuiltBuildBody defines model for QuiltBuildBody.
type QuiltBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// RedirectAuthBody defines model for RedirectAuthBody.
type RedirectAuthBody struct {
	Token string `json:"token"`
}

// UpdateBuildBody defines model for UpdateBuildBody.
type UpdateBuildBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// UpdateGroupBody defines model for UpdateGroupBody.
type UpdateGroupBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateModBody defines model for UpdateModBody.
type UpdateModBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// UpdatePackBody defines model for UpdatePackBody.
type UpdatePackBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// UpdateProfileBody defines model for UpdateProfileBody.
type UpdateProfileBody struct {
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateUserBody defines model for UpdateUserBody.
type UpdateUserBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateVersionBody defines model for UpdateVersionBody.
type UpdateVersionBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// UserGroupDropBody defines model for UserGroupDropBody.
type UserGroupDropBody struct {
	Group string `json:"group"`
}

// UserGroupPermBody defines model for UserGroupPermBody.
type UserGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// UserModDropBody defines model for UserModDropBody.
type UserModDropBody struct {
	Mod string `json:"mod"`
}

// UserModPermBody defines model for UserModPermBody.
type UserModPermBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// UserPackDropBody defines model for UserPackDropBody.
type UserPackDropBody struct {
	Pack string `json:"pack"`
}

// UserPackPermBody defines model for UserPackPermBody.
type UserPackPermBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// VersionBuildBody defines model for VersionBuildBody.
type VersionBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// LoginAuthJSONBody defines parameters for LoginAuth.
type LoginAuthJSONBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// RedirectAuthJSONBody defines parameters for RedirectAuth.
type RedirectAuthJSONBody struct {
	Token string `json:"token"`
}

// CallbackProviderParams defines parameters for CallbackProvider.
type CallbackProviderParams struct {
	// State Auth state
	State *AuthStateParam `form:"state,omitempty" json:"state,omitempty"`

	// Code Auth code
	Code *AuthCodeParam `form:"code,omitempty" json:"code,omitempty"`
}

// ListFabricsParams defines parameters for ListFabrics.
type ListFabricsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteFabricFromBuildJSONBody defines parameters for DeleteFabricFromBuild.
type DeleteFabricFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListFabricBuildsParams defines parameters for ListFabricBuilds.
type ListFabricBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListFabricBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListFabricBuildsParamsOrder defines parameters for ListFabricBuilds.
type ListFabricBuildsParamsOrder string

// AttachFabricToBuildJSONBody defines parameters for AttachFabricToBuild.
type AttachFabricToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListForgesParams defines parameters for ListForges.
type ListForgesParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteForgeFromBuildJSONBody defines parameters for DeleteForgeFromBuild.
type DeleteForgeFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListForgeBuildsParams defines parameters for ListForgeBuilds.
type ListForgeBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListForgeBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListForgeBuildsParamsOrder defines parameters for ListForgeBuilds.
type ListForgeBuildsParamsOrder string

// AttachForgeToBuildJSONBody defines parameters for AttachForgeToBuild.
type AttachForgeToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupsParamsOrder defines parameters for ListGroups.
type ListGroupsParamsOrder string

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateGroupJSONBody defines parameters for UpdateGroup.
type UpdateGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// DeleteGroupFromModJSONBody defines parameters for DeleteGroupFromMod.
type DeleteGroupFromModJSONBody struct {
	Mod string `json:"mod"`
}

// ListGroupModsParams defines parameters for ListGroupMods.
type ListGroupModsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupModsParamsOrder defines parameters for ListGroupMods.
type ListGroupModsParamsOrder string

// AttachGroupToModJSONBody defines parameters for AttachGroupToMod.
type AttachGroupToModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// PermitGroupModJSONBody defines parameters for PermitGroupMod.
type PermitGroupModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// DeleteGroupFromPackJSONBody defines parameters for DeleteGroupFromPack.
type DeleteGroupFromPackJSONBody struct {
	Pack string `json:"pack"`
}

// ListGroupPacksParams defines parameters for ListGroupPacks.
type ListGroupPacksParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupPacksParamsOrder defines parameters for ListGroupPacks.
type ListGroupPacksParamsOrder string

// AttachGroupToPackJSONBody defines parameters for AttachGroupToPack.
type AttachGroupToPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// PermitGroupPackJSONBody defines parameters for PermitGroupPack.
type PermitGroupPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// DeleteGroupFromUserJSONBody defines parameters for DeleteGroupFromUser.
type DeleteGroupFromUserJSONBody struct {
	User string `json:"user"`
}

// ListGroupUsersParams defines parameters for ListGroupUsers.
type ListGroupUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupUsersParamsOrder defines parameters for ListGroupUsers.
type ListGroupUsersParamsOrder string

// AttachGroupToUserJSONBody defines parameters for AttachGroupToUser.
type AttachGroupToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitGroupUserJSONBody defines parameters for PermitGroupUser.
type PermitGroupUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// ListMinecraftsParams defines parameters for ListMinecrafts.
type ListMinecraftsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteMinecraftFromBuildJSONBody defines parameters for DeleteMinecraftFromBuild.
type DeleteMinecraftFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListMinecraftBuildsParams defines parameters for ListMinecraftBuilds.
type ListMinecraftBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListMinecraftBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListMinecraftBuildsParamsOrder defines parameters for ListMinecraftBuilds.
type ListMinecraftBuildsParamsOrder string

// AttachMinecraftToBuildJSONBody defines parameters for AttachMinecraftToBuild.
type AttachMinecraftToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListModsParams defines parameters for ListMods.
type ListModsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModsParamsOrder defines parameters for ListMods.
type ListModsParamsOrder string

// CreateModJSONBody defines parameters for CreateMod.
type CreateModJSONBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// UpdateModJSONBody defines parameters for UpdateMod.
type UpdateModJSONBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// CreateModAvatarMultipartBody defines parameters for CreateModAvatar.
type CreateModAvatarMultipartBody struct {
	File *openapi_types.File `json:"file,omitempty"`
}

// DeleteModFromGroupJSONBody defines parameters for DeleteModFromGroup.
type DeleteModFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListModGroupsParams defines parameters for ListModGroups.
type ListModGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModGroupsParamsOrder defines parameters for ListModGroups.
type ListModGroupsParamsOrder string

// AttachModToGroupJSONBody defines parameters for AttachModToGroup.
type AttachModToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitModGroupJSONBody defines parameters for PermitModGroup.
type PermitModGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// DeleteModFromUserJSONBody defines parameters for DeleteModFromUser.
type DeleteModFromUserJSONBody struct {
	User string `json:"user"`
}

// ListModUsersParams defines parameters for ListModUsers.
type ListModUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModUsersParamsOrder defines parameters for ListModUsers.
type ListModUsersParamsOrder string

// AttachModToUserJSONBody defines parameters for AttachModToUser.
type AttachModToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitModUserJSONBody defines parameters for PermitModUser.
type PermitModUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// ListVersionsParams defines parameters for ListVersions.
type ListVersionsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListVersionsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListVersionsParamsOrder defines parameters for ListVersions.
type ListVersionsParamsOrder string

// CreateVersionJSONBody defines parameters for CreateVersion.
type CreateVersionJSONBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// UpdateVersionJSONBody defines parameters for UpdateVersion.
type UpdateVersionJSONBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// DeleteVersionFromBuildJSONBody defines parameters for DeleteVersionFromBuild.
type DeleteVersionFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListVersionBuildsParams defines parameters for ListVersionBuilds.
type ListVersionBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListVersionBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListVersionBuildsParamsOrder defines parameters for ListVersionBuilds.
type ListVersionBuildsParamsOrder string

// AttachVersionToBuildJSONBody defines parameters for AttachVersionToBuild.
type AttachVersionToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListNeoforgesParams defines parameters for ListNeoforges.
type ListNeoforgesParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteNeoforgeFromBuildJSONBody defines parameters for DeleteNeoforgeFromBuild.
type DeleteNeoforgeFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListNeoforgeBuildsParams defines parameters for ListNeoforgeBuilds.
type ListNeoforgeBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListNeoforgeBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListNeoforgeBuildsParamsOrder defines parameters for ListNeoforgeBuilds.
type ListNeoforgeBuildsParamsOrder string

// AttachNeoforgeToBuildJSONBody defines parameters for AttachNeoforgeToBuild.
type AttachNeoforgeToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListPacksParams defines parameters for ListPacks.
type ListPacksParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPacksParamsOrder defines parameters for ListPacks.
type ListPacksParamsOrder string

// CreatePackJSONBody defines parameters for CreatePack.
type CreatePackJSONBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// UpdatePackJSONBody defines parameters for UpdatePack.
type UpdatePackJSONBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// CreatePackAvatarMultipartBody defines parameters for CreatePackAvatar.
type CreatePackAvatarMultipartBody struct {
	File *openapi_types.File `json:"file,omitempty"`
}

// ListBuildsParams defines parameters for ListBuilds.
type ListBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListBuildsParamsOrder defines parameters for ListBuilds.
type ListBuildsParamsOrder string

// CreateBuildJSONBody defines parameters for CreateBuild.
type CreateBuildJSONBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// UpdateBuildJSONBody defines parameters for UpdateBuild.
type UpdateBuildJSONBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// DeleteBuildFromVersionJSONBody defines parameters for DeleteBuildFromVersion.
type DeleteBuildFromVersionJSONBody struct {
	Mod     string `json:"mod,omitempty"`
	Version string `json:"version,omitempty"`
}

// ListBuildVersionsParams defines parameters for ListBuildVersions.
type ListBuildVersionsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListBuildVersionsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListBuildVersionsParamsOrder defines parameters for ListBuildVersions.
type ListBuildVersionsParamsOrder string

// AttachBuildToVersionJSONBody defines parameters for AttachBuildToVersion.
type AttachBuildToVersionJSONBody struct {
	Mod     string `json:"mod,omitempty"`
	Version string `json:"version,omitempty"`
}

// DeletePackFromGroupJSONBody defines parameters for DeletePackFromGroup.
type DeletePackFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListPackGroupsParams defines parameters for ListPackGroups.
type ListPackGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPackGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPackGroupsParamsOrder defines parameters for ListPackGroups.
type ListPackGroupsParamsOrder string

// AttachPackToGroupJSONBody defines parameters for AttachPackToGroup.
type AttachPackToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitPackGroupJSONBody defines parameters for PermitPackGroup.
type PermitPackGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// DeletePackFromUserJSONBody defines parameters for DeletePackFromUser.
type DeletePackFromUserJSONBody struct {
	User string `json:"user"`
}

// ListPackUsersParams defines parameters for ListPackUsers.
type ListPackUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPackUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPackUsersParamsOrder defines parameters for ListPackUsers.
type ListPackUsersParamsOrder string

// AttachPackToUserJSONBody defines parameters for AttachPackToUser.
type AttachPackToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitPackUserJSONBody defines parameters for PermitPackUser.
type PermitPackUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// UpdateProfileJSONBody defines parameters for UpdateProfile.
type UpdateProfileJSONBody struct {
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// ListQuiltsParams defines parameters for ListQuilts.
type ListQuiltsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteQuiltFromBuildJSONBody defines parameters for DeleteQuiltFromBuild.
type DeleteQuiltFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListQuiltBuildsParams defines parameters for ListQuiltBuilds.
type ListQuiltBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListQuiltBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListQuiltBuildsParamsOrder defines parameters for ListQuiltBuilds.
type ListQuiltBuildsParamsOrder string

// AttachQuiltToBuildJSONBody defines parameters for AttachQuiltToBuild.
type AttachQuiltToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUsersParamsOrder defines parameters for ListUsers.
type ListUsersParamsOrder string

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// DeleteUserFromGroupJSONBody defines parameters for DeleteUserFromGroup.
type DeleteUserFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListUserGroupsParams defines parameters for ListUserGroups.
type ListUserGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserGroupsParamsOrder defines parameters for ListUserGroups.
type ListUserGroupsParamsOrder string

// AttachUserToGroupJSONBody defines parameters for AttachUserToGroup.
type AttachUserToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitUserGroupJSONBody defines parameters for PermitUserGroup.
type PermitUserGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// DeleteUserFromModJSONBody defines parameters for DeleteUserFromMod.
type DeleteUserFromModJSONBody struct {
	Mod string `json:"mod"`
}

// ListUserModsParams defines parameters for ListUserMods.
type ListUserModsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserModsParamsOrder defines parameters for ListUserMods.
type ListUserModsParamsOrder string

// AttachUserToModJSONBody defines parameters for AttachUserToMod.
type AttachUserToModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// PermitUserModJSONBody defines parameters for PermitUserMod.
type PermitUserModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// DeleteUserFromPackJSONBody defines parameters for DeleteUserFromPack.
type DeleteUserFromPackJSONBody struct {
	Pack string `json:"pack"`
}

// ListUserPacksParams defines parameters for ListUserPacks.
type ListUserPacksParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserPacksParamsOrder defines parameters for ListUserPacks.
type ListUserPacksParamsOrder string

// AttachUserToPackJSONBody defines parameters for AttachUserToPack.
type AttachUserToPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// PermitUserPackJSONBody defines parameters for PermitUserPack.
type PermitUserPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// LoginAuthJSONRequestBody defines body for LoginAuth for application/json ContentType.
type LoginAuthJSONRequestBody LoginAuthJSONBody

// RedirectAuthJSONRequestBody defines body for RedirectAuth for application/json ContentType.
type RedirectAuthJSONRequestBody RedirectAuthJSONBody

// DeleteFabricFromBuildJSONRequestBody defines body for DeleteFabricFromBuild for application/json ContentType.
type DeleteFabricFromBuildJSONRequestBody DeleteFabricFromBuildJSONBody

// AttachFabricToBuildJSONRequestBody defines body for AttachFabricToBuild for application/json ContentType.
type AttachFabricToBuildJSONRequestBody AttachFabricToBuildJSONBody

// DeleteForgeFromBuildJSONRequestBody defines body for DeleteForgeFromBuild for application/json ContentType.
type DeleteForgeFromBuildJSONRequestBody DeleteForgeFromBuildJSONBody

// AttachForgeToBuildJSONRequestBody defines body for AttachForgeToBuild for application/json ContentType.
type AttachForgeToBuildJSONRequestBody AttachForgeToBuildJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody UpdateGroupJSONBody

// DeleteGroupFromModJSONRequestBody defines body for DeleteGroupFromMod for application/json ContentType.
type DeleteGroupFromModJSONRequestBody DeleteGroupFromModJSONBody

// AttachGroupToModJSONRequestBody defines body for AttachGroupToMod for application/json ContentType.
type AttachGroupToModJSONRequestBody AttachGroupToModJSONBody

// PermitGroupModJSONRequestBody defines body for PermitGroupMod for application/json ContentType.
type PermitGroupModJSONRequestBody PermitGroupModJSONBody

// DeleteGroupFromPackJSONRequestBody defines body for DeleteGroupFromPack for application/json ContentType.
type DeleteGroupFromPackJSONRequestBody DeleteGroupFromPackJSONBody

// AttachGroupToPackJSONRequestBody defines body for AttachGroupToPack for application/json ContentType.
type AttachGroupToPackJSONRequestBody AttachGroupToPackJSONBody

// PermitGroupPackJSONRequestBody defines body for PermitGroupPack for application/json ContentType.
type PermitGroupPackJSONRequestBody PermitGroupPackJSONBody

// DeleteGroupFromUserJSONRequestBody defines body for DeleteGroupFromUser for application/json ContentType.
type DeleteGroupFromUserJSONRequestBody DeleteGroupFromUserJSONBody

// AttachGroupToUserJSONRequestBody defines body for AttachGroupToUser for application/json ContentType.
type AttachGroupToUserJSONRequestBody AttachGroupToUserJSONBody

// PermitGroupUserJSONRequestBody defines body for PermitGroupUser for application/json ContentType.
type PermitGroupUserJSONRequestBody PermitGroupUserJSONBody

// DeleteMinecraftFromBuildJSONRequestBody defines body for DeleteMinecraftFromBuild for application/json ContentType.
type DeleteMinecraftFromBuildJSONRequestBody DeleteMinecraftFromBuildJSONBody

// AttachMinecraftToBuildJSONRequestBody defines body for AttachMinecraftToBuild for application/json ContentType.
type AttachMinecraftToBuildJSONRequestBody AttachMinecraftToBuildJSONBody

// CreateModJSONRequestBody defines body for CreateMod for application/json ContentType.
type CreateModJSONRequestBody CreateModJSONBody

// UpdateModJSONRequestBody defines body for UpdateMod for application/json ContentType.
type UpdateModJSONRequestBody UpdateModJSONBody

// CreateModAvatarMultipartRequestBody defines body for CreateModAvatar for multipart/form-data ContentType.
type CreateModAvatarMultipartRequestBody CreateModAvatarMultipartBody

// DeleteModFromGroupJSONRequestBody defines body for DeleteModFromGroup for application/json ContentType.
type DeleteModFromGroupJSONRequestBody DeleteModFromGroupJSONBody

// AttachModToGroupJSONRequestBody defines body for AttachModToGroup for application/json ContentType.
type AttachModToGroupJSONRequestBody AttachModToGroupJSONBody

// PermitModGroupJSONRequestBody defines body for PermitModGroup for application/json ContentType.
type PermitModGroupJSONRequestBody PermitModGroupJSONBody

// DeleteModFromUserJSONRequestBody defines body for DeleteModFromUser for application/json ContentType.
type DeleteModFromUserJSONRequestBody DeleteModFromUserJSONBody

// AttachModToUserJSONRequestBody defines body for AttachModToUser for application/json ContentType.
type AttachModToUserJSONRequestBody AttachModToUserJSONBody

// PermitModUserJSONRequestBody defines body for PermitModUser for application/json ContentType.
type PermitModUserJSONRequestBody PermitModUserJSONBody

// CreateVersionJSONRequestBody defines body for CreateVersion for application/json ContentType.
type CreateVersionJSONRequestBody CreateVersionJSONBody

// UpdateVersionJSONRequestBody defines body for UpdateVersion for application/json ContentType.
type UpdateVersionJSONRequestBody UpdateVersionJSONBody

// DeleteVersionFromBuildJSONRequestBody defines body for DeleteVersionFromBuild for application/json ContentType.
type DeleteVersionFromBuildJSONRequestBody DeleteVersionFromBuildJSONBody

// AttachVersionToBuildJSONRequestBody defines body for AttachVersionToBuild for application/json ContentType.
type AttachVersionToBuildJSONRequestBody AttachVersionToBuildJSONBody

// DeleteNeoforgeFromBuildJSONRequestBody defines body for DeleteNeoforgeFromBuild for application/json ContentType.
type DeleteNeoforgeFromBuildJSONRequestBody DeleteNeoforgeFromBuildJSONBody

// AttachNeoforgeToBuildJSONRequestBody defines body for AttachNeoforgeToBuild for application/json ContentType.
type AttachNeoforgeToBuildJSONRequestBody AttachNeoforgeToBuildJSONBody

// CreatePackJSONRequestBody defines body for CreatePack for application/json ContentType.
type CreatePackJSONRequestBody CreatePackJSONBody

// UpdatePackJSONRequestBody defines body for UpdatePack for application/json ContentType.
type UpdatePackJSONRequestBody UpdatePackJSONBody

// CreatePackAvatarMultipartRequestBody defines body for CreatePackAvatar for multipart/form-data ContentType.
type CreatePackAvatarMultipartRequestBody CreatePackAvatarMultipartBody

// CreateBuildJSONRequestBody defines body for CreateBuild for application/json ContentType.
type CreateBuildJSONRequestBody CreateBuildJSONBody

// UpdateBuildJSONRequestBody defines body for UpdateBuild for application/json ContentType.
type UpdateBuildJSONRequestBody UpdateBuildJSONBody

// DeleteBuildFromVersionJSONRequestBody defines body for DeleteBuildFromVersion for application/json ContentType.
type DeleteBuildFromVersionJSONRequestBody DeleteBuildFromVersionJSONBody

// AttachBuildToVersionJSONRequestBody defines body for AttachBuildToVersion for application/json ContentType.
type AttachBuildToVersionJSONRequestBody AttachBuildToVersionJSONBody

// DeletePackFromGroupJSONRequestBody defines body for DeletePackFromGroup for application/json ContentType.
type DeletePackFromGroupJSONRequestBody DeletePackFromGroupJSONBody

// AttachPackToGroupJSONRequestBody defines body for AttachPackToGroup for application/json ContentType.
type AttachPackToGroupJSONRequestBody AttachPackToGroupJSONBody

// PermitPackGroupJSONRequestBody defines body for PermitPackGroup for application/json ContentType.
type PermitPackGroupJSONRequestBody PermitPackGroupJSONBody

// DeletePackFromUserJSONRequestBody defines body for DeletePackFromUser for application/json ContentType.
type DeletePackFromUserJSONRequestBody DeletePackFromUserJSONBody

// AttachPackToUserJSONRequestBody defines body for AttachPackToUser for application/json ContentType.
type AttachPackToUserJSONRequestBody AttachPackToUserJSONBody

// PermitPackUserJSONRequestBody defines body for PermitPackUser for application/json ContentType.
type PermitPackUserJSONRequestBody PermitPackUserJSONBody

// UpdateProfileJSONRequestBody defines body for UpdateProfile for application/json ContentType.
type UpdateProfileJSONRequestBody UpdateProfileJSONBody

// DeleteQuiltFromBuildJSONRequestBody defines body for DeleteQuiltFromBuild for application/json ContentType.
type DeleteQuiltFromBuildJSONRequestBody DeleteQuiltFromBuildJSONBody

// AttachQuiltToBuildJSONRequestBody defines body for AttachQuiltToBuild for application/json ContentType.
type AttachQuiltToBuildJSONRequestBody AttachQuiltToBuildJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// DeleteUserFromGroupJSONRequestBody defines body for DeleteUserFromGroup for application/json ContentType.
type DeleteUserFromGroupJSONRequestBody DeleteUserFromGroupJSONBody

// AttachUserToGroupJSONRequestBody defines body for AttachUserToGroup for application/json ContentType.
type AttachUserToGroupJSONRequestBody AttachUserToGroupJSONBody

// PermitUserGroupJSONRequestBody defines body for PermitUserGroup for application/json ContentType.
type PermitUserGroupJSONRequestBody PermitUserGroupJSONBody

// DeleteUserFromModJSONRequestBody defines body for DeleteUserFromMod for application/json ContentType.
type DeleteUserFromModJSONRequestBody DeleteUserFromModJSONBody

// AttachUserToModJSONRequestBody defines body for AttachUserToMod for application/json ContentType.
type AttachUserToModJSONRequestBody AttachUserToModJSONBody

// PermitUserModJSONRequestBody defines body for PermitUserMod for application/json ContentType.
type PermitUserModJSONRequestBody PermitUserModJSONBody

// DeleteUserFromPackJSONRequestBody defines body for DeleteUserFromPack for application/json ContentType.
type DeleteUserFromPackJSONRequestBody DeleteUserFromPackJSONBody

// AttachUserToPackJSONRequestBody defines body for AttachUserToPack for application/json ContentType.
type AttachUserToPackJSONRequestBody AttachUserToPackJSONBody

// PermitUserPackJSONRequestBody defines body for PermitUserPack for application/json ContentType.
type PermitUserPackJSONRequestBody PermitUserPackJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate an user by credentials
	// (POST /auth/login)
	LoginAuth(w http.ResponseWriter, r *http.Request)
	// Fetch the available auth providers
	// (GET /auth/providers)
	ListProviders(w http.ResponseWriter, r *http.Request)
	// Retrieve real token after redirect
	// (POST /auth/redirect)
	RedirectAuth(w http.ResponseWriter, r *http.Request)
	// Refresh an auth token before it expires
	// (GET /auth/refresh)
	RefreshAuth(w http.ResponseWriter, r *http.Request)
	// Verify validity for an authentication token
	// (GET /auth/verify)
	VerifyAuth(w http.ResponseWriter, r *http.Request)
	// Callback to parse the defined provider
	// (GET /auth/{provider}/callback)
	CallbackProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam, params CallbackProviderParams)
	// Request the redirect to defined provider
	// (GET /auth/{provider}/request)
	RequestProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam)
	// Fetch the available Fabric versions
	// (GET /fabric)
	ListFabrics(w http.ResponseWriter, r *http.Request, params ListFabricsParams)
	// Update the available Fabric versions
	// (PUT /fabric)
	UpdateFabric(w http.ResponseWriter, r *http.Request)
	// Unlink a build from a Fabric version
	// (DELETE /fabric/{fabric_id}/builds)
	DeleteFabricFromBuild(w http.ResponseWriter, r *http.Request, fabricID FabricID)
	// Fetch the builds attached to a Fabric version
	// (GET /fabric/{fabric_id}/builds)
	ListFabricBuilds(w http.ResponseWriter, r *http.Request, fabricID FabricID, params ListFabricBuildsParams)
	// Attach a build to a Fabric version
	// (POST /fabric/{fabric_id}/builds)
	AttachFabricToBuild(w http.ResponseWriter, r *http.Request, fabricID FabricID)
	// Fetch the available Forge versions
	// (GET /forge)
	ListForges(w http.ResponseWriter, r *http.Request, params ListForgesParams)
	// Update the available Forge versions
	// (PUT /forge)
	UpdateForge(w http.ResponseWriter, r *http.Request)
	// Unlink a build from a Forge version
	// (DELETE /forge/{forge_id}/builds)
	DeleteForgeFromBuild(w http.ResponseWriter, r *http.Request, forgeID ForgeID)
	// Fetch the builds attached to a Forge version
	// (GET /forge/{forge_id}/builds)
	ListForgeBuilds(w http.ResponseWriter, r *http.Request, forgeID ForgeID, params ListForgeBuildsParams)
	// Attach a build to a Forge version
	// (POST /forge/{forge_id}/builds)
	AttachForgeToBuild(w http.ResponseWriter, r *http.Request, forgeID ForgeID)
	// Fetch all available groups
	// (GET /groups)
	ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams)
	// Create a new group
	// (POST /groups)
	CreateGroup(w http.ResponseWriter, r *http.Request)
	// Delete a specific group
	// (DELETE /groups/{group_id})
	DeleteGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch a specific group
	// (GET /groups/{group_id})
	ShowGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update a specific group
	// (PUT /groups/{group_id})
	UpdateGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Unlink a mod from group
	// (DELETE /groups/{group_id}/mods)
	DeleteGroupFromMod(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch all mods attached to group
	// (GET /groups/{group_id}/mods)
	ListGroupMods(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupModsParams)
	// Attach a mod to group
	// (POST /groups/{group_id}/mods)
	AttachGroupToMod(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update mod perms for group
	// (PUT /groups/{group_id}/mods)
	PermitGroupMod(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Unlink a pack from group
	// (DELETE /groups/{group_id}/packs)
	DeleteGroupFromPack(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch all packs attached to group
	// (GET /groups/{group_id}/packs)
	ListGroupPacks(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupPacksParams)
	// Attach a pack to group
	// (POST /groups/{group_id}/packs)
	AttachGroupToPack(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update pack perms for group
	// (PUT /groups/{group_id}/packs)
	PermitGroupPack(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Unlink a user from group
	// (DELETE /groups/{group_id}/users)
	DeleteGroupFromUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch all users attached to group
	// (GET /groups/{group_id}/users)
	ListGroupUsers(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupUsersParams)
	// Attach a user to group
	// (POST /groups/{group_id}/users)
	AttachGroupToUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update user perms for group
	// (PUT /groups/{group_id}/users)
	PermitGroupUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch the available Minecraft versions
	// (GET /minecraft)
	ListMinecrafts(w http.ResponseWriter, r *http.Request, params ListMinecraftsParams)
	// Update the available Minecraft versions
	// (PUT /minecraft)
	UpdateMinecraft(w http.ResponseWriter, r *http.Request)
	// Unlink a build from a Minecraft version
	// (DELETE /minecraft/{minecraft_id}/builds)
	DeleteMinecraftFromBuild(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID)
	// Fetch the builds attached to a Minecraft version
	// (GET /minecraft/{minecraft_id}/builds)
	ListMinecraftBuilds(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID, params ListMinecraftBuildsParams)
	// Attach a build to a Minecraft version
	// (POST /minecraft/{minecraft_id}/builds)
	AttachMinecraftToBuild(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID)
	// Fetch all available mods
	// (GET /mods)
	ListMods(w http.ResponseWriter, r *http.Request, params ListModsParams)
	// Create a new mod
	// (POST /mods)
	CreateMod(w http.ResponseWriter, r *http.Request)
	// Delete a specific mod
	// (DELETE /mods/{mod_id})
	DeleteMod(w http.ResponseWriter, r *http.Request, modID ModID)
	// Fetch a specific mod
	// (GET /mods/{mod_id})
	ShowMod(w http.ResponseWriter, r *http.Request, modID ModID)
	// Update a specific mod
	// (PUT /mods/{mod_id})
	UpdateMod(w http.ResponseWriter, r *http.Request, modID ModID)
	// Delete the avatar for the defined mod
	// (DELETE /mods/{mod_id}/avatar)
	DeleteModAvatar(w http.ResponseWriter, r *http.Request, modID ModID)
	// Upload an avatar for the defined mod
	// (POST /mods/{mod_id}/avatar)
	CreateModAvatar(w http.ResponseWriter, r *http.Request, modID ModID)
	// Unlink a group from mod
	// (DELETE /mods/{mod_id}/groups)
	DeleteModFromGroup(w http.ResponseWriter, r *http.Request, modID ModID)
	// Fetch all groups attached to mod
	// (GET /mods/{mod_id}/groups)
	ListModGroups(w http.ResponseWriter, r *http.Request, modID ModID, params ListModGroupsParams)
	// Attach a group to mod
	// (POST /mods/{mod_id}/groups)
	AttachModToGroup(w http.ResponseWriter, r *http.Request, modID ModID)
	// Update group perms for mod
	// (PUT /mods/{mod_id}/groups)
	PermitModGroup(w http.ResponseWriter, r *http.Request, modID ModID)
	// Unlink a user from mod
	// (DELETE /mods/{mod_id}/users)
	DeleteModFromUser(w http.ResponseWriter, r *http.Request, modID ModID)
	// Fetch all users attached to mod
	// (GET /mods/{mod_id}/users)
	ListModUsers(w http.ResponseWriter, r *http.Request, modID ModID, params ListModUsersParams)
	// Attach a user to mod
	// (POST /mods/{mod_id}/users)
	AttachModToUser(w http.ResponseWriter, r *http.Request, modID ModID)
	// Update user perms for mod
	// (PUT /mods/{mod_id}/users)
	PermitModUser(w http.ResponseWriter, r *http.Request, modID ModID)
	// Fetch all available versions for a mod
	// (GET /mods/{mod_id}/versions)
	ListVersions(w http.ResponseWriter, r *http.Request, modID ModID, params ListVersionsParams)
	// Create a new version for a mod
	// (POST /mods/{mod_id}/versions)
	CreateVersion(w http.ResponseWriter, r *http.Request, modID ModID)
	// Delete a specific version for a mod
	// (DELETE /mods/{mod_id}/versions/{version_id})
	DeleteVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID)
	// Fetch a specific version for a mod
	// (GET /mods/{mod_id}/versions/{version_id})
	ShowVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID)
	// Update a specific version for a mod
	// (PUT /mods/{mod_id}/versions/{version_id})
	UpdateVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID)
	// Unlink a build from a version
	// (DELETE /mods/{mod_id}/versions/{version_id}/builds)
	DeleteVersionFromBuild(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID)
	// Fetch all builds attached to version
	// (GET /mods/{mod_id}/versions/{version_id}/builds)
	ListVersionBuilds(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID, params ListVersionBuildsParams)
	// Attach a build to a version
	// (POST /mods/{mod_id}/versions/{version_id}/builds)
	AttachVersionToBuild(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID)
	// Fetch the available Neoforge versions
	// (GET /neoforge)
	ListNeoforges(w http.ResponseWriter, r *http.Request, params ListNeoforgesParams)
	// Update the available Neoforge versions
	// (PUT /neoforge)
	UpdateNeoforge(w http.ResponseWriter, r *http.Request)
	// Unlink a build from a Neoforge version
	// (DELETE /neoforge/{neoforge_id}/builds)
	DeleteNeoforgeFromBuild(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID)
	// Fetch the builds attached to a Neoforge version
	// (GET /neoforge/{neoforge_id}/builds)
	ListNeoforgeBuilds(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID, params ListNeoforgeBuildsParams)
	// Attach a build to a Neoforge version
	// (POST /neoforge/{neoforge_id}/builds)
	AttachNeoforgeToBuild(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID)
	// Fetch all available packs
	// (GET /packs)
	ListPacks(w http.ResponseWriter, r *http.Request, params ListPacksParams)
	// Create a new pack
	// (POST /packs)
	CreatePack(w http.ResponseWriter, r *http.Request)
	// Delete a specific pack
	// (DELETE /packs/{pack_id})
	DeletePack(w http.ResponseWriter, r *http.Request, packID PackID)
	// Fetch a specific pack
	// (GET /packs/{pack_id})
	ShowPack(w http.ResponseWriter, r *http.Request, packID PackID)
	// Update a specific pack
	// (PUT /packs/{pack_id})
	UpdatePack(w http.ResponseWriter, r *http.Request, packID PackID)
	// Delete the avatar for the defined pack
	// (DELETE /packs/{pack_id}/avatar)
	DeletePackAvatar(w http.ResponseWriter, r *http.Request, packID PackID)
	// Upload an avatar for the defined pack
	// (POST /packs/{pack_id}/avatar)
	CreatePackAvatar(w http.ResponseWriter, r *http.Request, packID PackID)
	// Fetch all available builds for a pack
	// (GET /packs/{pack_id}/builds)
	ListBuilds(w http.ResponseWriter, r *http.Request, packID PackID, params ListBuildsParams)
	// Create a new build for a pack
	// (POST /packs/{pack_id}/builds)
	CreateBuild(w http.ResponseWriter, r *http.Request, packID PackID)
	// Delete a specific build for a pack
	// (DELETE /packs/{pack_id}/builds/{build_id})
	DeleteBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID)
	// Fetch a specific build for a pack
	// (GET /packs/{pack_id}/builds/{build_id})
	ShowBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID)
	// Update a specific build for a pack
	// (PUT /packs/{pack_id}/builds/{build_id})
	UpdateBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID)
	// Unlink a version from a build
	// (DELETE /packs/{pack_id}/builds/{build_id}/versions)
	DeleteBuildFromVersion(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID)
	// Fetch all versions attached to build
	// (GET /packs/{pack_id}/builds/{build_id}/versions)
	ListBuildVersions(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID, params ListBuildVersionsParams)
	// Attach a version to a build
	// (POST /packs/{pack_id}/builds/{build_id}/versions)
	AttachBuildToVersion(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID)
	// Unlink a group from pack
	// (DELETE /packs/{pack_id}/groups)
	DeletePackFromGroup(w http.ResponseWriter, r *http.Request, packID PackID)
	// Fetch all groups attached to pack
	// (GET /packs/{pack_id}/groups)
	ListPackGroups(w http.ResponseWriter, r *http.Request, packID PackID, params ListPackGroupsParams)
	// Attach a group to pack
	// (POST /packs/{pack_id}/groups)
	AttachPackToGroup(w http.ResponseWriter, r *http.Request, packID PackID)
	// Update group perms for pack
	// (PUT /packs/{pack_id}/groups)
	PermitPackGroup(w http.ResponseWriter, r *http.Request, packID PackID)
	// Unlink a user from pack
	// (DELETE /packs/{pack_id}/users)
	DeletePackFromUser(w http.ResponseWriter, r *http.Request, packID PackID)
	// Fetch all users attached to pack
	// (GET /packs/{pack_id}/users)
	ListPackUsers(w http.ResponseWriter, r *http.Request, packID PackID, params ListPackUsersParams)
	// Attach a user to pack
	// (POST /packs/{pack_id}/users)
	AttachPackToUser(w http.ResponseWriter, r *http.Request, packID PackID)
	// Update user perms for pack
	// (PUT /packs/{pack_id}/users)
	PermitPackUser(w http.ResponseWriter, r *http.Request, packID PackID)
	// Fetch profile details of the personal account
	// (GET /profile/self)
	ShowProfile(w http.ResponseWriter, r *http.Request)
	// Update your own profile information
	// (PUT /profile/self)
	UpdateProfile(w http.ResponseWriter, r *http.Request)
	// Retrieve an unlimited auth token
	// (GET /profile/token)
	TokenProfile(w http.ResponseWriter, r *http.Request)
	// Fetch the available Quilt versions
	// (GET /quilt)
	ListQuilts(w http.ResponseWriter, r *http.Request, params ListQuiltsParams)
	// Update the available Quilt versions
	// (PUT /quilt)
	UpdateQuilt(w http.ResponseWriter, r *http.Request)
	// Unlink a build from a Quilt version
	// (DELETE /quilt/{quilt_id}/builds)
	DeleteQuiltFromBuild(w http.ResponseWriter, r *http.Request, quiltID QuiltID)
	// Fetch the builds attached to a Quilt version
	// (GET /quilt/{quilt_id}/builds)
	ListQuiltBuilds(w http.ResponseWriter, r *http.Request, quiltID QuiltID, params ListQuiltBuildsParams)
	// Attach a build to a Quilt version
	// (POST /quilt/{quilt_id}/builds)
	AttachQuiltToBuild(w http.ResponseWriter, r *http.Request, quiltID QuiltID)
	// Fetch all available users
	// (GET /users)
	ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams)
	// Create a new user
	// (POST /users)
	CreateUser(w http.ResponseWriter, r *http.Request)
	// Delete a specific user
	// (DELETE /users/{user_id})
	DeleteUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch a specific user
	// (GET /users/{user_id})
	ShowUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update a specific user
	// (PUT /users/{user_id})
	UpdateUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Unlink a group from user
	// (DELETE /users/{user_id}/groups)
	DeleteUserFromGroup(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch all groups attached to user
	// (GET /users/{user_id}/groups)
	ListUserGroups(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserGroupsParams)
	// Attach a group to user
	// (POST /users/{user_id}/groups)
	AttachUserToGroup(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update group perms for user
	// (PUT /users/{user_id}/groups)
	PermitUserGroup(w http.ResponseWriter, r *http.Request, userID UserID)
	// Unlink a mod from user
	// (DELETE /users/{user_id}/mods)
	DeleteUserFromMod(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch all mods attached to user
	// (GET /users/{user_id}/mods)
	ListUserMods(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserModsParams)
	// Attach a mod to user
	// (POST /users/{user_id}/mods)
	AttachUserToMod(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update mod perms for user
	// (PUT /users/{user_id}/mods)
	PermitUserMod(w http.ResponseWriter, r *http.Request, userID UserID)
	// Unlink a pack from user
	// (DELETE /users/{user_id}/packs)
	DeleteUserFromPack(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch all packs attached to user
	// (GET /users/{user_id}/packs)
	ListUserPacks(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserPacksParams)
	// Attach a pack to user
	// (POST /users/{user_id}/packs)
	AttachUserToPack(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update pack perms for user
	// (PUT /users/{user_id}/packs)
	PermitUserPack(w http.ResponseWriter, r *http.Request, userID UserID)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Authenticate an user by credentials
// (POST /auth/login)
func (_ Unimplemented) LoginAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available auth providers
// (GET /auth/providers)
func (_ Unimplemented) ListProviders(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve real token after redirect
// (POST /auth/redirect)
func (_ Unimplemented) RedirectAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Refresh an auth token before it expires
// (GET /auth/refresh)
func (_ Unimplemented) RefreshAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Verify validity for an authentication token
// (GET /auth/verify)
func (_ Unimplemented) VerifyAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Callback to parse the defined provider
// (GET /auth/{provider}/callback)
func (_ Unimplemented) CallbackProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam, params CallbackProviderParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Request the redirect to defined provider
// (GET /auth/{provider}/request)
func (_ Unimplemented) RequestProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available Fabric versions
// (GET /fabric)
func (_ Unimplemented) ListFabrics(w http.ResponseWriter, r *http.Request, params ListFabricsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update the available Fabric versions
// (PUT /fabric)
func (_ Unimplemented) UpdateFabric(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a Fabric version
// (DELETE /fabric/{fabric_id}/builds)
func (_ Unimplemented) DeleteFabricFromBuild(w http.ResponseWriter, r *http.Request, fabricID FabricID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the builds attached to a Fabric version
// (GET /fabric/{fabric_id}/builds)
func (_ Unimplemented) ListFabricBuilds(w http.ResponseWriter, r *http.Request, fabricID FabricID, params ListFabricBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a Fabric version
// (POST /fabric/{fabric_id}/builds)
func (_ Unimplemented) AttachFabricToBuild(w http.ResponseWriter, r *http.Request, fabricID FabricID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available Forge versions
// (GET /forge)
func (_ Unimplemented) ListForges(w http.ResponseWriter, r *http.Request, params ListForgesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update the available Forge versions
// (PUT /forge)
func (_ Unimplemented) UpdateForge(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a Forge version
// (DELETE /forge/{forge_id}/builds)
func (_ Unimplemented) DeleteForgeFromBuild(w http.ResponseWriter, r *http.Request, forgeID ForgeID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the builds attached to a Forge version
// (GET /forge/{forge_id}/builds)
func (_ Unimplemented) ListForgeBuilds(w http.ResponseWriter, r *http.Request, forgeID ForgeID, params ListForgeBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a Forge version
// (POST /forge/{forge_id}/builds)
func (_ Unimplemented) AttachForgeToBuild(w http.ResponseWriter, r *http.Request, forgeID ForgeID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available groups
// (GET /groups)
func (_ Unimplemented) ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new group
// (POST /groups)
func (_ Unimplemented) CreateGroup(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific group
// (DELETE /groups/{group_id})
func (_ Unimplemented) DeleteGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific group
// (GET /groups/{group_id})
func (_ Unimplemented) ShowGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific group
// (PUT /groups/{group_id})
func (_ Unimplemented) UpdateGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a mod from group
// (DELETE /groups/{group_id}/mods)
func (_ Unimplemented) DeleteGroupFromMod(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all mods attached to group
// (GET /groups/{group_id}/mods)
func (_ Unimplemented) ListGroupMods(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupModsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a mod to group
// (POST /groups/{group_id}/mods)
func (_ Unimplemented) AttachGroupToMod(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update mod perms for group
// (PUT /groups/{group_id}/mods)
func (_ Unimplemented) PermitGroupMod(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a pack from group
// (DELETE /groups/{group_id}/packs)
func (_ Unimplemented) DeleteGroupFromPack(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all packs attached to group
// (GET /groups/{group_id}/packs)
func (_ Unimplemented) ListGroupPacks(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupPacksParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a pack to group
// (POST /groups/{group_id}/packs)
func (_ Unimplemented) AttachGroupToPack(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update pack perms for group
// (PUT /groups/{group_id}/packs)
func (_ Unimplemented) PermitGroupPack(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a user from group
// (DELETE /groups/{group_id}/users)
func (_ Unimplemented) DeleteGroupFromUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all users attached to group
// (GET /groups/{group_id}/users)
func (_ Unimplemented) ListGroupUsers(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a user to group
// (POST /groups/{group_id}/users)
func (_ Unimplemented) AttachGroupToUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update user perms for group
// (PUT /groups/{group_id}/users)
func (_ Unimplemented) PermitGroupUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available Minecraft versions
// (GET /minecraft)
func (_ Unimplemented) ListMinecrafts(w http.ResponseWriter, r *http.Request, params ListMinecraftsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update the available Minecraft versions
// (PUT /minecraft)
func (_ Unimplemented) UpdateMinecraft(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a Minecraft version
// (DELETE /minecraft/{minecraft_id}/builds)
func (_ Unimplemented) DeleteMinecraftFromBuild(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the builds attached to a Minecraft version
// (GET /minecraft/{minecraft_id}/builds)
func (_ Unimplemented) ListMinecraftBuilds(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID, params ListMinecraftBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a Minecraft version
// (POST /minecraft/{minecraft_id}/builds)
func (_ Unimplemented) AttachMinecraftToBuild(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available mods
// (GET /mods)
func (_ Unimplemented) ListMods(w http.ResponseWriter, r *http.Request, params ListModsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new mod
// (POST /mods)
func (_ Unimplemented) CreateMod(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific mod
// (DELETE /mods/{mod_id})
func (_ Unimplemented) DeleteMod(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific mod
// (GET /mods/{mod_id})
func (_ Unimplemented) ShowMod(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific mod
// (PUT /mods/{mod_id})
func (_ Unimplemented) UpdateMod(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete the avatar for the defined mod
// (DELETE /mods/{mod_id}/avatar)
func (_ Unimplemented) DeleteModAvatar(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upload an avatar for the defined mod
// (POST /mods/{mod_id}/avatar)
func (_ Unimplemented) CreateModAvatar(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a group from mod
// (DELETE /mods/{mod_id}/groups)
func (_ Unimplemented) DeleteModFromGroup(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all groups attached to mod
// (GET /mods/{mod_id}/groups)
func (_ Unimplemented) ListModGroups(w http.ResponseWriter, r *http.Request, modID ModID, params ListModGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a group to mod
// (POST /mods/{mod_id}/groups)
func (_ Unimplemented) AttachModToGroup(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update group perms for mod
// (PUT /mods/{mod_id}/groups)
func (_ Unimplemented) PermitModGroup(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a user from mod
// (DELETE /mods/{mod_id}/users)
func (_ Unimplemented) DeleteModFromUser(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all users attached to mod
// (GET /mods/{mod_id}/users)
func (_ Unimplemented) ListModUsers(w http.ResponseWriter, r *http.Request, modID ModID, params ListModUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a user to mod
// (POST /mods/{mod_id}/users)
func (_ Unimplemented) AttachModToUser(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update user perms for mod
// (PUT /mods/{mod_id}/users)
func (_ Unimplemented) PermitModUser(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available versions for a mod
// (GET /mods/{mod_id}/versions)
func (_ Unimplemented) ListVersions(w http.ResponseWriter, r *http.Request, modID ModID, params ListVersionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new version for a mod
// (POST /mods/{mod_id}/versions)
func (_ Unimplemented) CreateVersion(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific version for a mod
// (DELETE /mods/{mod_id}/versions/{version_id})
func (_ Unimplemented) DeleteVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific version for a mod
// (GET /mods/{mod_id}/versions/{version_id})
func (_ Unimplemented) ShowVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific version for a mod
// (PUT /mods/{mod_id}/versions/{version_id})
func (_ Unimplemented) UpdateVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a version
// (DELETE /mods/{mod_id}/versions/{version_id}/builds)
func (_ Unimplemented) DeleteVersionFromBuild(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all builds attached to version
// (GET /mods/{mod_id}/versions/{version_id}/builds)
func (_ Unimplemented) ListVersionBuilds(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID, params ListVersionBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a version
// (POST /mods/{mod_id}/versions/{version_id}/builds)
func (_ Unimplemented) AttachVersionToBuild(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available Neoforge versions
// (GET /neoforge)
func (_ Unimplemented) ListNeoforges(w http.ResponseWriter, r *http.Request, params ListNeoforgesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update the available Neoforge versions
// (PUT /neoforge)
func (_ Unimplemented) UpdateNeoforge(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a Neoforge version
// (DELETE /neoforge/{neoforge_id}/builds)
func (_ Unimplemented) DeleteNeoforgeFromBuild(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the builds attached to a Neoforge version
// (GET /neoforge/{neoforge_id}/builds)
func (_ Unimplemented) ListNeoforgeBuilds(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID, params ListNeoforgeBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a Neoforge version
// (POST /neoforge/{neoforge_id}/builds)
func (_ Unimplemented) AttachNeoforgeToBuild(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available packs
// (GET /packs)
func (_ Unimplemented) ListPacks(w http.ResponseWriter, r *http.Request, params ListPacksParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new pack
// (POST /packs)
func (_ Unimplemented) CreatePack(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific pack
// (DELETE /packs/{pack_id})
func (_ Unimplemented) DeletePack(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific pack
// (GET /packs/{pack_id})
func (_ Unimplemented) ShowPack(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific pack
// (PUT /packs/{pack_id})
func (_ Unimplemented) UpdatePack(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete the avatar for the defined pack
// (DELETE /packs/{pack_id}/avatar)
func (_ Unimplemented) DeletePackAvatar(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upload an avatar for the defined pack
// (POST /packs/{pack_id}/avatar)
func (_ Unimplemented) CreatePackAvatar(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available builds for a pack
// (GET /packs/{pack_id}/builds)
func (_ Unimplemented) ListBuilds(w http.ResponseWriter, r *http.Request, packID PackID, params ListBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new build for a pack
// (POST /packs/{pack_id}/builds)
func (_ Unimplemented) CreateBuild(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific build for a pack
// (DELETE /packs/{pack_id}/builds/{build_id})
func (_ Unimplemented) DeleteBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific build for a pack
// (GET /packs/{pack_id}/builds/{build_id})
func (_ Unimplemented) ShowBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific build for a pack
// (PUT /packs/{pack_id}/builds/{build_id})
func (_ Unimplemented) UpdateBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a version from a build
// (DELETE /packs/{pack_id}/builds/{build_id}/versions)
func (_ Unimplemented) DeleteBuildFromVersion(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all versions attached to build
// (GET /packs/{pack_id}/builds/{build_id}/versions)
func (_ Unimplemented) ListBuildVersions(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID, params ListBuildVersionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a version to a build
// (POST /packs/{pack_id}/builds/{build_id}/versions)
func (_ Unimplemented) AttachBuildToVersion(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a group from pack
// (DELETE /packs/{pack_id}/groups)
func (_ Unimplemented) DeletePackFromGroup(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all groups attached to pack
// (GET /packs/{pack_id}/groups)
func (_ Unimplemented) ListPackGroups(w http.ResponseWriter, r *http.Request, packID PackID, params ListPackGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a group to pack
// (POST /packs/{pack_id}/groups)
func (_ Unimplemented) AttachPackToGroup(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update group perms for pack
// (PUT /packs/{pack_id}/groups)
func (_ Unimplemented) PermitPackGroup(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a user from pack
// (DELETE /packs/{pack_id}/users)
func (_ Unimplemented) DeletePackFromUser(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all users attached to pack
// (GET /packs/{pack_id}/users)
func (_ Unimplemented) ListPackUsers(w http.ResponseWriter, r *http.Request, packID PackID, params ListPackUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a user to pack
// (POST /packs/{pack_id}/users)
func (_ Unimplemented) AttachPackToUser(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update user perms for pack
// (PUT /packs/{pack_id}/users)
func (_ Unimplemented) PermitPackUser(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch profile details of the personal account
// (GET /profile/self)
func (_ Unimplemented) ShowProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update your own profile information
// (PUT /profile/self)
func (_ Unimplemented) UpdateProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve an unlimited auth token
// (GET /profile/token)
func (_ Unimplemented) TokenProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available Quilt versions
// (GET /quilt)
func (_ Unimplemented) ListQuilts(w http.ResponseWriter, r *http.Request, params ListQuiltsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update the available Quilt versions
// (PUT /quilt)
func (_ Unimplemented) UpdateQuilt(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a Quilt version
// (DELETE /quilt/{quilt_id}/builds)
func (_ Unimplemented) DeleteQuiltFromBuild(w http.ResponseWriter, r *http.Request, quiltID QuiltID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the builds attached to a Quilt version
// (GET /quilt/{quilt_id}/builds)
func (_ Unimplemented) ListQuiltBuilds(w http.ResponseWriter, r *http.Request, quiltID QuiltID, params ListQuiltBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a Quilt version
// (POST /quilt/{quilt_id}/builds)
func (_ Unimplemented) AttachQuiltToBuild(w http.ResponseWriter, r *http.Request, quiltID QuiltID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available users
// (GET /users)
func (_ Unimplemented) ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new user
// (POST /users)
func (_ Unimplemented) CreateUser(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific user
// (DELETE /users/{user_id})
func (_ Unimplemented) DeleteUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific user
// (GET /users/{user_id})
func (_ Unimplemented) ShowUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific user
// (PUT /users/{user_id})
func (_ Unimplemented) UpdateUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a group from user
// (DELETE /users/{user_id}/groups)
func (_ Unimplemented) DeleteUserFromGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all groups attached to user
// (GET /users/{user_id}/groups)
func (_ Unimplemented) ListUserGroups(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a group to user
// (POST /users/{user_id}/groups)
func (_ Unimplemented) AttachUserToGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update group perms for user
// (PUT /users/{user_id}/groups)
func (_ Unimplemented) PermitUserGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a mod from user
// (DELETE /users/{user_id}/mods)
func (_ Unimplemented) DeleteUserFromMod(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all mods attached to user
// (GET /users/{user_id}/mods)
func (_ Unimplemented) ListUserMods(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserModsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a mod to user
// (POST /users/{user_id}/mods)
func (_ Unimplemented) AttachUserToMod(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update mod perms for user
// (PUT /users/{user_id}/mods)
func (_ Unimplemented) PermitUserMod(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a pack from user
// (DELETE /users/{user_id}/packs)
func (_ Unimplemented) DeleteUserFromPack(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all packs attached to user
// (GET /users/{user_id}/packs)
func (_ Unimplemented) ListUserPacks(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserPacksParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a pack to user
// (POST /users/{user_id}/packs)
func (_ Unimplemented) AttachUserToPack(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update pack perms for user
// (PUT /users/{user_id}/packs)
func (_ Unimplemented) PermitUserPack(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// LoginAuth operation middleware
func (siw *ServerInterfaceWrapper) LoginAuth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LoginAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProviders operation middleware
func (siw *ServerInterfaceWrapper) ListProviders(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviders(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RedirectAuth operation middleware
func (siw *ServerInterfaceWrapper) RedirectAuth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RedirectAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RefreshAuth operation middleware
func (siw *ServerInterfaceWrapper) RefreshAuth(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RefreshAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// VerifyAuth operation middleware
func (siw *ServerInterfaceWrapper) VerifyAuth(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VerifyAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CallbackProvider operation middleware
func (siw *ServerInterfaceWrapper) CallbackProvider(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "provider" -------------
	var provider AuthProviderParam

	err = runtime.BindStyledParameterWithOptions("simple", "provider", chi.URLParam(r, "provider"), &provider, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provider", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CallbackProviderParams

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", r.URL.Query(), &params.Code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CallbackProvider(w, r, provider, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RequestProvider operation middleware
func (siw *ServerInterfaceWrapper) RequestProvider(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "provider" -------------
	var provider AuthProviderParam

	err = runtime.BindStyledParameterWithOptions("simple", "provider", chi.URLParam(r, "provider"), &provider, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provider", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RequestProvider(w, r, provider)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListFabrics operation middleware
func (siw *ServerInterfaceWrapper) ListFabrics(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFabricsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFabrics(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateFabric operation middleware
func (siw *ServerInterfaceWrapper) UpdateFabric(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateFabric(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteFabricFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteFabricFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "fabric_id" -------------
	var fabricID FabricID

	err = runtime.BindStyledParameterWithOptions("simple", "fabric_id", chi.URLParam(r, "fabric_id"), &fabricID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fabric_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFabricFromBuild(w, r, fabricID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListFabricBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListFabricBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "fabric_id" -------------
	var fabricID FabricID

	err = runtime.BindStyledParameterWithOptions("simple", "fabric_id", chi.URLParam(r, "fabric_id"), &fabricID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fabric_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFabricBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFabricBuilds(w, r, fabricID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachFabricToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachFabricToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "fabric_id" -------------
	var fabricID FabricID

	err = runtime.BindStyledParameterWithOptions("simple", "fabric_id", chi.URLParam(r, "fabric_id"), &fabricID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fabric_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachFabricToBuild(w, r, fabricID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListForges operation middleware
func (siw *ServerInterfaceWrapper) ListForges(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListForgesParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListForges(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateForge operation middleware
func (siw *ServerInterfaceWrapper) UpdateForge(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateForge(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteForgeFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteForgeFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "forge_id" -------------
	var forgeID ForgeID

	err = runtime.BindStyledParameterWithOptions("simple", "forge_id", chi.URLParam(r, "forge_id"), &forgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "forge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteForgeFromBuild(w, r, forgeID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListForgeBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListForgeBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "forge_id" -------------
	var forgeID ForgeID

	err = runtime.BindStyledParameterWithOptions("simple", "forge_id", chi.URLParam(r, "forge_id"), &forgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "forge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListForgeBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListForgeBuilds(w, r, forgeID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachForgeToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachForgeToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "forge_id" -------------
	var forgeID ForgeID

	err = runtime.BindStyledParameterWithOptions("simple", "forge_id", chi.URLParam(r, "forge_id"), &forgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "forge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachForgeToBuild(w, r, forgeID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroups operation middleware
func (siw *ServerInterfaceWrapper) ListGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroups(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowGroup operation middleware
func (siw *ServerInterfaceWrapper) ShowGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateGroup operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroupFromMod operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupFromMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupFromMod(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroupMods operation middleware
func (siw *ServerInterfaceWrapper) ListGroupMods(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupModsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupMods(w, r, groupID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachGroupToMod operation middleware
func (siw *ServerInterfaceWrapper) AttachGroupToMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachGroupToMod(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitGroupMod operation middleware
func (siw *ServerInterfaceWrapper) PermitGroupMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitGroupMod(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroupFromPack operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupFromPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupFromPack(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroupPacks operation middleware
func (siw *ServerInterfaceWrapper) ListGroupPacks(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupPacksParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupPacks(w, r, groupID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachGroupToPack operation middleware
func (siw *ServerInterfaceWrapper) AttachGroupToPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachGroupToPack(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitGroupPack operation middleware
func (siw *ServerInterfaceWrapper) PermitGroupPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitGroupPack(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroupFromUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupFromUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupFromUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroupUsers operation middleware
func (siw *ServerInterfaceWrapper) ListGroupUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupUsers(w, r, groupID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachGroupToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachGroupToUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachGroupToUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitGroupUser operation middleware
func (siw *ServerInterfaceWrapper) PermitGroupUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitGroupUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListMinecrafts operation middleware
func (siw *ServerInterfaceWrapper) ListMinecrafts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMinecraftsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListMinecrafts(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateMinecraft operation middleware
func (siw *ServerInterfaceWrapper) UpdateMinecraft(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateMinecraft(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteMinecraftFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteMinecraftFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "minecraft_id" -------------
	var minecraftID MinecraftID

	err = runtime.BindStyledParameterWithOptions("simple", "minecraft_id", chi.URLParam(r, "minecraft_id"), &minecraftID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "minecraft_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteMinecraftFromBuild(w, r, minecraftID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListMinecraftBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListMinecraftBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "minecraft_id" -------------
	var minecraftID MinecraftID

	err = runtime.BindStyledParameterWithOptions("simple", "minecraft_id", chi.URLParam(r, "minecraft_id"), &minecraftID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "minecraft_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMinecraftBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListMinecraftBuilds(w, r, minecraftID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachMinecraftToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachMinecraftToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "minecraft_id" -------------
	var minecraftID MinecraftID

	err = runtime.BindStyledParameterWithOptions("simple", "minecraft_id", chi.URLParam(r, "minecraft_id"), &minecraftID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "minecraft_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachMinecraftToBuild(w, r, minecraftID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListMods operation middleware
func (siw *ServerInterfaceWrapper) ListMods(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListModsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListMods(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateMod operation middleware
func (siw *ServerInterfaceWrapper) CreateMod(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateMod(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteMod operation middleware
func (siw *ServerInterfaceWrapper) DeleteMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteMod(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowMod operation middleware
func (siw *ServerInterfaceWrapper) ShowMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowMod(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateMod operation middleware
func (siw *ServerInterfaceWrapper) UpdateMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateMod(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteModAvatar operation middleware
func (siw *ServerInterfaceWrapper) DeleteModAvatar(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteModAvatar(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateModAvatar operation middleware
func (siw *ServerInterfaceWrapper) CreateModAvatar(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateModAvatar(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteModFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteModFromGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteModFromGroup(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModGroups operation middleware
func (siw *ServerInterfaceWrapper) ListModGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListModGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModGroups(w, r, modID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachModToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachModToGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachModToGroup(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitModGroup operation middleware
func (siw *ServerInterfaceWrapper) PermitModGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitModGroup(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteModFromUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteModFromUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteModFromUser(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModUsers operation middleware
func (siw *ServerInterfaceWrapper) ListModUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListModUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModUsers(w, r, modID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachModToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachModToUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachModToUser(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitModUser operation middleware
func (siw *ServerInterfaceWrapper) PermitModUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitModUser(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListVersions operation middleware
func (siw *ServerInterfaceWrapper) ListVersions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListVersionsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListVersions(w, r, modID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateVersion operation middleware
func (siw *ServerInterfaceWrapper) CreateVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateVersion(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteVersion operation middleware
func (siw *ServerInterfaceWrapper) DeleteVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteVersion(w, r, modID, versionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowVersion operation middleware
func (siw *ServerInterfaceWrapper) ShowVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowVersion(w, r, modID, versionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateVersion operation middleware
func (siw *ServerInterfaceWrapper) UpdateVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateVersion(w, r, modID, versionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteVersionFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteVersionFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteVersionFromBuild(w, r, modID, versionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListVersionBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListVersionBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListVersionBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListVersionBuilds(w, r, modID, versionID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachVersionToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachVersionToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachVersionToBuild(w, r, modID, versionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListNeoforges operation middleware
func (siw *ServerInterfaceWrapper) ListNeoforges(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNeoforgesParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNeoforges(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateNeoforge operation middleware
func (siw *ServerInterfaceWrapper) UpdateNeoforge(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateNeoforge(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteNeoforgeFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteNeoforgeFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "neoforge_id" -------------
	var neoforgeID NeoforgeID

	err = runtime.BindStyledParameterWithOptions("simple", "neoforge_id", chi.URLParam(r, "neoforge_id"), &neoforgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "neoforge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteNeoforgeFromBuild(w, r, neoforgeID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListNeoforgeBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListNeoforgeBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "neoforge_id" -------------
	var neoforgeID NeoforgeID

	err = runtime.BindStyledParameterWithOptions("simple", "neoforge_id", chi.URLParam(r, "neoforge_id"), &neoforgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "neoforge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNeoforgeBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNeoforgeBuilds(w, r, neoforgeID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachNeoforgeToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachNeoforgeToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "neoforge_id" -------------
	var neoforgeID NeoforgeID

	err = runtime.BindStyledParameterWithOptions("simple", "neoforge_id", chi.URLParam(r, "neoforge_id"), &neoforgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "neoforge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachNeoforgeToBuild(w, r, neoforgeID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListPacks operation middleware
func (siw *ServerInterfaceWrapper) ListPacks(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPacksParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPacks(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePack operation middleware
func (siw *ServerInterfaceWrapper) CreatePack(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePack(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePack operation middleware
func (siw *ServerInterfaceWrapper) DeletePack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePack(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowPack operation middleware
func (siw *ServerInterfaceWrapper) ShowPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowPack(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdatePack operation middleware
func (siw *ServerInterfaceWrapper) UpdatePack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePack(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePackAvatar operation middleware
func (siw *ServerInterfaceWrapper) DeletePackAvatar(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePackAvatar(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePackAvatar operation middleware
func (siw *ServerInterfaceWrapper) CreatePackAvatar(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePackAvatar(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBuilds(w, r, packID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateBuild operation middleware
func (siw *ServerInterfaceWrapper) CreateBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBuild(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBuild(w, r, packID, buildID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowBuild operation middleware
func (siw *ServerInterfaceWrapper) ShowBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowBuild(w, r, packID, buildID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateBuild operation middleware
func (siw *ServerInterfaceWrapper) UpdateBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateBuild(w, r, packID, buildID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteBuildFromVersion operation middleware
func (siw *ServerInterfaceWrapper) DeleteBuildFromVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBuildFromVersion(w, r, packID, buildID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListBuildVersions operation middleware
func (siw *ServerInterfaceWrapper) ListBuildVersions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBuildVersionsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBuildVersions(w, r, packID, buildID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachBuildToVersion operation middleware
func (siw *ServerInterfaceWrapper) AttachBuildToVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachBuildToVersion(w, r, packID, buildID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePackFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DeletePackFromGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePackFromGroup(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListPackGroups operation middleware
func (siw *ServerInterfaceWrapper) ListPackGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPackGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPackGroups(w, r, packID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachPackToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachPackToGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPackToGroup(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitPackGroup operation middleware
func (siw *ServerInterfaceWrapper) PermitPackGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitPackGroup(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePackFromUser operation middleware
func (siw *ServerInterfaceWrapper) DeletePackFromUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePackFromUser(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListPackUsers operation middleware
func (siw *ServerInterfaceWrapper) ListPackUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPackUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPackUsers(w, r, packID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachPackToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachPackToUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPackToUser(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitPackUser operation middleware
func (siw *ServerInterfaceWrapper) PermitPackUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitPackUser(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProfile operation middleware
func (siw *ServerInterfaceWrapper) ShowProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProfile operation middleware
func (siw *ServerInterfaceWrapper) UpdateProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenProfile operation middleware
func (siw *ServerInterfaceWrapper) TokenProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListQuilts operation middleware
func (siw *ServerInterfaceWrapper) ListQuilts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListQuiltsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListQuilts(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateQuilt operation middleware
func (siw *ServerInterfaceWrapper) UpdateQuilt(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateQuilt(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteQuiltFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteQuiltFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "quilt_id" -------------
	var quiltID QuiltID

	err = runtime.BindStyledParameterWithOptions("simple", "quilt_id", chi.URLParam(r, "quilt_id"), &quiltID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "quilt_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteQuiltFromBuild(w, r, quiltID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListQuiltBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListQuiltBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "quilt_id" -------------
	var quiltID QuiltID

	err = runtime.BindStyledParameterWithOptions("simple", "quilt_id", chi.URLParam(r, "quilt_id"), &quiltID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "quilt_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListQuiltBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListQuiltBuilds(w, r, quiltID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachQuiltToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachQuiltToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "quilt_id" -------------
	var quiltID QuiltID

	err = runtime.BindStyledParameterWithOptions("simple", "quilt_id", chi.URLParam(r, "quilt_id"), &quiltID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "quilt_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachQuiltToBuild(w, r, quiltID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUsers operation middleware
func (siw *ServerInterfaceWrapper) ListUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUsers(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowUser operation middleware
func (siw *ServerInterfaceWrapper) ShowUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserFromGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserFromGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUserGroups operation middleware
func (siw *ServerInterfaceWrapper) ListUserGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserGroups(w, r, userID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachUserToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachUserToGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachUserToGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitUserGroup operation middleware
func (siw *ServerInterfaceWrapper) PermitUserGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitUserGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserFromMod operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserFromMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserFromMod(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUserMods operation middleware
func (siw *ServerInterfaceWrapper) ListUserMods(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserModsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserMods(w, r, userID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachUserToMod operation middleware
func (siw *ServerInterfaceWrapper) AttachUserToMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachUserToMod(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitUserMod operation middleware
func (siw *ServerInterfaceWrapper) PermitUserMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitUserMod(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserFromPack operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserFromPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserFromPack(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUserPacks operation middleware
func (siw *ServerInterfaceWrapper) ListUserPacks(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserPacksParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserPacks(w, r, userID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachUserToPack operation middleware
func (siw *ServerInterfaceWrapper) AttachUserToPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachUserToPack(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitUserPack operation middleware
func (siw *ServerInterfaceWrapper) PermitUserPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitUserPack(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/login", wrapper.LoginAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/providers", wrapper.ListProviders)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/redirect", wrapper.RedirectAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/refresh", wrapper.RefreshAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/verify", wrapper.VerifyAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/{provider}/callback", wrapper.CallbackProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/{provider}/request", wrapper.RequestProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/fabric", wrapper.ListFabrics)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/fabric", wrapper.UpdateFabric)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/fabric/{fabric_id}/builds", wrapper.DeleteFabricFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/fabric/{fabric_id}/builds", wrapper.ListFabricBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/fabric/{fabric_id}/builds", wrapper.AttachFabricToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/forge", wrapper.ListForges)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/forge", wrapper.UpdateForge)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/forge/{forge_id}/builds", wrapper.DeleteForgeFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/forge/{forge_id}/builds", wrapper.ListForgeBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/forge/{forge_id}/builds", wrapper.AttachForgeToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups", wrapper.ListGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}", wrapper.DeleteGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}", wrapper.ShowGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}", wrapper.UpdateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}/mods", wrapper.DeleteGroupFromMod)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}/mods", wrapper.ListGroupMods)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups/{group_id}/mods", wrapper.AttachGroupToMod)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}/mods", wrapper.PermitGroupMod)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}/packs", wrapper.DeleteGroupFromPack)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}/packs", wrapper.ListGroupPacks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups/{group_id}/packs", wrapper.AttachGroupToPack)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}/packs", wrapper.PermitGroupPack)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}/users", wrapper.DeleteGroupFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}/users", wrapper.ListGroupUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups/{group_id}/users", wrapper.AttachGroupToUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}/users", wrapper.PermitGroupUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/minecraft", wrapper.ListMinecrafts)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/minecraft", wrapper.UpdateMinecraft)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/minecraft/{minecraft_id}/builds", wrapper.DeleteMinecraftFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/minecraft/{minecraft_id}/builds", wrapper.ListMinecraftBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/minecraft/{minecraft_id}/builds", wrapper.AttachMinecraftToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods", wrapper.ListMods)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods", wrapper.CreateMod)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}", wrapper.DeleteMod)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}", wrapper.ShowMod)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/mods/{mod_id}", wrapper.UpdateMod)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}/avatar", wrapper.DeleteModAvatar)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods/{mod_id}/avatar", wrapper.CreateModAvatar)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}/groups", wrapper.DeleteModFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}/groups", wrapper.ListModGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods/{mod_id}/groups", wrapper.AttachModToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/mods/{mod_id}/groups", wrapper.PermitModGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}/users", wrapper.DeleteModFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}/users", wrapper.ListModUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods/{mod_id}/users", wrapper.AttachModToUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/mods/{mod_id}/users", wrapper.PermitModUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}/versions", wrapper.ListVersions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods/{mod_id}/versions", wrapper.CreateVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}/versions/{version_id}", wrapper.DeleteVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}/versions/{version_id}", wrapper.ShowVersion)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/mods/{mod_id}/versions/{version_id}", wrapper.UpdateVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}/versions/{version_id}/builds", wrapper.DeleteVersionFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}/versions/{version_id}/builds", wrapper.ListVersionBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods/{mod_id}/versions/{version_id}/builds", wrapper.AttachVersionToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/neoforge", wrapper.ListNeoforges)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/neoforge", wrapper.UpdateNeoforge)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/neoforge/{neoforge_id}/builds", wrapper.DeleteNeoforgeFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/neoforge/{neoforge_id}/builds", wrapper.ListNeoforgeBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/neoforge/{neoforge_id}/builds", wrapper.AttachNeoforgeToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs", wrapper.ListPacks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs", wrapper.CreatePack)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}", wrapper.DeletePack)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}", wrapper.ShowPack)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/packs/{pack_id}", wrapper.UpdatePack)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}/avatar", wrapper.DeletePackAvatar)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs/{pack_id}/avatar", wrapper.CreatePackAvatar)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}/builds", wrapper.ListBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs/{pack_id}/builds", wrapper.CreateBuild)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}/builds/{build_id}", wrapper.DeleteBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}/builds/{build_id}", wrapper.ShowBuild)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/packs/{pack_id}/builds/{build_id}", wrapper.UpdateBuild)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}/builds/{build_id}/versions", wrapper.DeleteBuildFromVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}/builds/{build_id}/versions", wrapper.ListBuildVersions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs/{pack_id}/builds/{build_id}/versions", wrapper.AttachBuildToVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}/groups", wrapper.DeletePackFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}/groups", wrapper.ListPackGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs/{pack_id}/groups", wrapper.AttachPackToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/packs/{pack_id}/groups", wrapper.PermitPackGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}/users", wrapper.DeletePackFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}/users", wrapper.ListPackUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs/{pack_id}/users", wrapper.AttachPackToUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/packs/{pack_id}/users", wrapper.PermitPackUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/profile/self", wrapper.ShowProfile)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/profile/self", wrapper.UpdateProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/profile/token", wrapper.TokenProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/quilt", wrapper.ListQuilts)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/quilt", wrapper.UpdateQuilt)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/quilt/{quilt_id}/builds", wrapper.DeleteQuiltFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/quilt/{quilt_id}/builds", wrapper.ListQuiltBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/quilt/{quilt_id}/builds", wrapper.AttachQuiltToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users", wrapper.ListUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}", wrapper.DeleteUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}", wrapper.ShowUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}", wrapper.UpdateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}/groups", wrapper.DeleteUserFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}/groups", wrapper.ListUserGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users/{user_id}/groups", wrapper.AttachUserToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}/groups", wrapper.PermitUserGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}/mods", wrapper.DeleteUserFromMod)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}/mods", wrapper.ListUserMods)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users/{user_id}/mods", wrapper.AttachUserToMod)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}/mods", wrapper.PermitUserMod)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}/packs", wrapper.DeleteUserFromPack)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}/packs", wrapper.ListUserPacks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users/{user_id}/packs", wrapper.AttachUserToPack)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}/packs", wrapper.PermitUserPack)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w9227cuJK/Imj3adFOJzM5i4Wf1smM5wRnnDhXLDAwBrTEdnMiiT0UZcfH8L8veJXU",
	"EiWKUlvdbT4lbvFSrCpWFYtVxYcwwukGZzCjeXj6EG4AASmkkPC/zgq6fotjeMl+ZT/EMI8I2lCEs/CU",
	"fw4iHMNwESL2w98FJPfhIsxACsPTUH7KozVMAetO7zfs95wSlN2Ej48LPsQlwbcohsQ0SxagGGYUrRAk",
	"wQqTgK5hANjcG9lTzb8BdF1OX/lK4N8FIjAOTykpYAdIi/DHCfwB0k3Cfr1BdF1chxLOzxTQTlTkrIEB",
	"F+pbFzLeFCiJTRME1+xrFRWYBHlS3LQvnrf+E8Xui+cjnLwK2a83+ESOy2F89wtrfA6uCYqM8K74Z2uA",
	"RfNREIshGiALOCXMmNxAM8jsqz3ErPU4gNkITXjZrwLc3wguNkZwb9hXa3B561Hg8hEa4HIYBbgXKIMR",
	"AStqBDlVLazB1j1Gga5HaYCvYZZLwOYdmGL7/Zficbsvxc29d4HlznsP8aqTkTPZwBpc1WEUzGqQBuAK",
	"XgH9JYi+GyHfgOi7NdSs8SiI2QANaBl8CtIblN38jlJk4mjRIkhYE4PkV99KkGK4AkVCw9NXL18uFIAo",
	"o/AGki0IX718qeH4sFrlsAcQzNsYINEfW0DpA4SB8bFAiXlr/82+WpOOtx5FOz5Cg3gcRkG9zxCQaP2R",
	"4cAAtGgRKDS16m3epEdxf8aEvsVJkWamiTChjDwRb2SaChNqMdEHYraV1DyYVKyibS6Q31qYIAR5FC5C",
	"mBVpePqH/IvNEF4tuonBGz0uwq+52Y4LihwSawZhjUfxx18xhlvMwaATvPENkhzhzAjqrfhuDa1sPwpg",
	"OUaDpSWsDPBHMTjM6RscI8iNdG6RyTZvcHzPfotwRmFG2X/BZpOgCLCVLf/K2fIeKgBtCN5AQuVQKY6b",
	"UDJgsiJJwDWDUqzoxwlOEYXpht6Lnx4XCnzXAR6rePuDg1KOWbIfvv4LRjR8ZO3rRPuyhtJGVsSLAQUB",
	"xUFEIKCQETCGCeRmeJ1Ej4vwLW/DcTkSiaUh24qJFrvUFsNaQ/cNLHWt7bh/gVvgTvcEUJjTSv9rjBMI",
	"MusBUphicu8OQM1C7EFN1dqzHV90dYWualn1AFcxk2xH3xTXCYpGIF/r4R7YlF61HZfACKcpzGIYO0P3",
	"OGjX13e7eY/z88rIPT6OJbgacReTVjgRZ0NbnFzgsVIPFHSNiTtOaitwHgRnbJnue3UUWUfvxRzFM3HV",
	"IryD1zlyx50tW7IjtC1TsnPYrPt0PEEPgST8xG1LE2ZBj5UUEUW3sHbuEEtwRDKIU5TVhluBJHcfD6YA",
	"Je5UWxVJMpLtQJ7fYcL15gqTFFB+3JA/LhxHZeepMXDZshM/5Nmy0zTHlpl3ebFJMKhTi63/pCCJI7Vs",
	"cd1+0GlDtzhrTHG84cbWGOaOvk90RORDLSRAtidEeSvRZjKyA2KxiU0YZJa5R6C8IxmOP252X+D4F4I3",
	"u3BTtDkQrgYZy1XbpMgSlH3vWsclJOlO1rEIN5CkdguUbd3Xybpz73T7OpkJNgHB2nm2lR2HLaVmu/TQ",
	"jF87jCeaYS22VJN7zoFstbX20I2ZaRPQjeny/iXxVsPWUjMSeujGXcoT0K2dPIshi3SiW22tZrr9jm9Q",
	"dlbQ9Wj+HGI9dhqGbTjgLSs2qi0uIgK5Kx0kOcMDKOia/RkZtIX203mNW7kzH651L3B8dgsoaDu0pUVC",
	"0QYQumR8csKGZT/DLMIxWyFjIJTASq8v8oYwBTdw+V/hIlxDEMtYIdnkJEb5BudIOXLMt1l8tUYnupxY",
	"c/A1ygC/xWqyqLXjAXBMcJEjTPZ2hHGpM4H05Nu/f1eJZlcD1lH37ZnFp1rLBNLTtBZbtSf6D5SfzbWa",
	"xecFjvdX6bGFWKo8uY7DVHiNdZrppe46vHwvg3WGi3dm03r5rr2YNgKeoWyvJTxfia2I16s5VBnfslqz",
	"0GCr3V8pz5diKebVSg5TzjdXaqYZvzj2Ul6Gxw0X8Z9gjAiM6ARHQ4q/w6yfI0Qz23URCV/Au9mc7b7y",
	"tfpQGx9q40NtDjvUxiy1xB5/jqE2fTjxoTY+1ObJQ236mNKH2jx9qE0vTQhmp+SRZPHRLOMoJohgTbRJ",
	"46PGBkT5AKjZA6D6+MUHQE0aANWB7hySvXb7cbaxdfvp1Ryq269ltWYXElvtnkYO8XXYBQ7JVRxi3FBj",
	"ld202t+oIb4Qy6AhtZLDjBlqrtRMM6WEvJNW6ROTm9aUP8jnzjc4ywUaziI26DlACYx/JUSc1q1R+p8E",
	"rsLT8D+WZW2WpfiaL99jilaya9sqxJwMavgDRgWFAeCw8MIpBOa4IBHkFU0SAkF8f0YpiNZPDeUnCUiA",
	"8gAIQAIgIWHAvQHx2zJg6Glh+5oJBwv6N4yDO0TXwR3B2U01gkmC+Emk4s5F4A0gOQxkPnCo6sd8knw4",
	"GUB8VNOGiSEFKMk5dwGxbTQkUqzkThAZxIoFoAtZcaFqjqKM/vfrsK3EgayJYNdYiacuKJjKYG0ppiCx",
	"HFeKHb5UJtRyq6VK/IalsQwIAfct9zkMkoUuRKHLQOhpbcTjWRDhJIFCmOBVXVTmmuiTUXsgMppYODg+",
	"sCWbRI8L0fQGreSD7BPFxIVeX3cB/E4pvFdUq+as5CX1piDcHiDQQfyVDDCD4BPUyMNaTtBebSIGVS8K",
	"eaPns4XKALuScs94Aynqz7F/OOrDSirVFHTQXqyuZfMJhzJ9igdsSrWktn058+7h63AhmM4ay8NqLtV+",
	"U22wPTeQxtq82yLy9HQTwLkTTvRXlJv8eCipY3M8vFGE1HldR8RDQ+R1kcugait+085+d4EtJnTnIdFf",
	"UW4yqg3cc096xpt+I8slO1OBE+BdRiHJQPIZkltIntb19BmnMEASgCDnEASQg8AhuwUJir/g7zCbyyV2",
	"AzNIpK+WQ8P+L+JZVYrl5ALwrKDrL2KKJmi/SYBiGR7L/YnwxwYRHlMAw0au46E6UHRoaN9sermHfaLY",
	"ysrMa5R8vieLGnVnOF1osuRhNf118l2vR7Yzfcr007CSmDmXIjUcUAaeiixQdNhaV+efKl7aBRdZ809Y",
	"Zoc+tXiZndguJnMrk+/eYFY5sIpnZqDVAGl9XJ4K5aOoJRcfqkGlsll6rWPV7qDNqXoSdI2Kz9eYqpJ2",
	"BltK0URQA9P5Y0UyTGtxIgwoHazxxGEivJi9BEnDIIE6x0U2F5oYQCs2f1grEDC57VIObWfCVDL0w2rm",
	"+lxGsMmDe6RRAyPs4DJHP1eU2wk32fNRWEmh32v1sKuIoeHmcDu7794e1rUCNO/sPcHsEXsIt0D6/kcm",
	"lE2/dcW4xspvBSEwo2UqldjNEiL+Qt8UHKFe+xtAPPU+4C4IWILjQrPa64YcVWUZjWcRYcdz5fvA4jjZ",
	"u5NMpdBHSbnne4YpifT0BxhOCk6ET3BFYL5+2ssfOWnn5c8nmGIKv2bgFiCe4PDUpwY2fVA5YSEaaFj4",
	"K2pFFME8v4B5Dm7gkwF2mQCUBbmYPEjl7I+LkGN73ku8DPKLT0ZImcejr+hnOMx0hAfsUbiDzSqe5DBT",
	"Zh7mYZmVt9deWqM3+6Bo5uzVVdmHeVjJyjuiQ4T5dDY3ydwPHTr9UBNtcpEtl9LvMcg4NAqOo7HEhrsA",
	"5jj+65P/NxGOg/BswUE6IKiSMvcNErS634k5IYZuA+kCUsBzS/GqfMteRylVs3HnOusZU8sWh3ZvXHmV",
	"tAsMveAnOCA2M+fk7JOzYbkqC7/qbUnzCTM3D5Nd7LfLXiRhhmWpZZF+rk8zzXpQ/PiZ/wnodr0WeEJR",
	"KnLbQfwhS+633mUbmMqvi412D2dbfHQRVmRqY1UiQz/e/aqqRYSGLUz3bFvbG5XfvKUocAwTproI3BCY",
	"w0z6lYR/ccr1O+Re7rj4qnUK065KtYoR+9mmnEE8LX4sJV4HRXoeRmHYIfEWOy4mO+BecJrCs9Z+2n0u",
	"U7sIRYWvMZKO6SZE+Yv7b6QwbZfH30rT0U4sa3W8GFW+gre2IADvIGTOFPJ/PGaHW9u6h8VyZSe24C3V",
	"qhFWG+5qi87BN02dBr3Pte7rpbRUk7vQwK4aZ5xwnHRHnSvsNFGsBHA/hnnLfUJwTSfOUe94WhpJ/DZI",
	"9JvKpOwlka75tyMS7Zrnx1ULnpQav0lUtlPjAsf2BAlkab/JiTIsxZa3thDovIPcYNYn/xTbqMYLLBWj",
	"KrCn3wZX753ArEgrz5+ImrmLEN9ltRdfplSPbXUzhdaSi7ra4orgAsdGzriUFqQla6gagofHG4NMZRB9",
	"txidNT8k/lDLajDIpaBqg0Muqgqrl0NK9XY8Vo3otRcS/qKC3ialLAV8m2gf+xCEDMa2z3Sc5qCxF+9P",
	"zMOVB/1uxRQHxAkeWlC7ql03ltxquatUSsIuRN/8+C5I0qcMv3763Qn7wZlCXIMI7yv+tl4aaOecP1K3",
	"qo/3JX6aiK5efjeQzePWUBSo0sT8oo/X68gDkMXqQpzfPm0jXzSzvwbTQ7XdGadl8GAToS1iigJa5JXW",
	"6oKuhylr2GjBlrXJ3Gos22nLalbU4oBZeOYHefZL15jM7AqxbdnKqxsXdcMQ3aFvVAaKFRFk24Xx2R3D",
	"KtUGqL6wY9G0oOthUVpnBV2Hj0ZkC6FqS9Qp2Gr294DGBERPgkVbp6RrVO8kQLoHnU40/S4ebdqUO3tG",
	"qTbBy1FKkGnp0ybERDqajRSrJYg1ZFmM8k0C7i2CVBZhTNCtmLTfEolwZtXQPkKmghe1lAZiPqrr616s",
	"iItuf45oRfFHiZwGfr/mlkynngrfr+fqvIYdr2FtFZwX8jZC/mveLsg079luNi7mdyLPNhVl0/jIt8/D",
	"jq44qkgKzsT6WjFlfxtdpnQd6A1X3yWUuHVa1C+jrnYUw2OfRiTaWqyVNW+J21G9K0i72mIQ4+24sp6t",
	"+WNXd+PP4up6Hq5oXotznjB4/vWJxpoldnYn/myurOfhi5brcM4YJjddxTnd7iMHSZBTUkS0IJDxSb7G",
	"dxXvuPSZN1hlhWDS/hKn0eFd1YAVsNqAHhB9aoo7nSQtQFpmFvGc50iUDHAOs7MWpbM/eDyhIdQRllrF",
	"6wA+CFodnDKB689xkRGTqMz4H71a8Jd/DPA8CZP6UO/Ed+U0l9wTnLc6nNjSYVQQRO8/s80lmOQNyMXO",
	"4BuO7w3+i+6+ppSbuW8gIELyly3FT42m/4RAnjTYOT9ciz/VJg7/7+Ts8t3Jv+B92RNsEPubJ8ChbIUV",
	"+4KIo1kel8PvCUQ5heR/7+D1Gm02CL6IYTnwv+TnUKKYA5SfLpeq3wtYhM0Uu8t3QQxXKEP62VQ10CJI",
	"QQZuIA8b4O5W/rka35OgCMqESQnF2QZEa3jy04uXNThOl8u7u7sXgH99gcnNUnbNl7+/e/vr+8+/si4v",
	"1jRNwgpNFSjBhw3Mzi7fhZWY+/DVi5cvXp6AZLMGr3iW5AZmYIPC0/Bn9iUUW4XTeclOlssE3wjXywaL",
	"nCMmL7hGeheHp+K9BHlEkznT6nngNhldNkFsFaoz77L9QO5PL1+ah5HtlvX3Gh4X4WubXtsPs/J+r6z6",
	"Nd6cfVyE/7CZs+1VjuoOC0//uFqEeZGmgNwzpijomk0UAQpVgYLg+r72xuwipOAmZ5YP9wJcsfEE2Wql",
	"zm5gG+VQTnVxtdAF983SbF3rOYc0WotcdlU7aLuGmXk5BMaIQLG12xnxk2zhyovV/u7sWK88tGt2bD6n",
	"sitm/AQpQfAWBgSCRJY4AismZDRluojHa1wZOVHWwNKUG4r07cJdM6KvgjAOE9u4ZemG4BquMIEBorLE",
	"VxfL3+o85lakiTRnZ5xtFbXYB5QJkMSZCtF7VZgFlHKQKVuR/G1G24MSJ4/LCCTJtTxmt+LwrWxQuVna",
	"AAJSSLng/KN9TWUTXsNDdb5kP4ePC6tOnymgcFCPtzhWHa62CP7zy//Zqr5A4Q+65HZBrezC9gGjo4qZ",
	"qlxW1hx5/fL1RLMojNXLUL9+9dNE45flXLiFBhL0b1hehJYMO8FU79pfuuqQpIrnytfZKS+zsUIZjKvX",
	"tRYMrorUmAUr/z4le++O95QCZohhKKkSbNe8NydDSCLxNZMKDuxYoqzIYDTy5EvQg6n/GQISrT8WkNwb",
	"iG+labYfoubk/Lm/X0vd/ul0TZsxKgANdLGVEt8SyVfcL9SC5a/8hK/zWofjaKuA5lwoYn1/trG3WuuR",
	"1jEscDIcxSVTLx90+ZDHZVmhKoYJFBGbdSL8wn8XM5wTnKrE/WFML/pX+X3gOaLyar77MaKNH1zPEc58",
	"JIVub9fKQxalGu+fsPZQyHQ7+2uWoOx7AGS5hRXBaQC2GK99a/cIUFFsbRxDLRyErkUfTOhbnBRpNqjL",
	"BzLEar0ENyi7+R2liA7s84GXsRqvQraq3c3B3JNrHyHW9Hs1TO/bMWu7E0RsKtH/C/YScH8l4FlCIIjv",
	"G1Lw9U8WnbfrZE7HmQIeLT0t2ZHrbJXMZRaj4p2ouczQ+jNh+2uF8hfO2iwkjuA+G1RmgXkT1GiC9uFX",
	"M/PyQRX3GmB+sh4jrE/WfYzo1S8aesm7P7ZnleNaN3S3yHQ1PCu85O1Od53xfMzOXj7tNDpZK2eb08s9",
	"b3FWLM4eTmQqukz4M0pP8drKBAanF4XLrZdr9sh8BklSMe9uFM0Vz4jIfLP0esuD1VQM+WDJU+nuLnp4",
	"92miBtwlz7xiQOAxAEEG73SexjYNy32/fFDpAI/9Rrki7jAxICuouW8ZR4Vyxiu3izvM+VTKRGQVBAhA",
	"kG9ghFYoMtLWYAV/XuO7mejXsisP2e6zokGHa2EiKgyUr5W5D1y+ull280pl6UGxYJ1W0bxUxQ4s5PM5",
	"wanI2nlaBlMlVH8heOMPD3M6TVIsXSYDVYQ29S+wg5ukyj/eTeKuKGsPJB6+skwS/pxgzUXSoTY7HCMc",
	"O1/wnLLtEpLUy7ZDdYwwudjNfW1GG6M50nLRs97BqNX9MPl4+hIkqUhfGmb16SpTlmafzMmdgUHZzN7w",
	"m9vw4zUPR1l+/LVfb/rNZPrV31o+CttPZG5OZvzNK+G8Dj5k828jk0Xc7T/Pfd4CHG4Bcr5zNQH1w+OW",
	"JqAshzYDi7KZvQk4twnIk9tHmYD83X5vAs5kAnLsH5cJyEXYdCbgvBLOK+FDNgG5dBxlAnru8ybgcBNQ",
	"VEC0MgFrz58aNbUugzRbGkgJwf6ngmhY29IVSoT3xG1US0/5tBBTWog1rmvMvnyoPmpvnyaiZ3NPFdFD",
	"jBDQegwfOr1fKSMNbjRu/H5R65g+ss1f/nQ0Tt88mzQSe97tOjXpUVxTSrx89OenltQSW+7kal5GL5pl",
	"rEvAmReTbWJyuuixHSaXpILeml9w3JtYImJvHNNKLvAIoXOBY59SolNKxNMOdcqpPb58EK8IWKSSuIRS",
	"XeDYp5FMnUbSRs+OFJIZ6NbYf0eSPNKO+S4HxHjcOyWNHLr0PI6EESvBuwSVF3J75K9+4vWpd7OYeDBX",
	"HKMglr4zCgh3DFcrmBrEQ7eJNA1Nh57u1LyjpIQjV3hZEX7dJBjEvMSzPSs1RUdZCKBXdJwTnLqlMY7m",
	"ND6tjzOZ28vKmUV4WQdYkPKs71hPouQd70N11b2Tlp/YkwATIbhq3tMhylP6SXH8Bc8p0/zd/iF7RoU8",
	"NHOeOaxE0d+znQ8pGXAyFAxXxpTY2XiW4cTSxHMKdhrNlj6QeL8CiYfbd24hxN68G2/ePYvwYUfjbj5p",
	"5nXsMQQNu1h2nue8XTcqVNjOrNOhll1BFt/KeEyvmJ9UMSvMH5diLsM5FPuJlwYdbi7KZ7mfUlLW5naX",
	"lXIAf3MxMrJEP6huZCKz4Fs+yP/ZRZ+M57d+4SHn8BErU0es9PNJR/zKgVC+VaYcSdyLDf06omBmoqBT",
	"5IzXLfsUQTOZgrFOT5LkG5Gc9KRMq9jVB+nvVRJTS4B9nxO2Ssn8CbnOHxDHqPtjS21ip8SW1CYzP3f5",
	"cCWOnNOYvCT1nl/3dCcTzzKLIYO4/9HG97LRbAn7GoD9z9dXoLalkGtk9xwT1Bg+Wb8jWd8S0VUmXz6o",
	"/w2yhNVM7qawGmGEVFZDeLG8XwbuNhuatnuvcHW0d7dYyxuxoxTMs0nQt2XbLqtWjeFq1nqp6I3VhrFq",
	"x5hMq+sK80bR6lYR3AvIFmJOWd57h7e5G0lxxTLs794bXFka2fEOlvV2lzyst8/Q1/eoG0GKLfLp3b58",
	"YP/Y3ZM6Fbzmtar9refEt57tVO246ZyFds2teCSXlib0d3ggJiGA07Xj4YvT47hwtJbE1mn7jDaOOd5T",
	"bG2fuW+Tub9FdpsAuAnpOlBilDOPkxg+fX9n6fut/NQmRUpnrPE45+ghqzCZ9445ic9jvNstz4zSPyYi",
	"a4y2UocAdPN+jZR9landhR/v7uXeyEOrvA/o4B+zwFs+8H/tjrSjGa1fZPAp/Al46hNwP4t0nIYPgewt",
	"kuRITs82pOs4Sc9BPKeDt1cl+3L0nkif1DLrLBTLOcGpa4D6k/Ir7z86PN1HQoyPhNBR6SIW4lrKOjvV",
	"po90zsmdzlznz4HuSv44E0J1Gmg1TMLIz11RERxJX7CXpD564omiJ5QU5vETBp5tsxhsi2YylnSvmjmB",
	"j9fXzdy3upmDzrAqFMexdKb3304RvPNMimcO89+KLcPQ41o/cyrp5kveHEUFzUEOIlFpSbOA5z1fbmlU",
	"GU17X5FlKU1l+DlVApuAO301zf2qpulk9bkV1PRG3xRG37Moqelu8s0p17zSPYa6mo72nmc8b+2NLK7Z",
	"YewRvEIJXOYwWRnj6XiUvWjolGUu++5jRpBcfxBDClCSB3jFIxI3kOQ4A0kAoggXGa0iTyKiLyi+gi+3",
	"2HYxwIhg1TasP7eEIbkf7nFBAnyXaXqjbIVJyqdspW11b1D8HWbGzfGFfR2zO/gA+7U3PkFKELyFAciC",
	"IkuYSQrjABR0HQhkmFD2d4ES2hmX+5G1mK02iJh9/wuDcDjbilUIBPfIHt7b1wPpqAfSi1/NzMsH/s+g",
	"GiB8dPcCILz7COON9/dJ7vtV+qPGca0bultkOuYzVHnJ+0bcdcazqfXRz6ddrhLe27XEh5d73ldSKe7R",
	"x4lMReu7CaPwdPMoe0HYQsYpHcQ7TNEqJMUVv7C/e9OypJPNMbOK9XaXOay3L+uhM6QKQYot8undvnxg",
	"/9jlQDm5Trnf0yc1TZzU1E7VjkSmWWjX3IpHkphkQn+HF2ESAji5Pg9fnB5HbpG1JLaODma0cY8OHstc",
	"OSQ+OnjfooMHKQZl0TtGB1cYyDtDnBXkM4kONqrMDv8HQ49rdPBU0s3f2R9FdPAgi01Ei2gW8Lzn40VG",
	"RQfbW34pjgfYfRc4noM3L3Dsbb65bb4UxyMsvgsce3tvHnuPof64rD0mtCay9eaTaF7XHrKdx6Shu5Xn",
	"uc5beMMsPMZvLvadfjjBzsBzqgU9AWeyeb2JN7eJx5hlhI3n9gSHN/KmMPKmfLNjT6w8LromMvPmlGte",
	"5R6yocdlorul5xnP23pDbT3Ocr3GHusJo4Iges956p8QxJCEp39cMdXzBgJS+QvkKOJ/XLFebH7BiAVJ",
	"wtNwTekmP10uKbl/8T2BKKeQvIDFEmzQ8vZV+Hj1+P8BAAD//6tq0HwTugEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

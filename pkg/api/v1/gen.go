// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// contextKey provides a type for use with context.WithValue.
type contextKey string

const (
	BasicScopes  contextKey = "Basic.Scopes"
	BearerScopes contextKey = "Bearer.Scopes"
	HeaderScopes contextKey = "Header.Scopes"
)

// Defines values for GroupModPerm.
const (
	GroupModPermAdmin GroupModPerm = "admin"
	GroupModPermOwner GroupModPerm = "owner"
	GroupModPermUser  GroupModPerm = "user"
)

// Defines values for GroupPackPerm.
const (
	GroupPackPermAdmin GroupPackPerm = "admin"
	GroupPackPermOwner GroupPackPerm = "owner"
	GroupPackPermUser  GroupPackPerm = "user"
)

// Defines values for UserGroupPerm.
const (
	UserGroupPermAdmin UserGroupPerm = "admin"
	UserGroupPermOwner UserGroupPerm = "owner"
	UserGroupPermUser  UserGroupPerm = "user"
)

// Defines values for UserModPerm.
const (
	UserModPermAdmin UserModPerm = "admin"
	UserModPermOwner UserModPerm = "owner"
	UserModPermUser  UserModPerm = "user"
)

// Defines values for UserPackPerm.
const (
	UserPackPermAdmin UserPackPerm = "admin"
	UserPackPermOwner UserPackPerm = "owner"
	UserPackPermUser  UserPackPerm = "user"
)

// Defines values for SortOrderParam.
const (
	SortOrderParamAsc  SortOrderParam = "asc"
	SortOrderParamDesc SortOrderParam = "desc"
)

// Defines values for ListFabricBuildsParamsOrder.
const (
	ListFabricBuildsParamsOrderAsc  ListFabricBuildsParamsOrder = "asc"
	ListFabricBuildsParamsOrderDesc ListFabricBuildsParamsOrder = "desc"
)

// Defines values for ListForgeBuildsParamsOrder.
const (
	ListForgeBuildsParamsOrderAsc  ListForgeBuildsParamsOrder = "asc"
	ListForgeBuildsParamsOrderDesc ListForgeBuildsParamsOrder = "desc"
)

// Defines values for ListGroupsParamsOrder.
const (
	ListGroupsParamsOrderAsc  ListGroupsParamsOrder = "asc"
	ListGroupsParamsOrderDesc ListGroupsParamsOrder = "desc"
)

// Defines values for ListGroupModsParamsOrder.
const (
	ListGroupModsParamsOrderAsc  ListGroupModsParamsOrder = "asc"
	ListGroupModsParamsOrderDesc ListGroupModsParamsOrder = "desc"
)

// Defines values for ListGroupPacksParamsOrder.
const (
	ListGroupPacksParamsOrderAsc  ListGroupPacksParamsOrder = "asc"
	ListGroupPacksParamsOrderDesc ListGroupPacksParamsOrder = "desc"
)

// Defines values for ListGroupUsersParamsOrder.
const (
	ListGroupUsersParamsOrderAsc  ListGroupUsersParamsOrder = "asc"
	ListGroupUsersParamsOrderDesc ListGroupUsersParamsOrder = "desc"
)

// Defines values for ListMinecraftBuildsParamsOrder.
const (
	ListMinecraftBuildsParamsOrderAsc  ListMinecraftBuildsParamsOrder = "asc"
	ListMinecraftBuildsParamsOrderDesc ListMinecraftBuildsParamsOrder = "desc"
)

// Defines values for ListModsParamsOrder.
const (
	ListModsParamsOrderAsc  ListModsParamsOrder = "asc"
	ListModsParamsOrderDesc ListModsParamsOrder = "desc"
)

// Defines values for ListModGroupsParamsOrder.
const (
	ListModGroupsParamsOrderAsc  ListModGroupsParamsOrder = "asc"
	ListModGroupsParamsOrderDesc ListModGroupsParamsOrder = "desc"
)

// Defines values for ListModUsersParamsOrder.
const (
	ListModUsersParamsOrderAsc  ListModUsersParamsOrder = "asc"
	ListModUsersParamsOrderDesc ListModUsersParamsOrder = "desc"
)

// Defines values for ListVersionsParamsOrder.
const (
	ListVersionsParamsOrderAsc  ListVersionsParamsOrder = "asc"
	ListVersionsParamsOrderDesc ListVersionsParamsOrder = "desc"
)

// Defines values for ListVersionBuildsParamsOrder.
const (
	ListVersionBuildsParamsOrderAsc  ListVersionBuildsParamsOrder = "asc"
	ListVersionBuildsParamsOrderDesc ListVersionBuildsParamsOrder = "desc"
)

// Defines values for ListNeoforgeBuildsParamsOrder.
const (
	ListNeoforgeBuildsParamsOrderAsc  ListNeoforgeBuildsParamsOrder = "asc"
	ListNeoforgeBuildsParamsOrderDesc ListNeoforgeBuildsParamsOrder = "desc"
)

// Defines values for ListPacksParamsOrder.
const (
	ListPacksParamsOrderAsc  ListPacksParamsOrder = "asc"
	ListPacksParamsOrderDesc ListPacksParamsOrder = "desc"
)

// Defines values for ListBuildsParamsOrder.
const (
	ListBuildsParamsOrderAsc  ListBuildsParamsOrder = "asc"
	ListBuildsParamsOrderDesc ListBuildsParamsOrder = "desc"
)

// Defines values for ListBuildVersionsParamsOrder.
const (
	ListBuildVersionsParamsOrderAsc  ListBuildVersionsParamsOrder = "asc"
	ListBuildVersionsParamsOrderDesc ListBuildVersionsParamsOrder = "desc"
)

// Defines values for ListPackGroupsParamsOrder.
const (
	ListPackGroupsParamsOrderAsc  ListPackGroupsParamsOrder = "asc"
	ListPackGroupsParamsOrderDesc ListPackGroupsParamsOrder = "desc"
)

// Defines values for ListPackUsersParamsOrder.
const (
	ListPackUsersParamsOrderAsc  ListPackUsersParamsOrder = "asc"
	ListPackUsersParamsOrderDesc ListPackUsersParamsOrder = "desc"
)

// Defines values for ListQuiltBuildsParamsOrder.
const (
	ListQuiltBuildsParamsOrderAsc  ListQuiltBuildsParamsOrder = "asc"
	ListQuiltBuildsParamsOrderDesc ListQuiltBuildsParamsOrder = "desc"
)

// Defines values for ListUsersParamsOrder.
const (
	ListUsersParamsOrderAsc  ListUsersParamsOrder = "asc"
	ListUsersParamsOrderDesc ListUsersParamsOrder = "desc"
)

// Defines values for ListUserGroupsParamsOrder.
const (
	ListUserGroupsParamsOrderAsc  ListUserGroupsParamsOrder = "asc"
	ListUserGroupsParamsOrderDesc ListUserGroupsParamsOrder = "desc"
)

// Defines values for ListUserModsParamsOrder.
const (
	ListUserModsParamsOrderAsc  ListUserModsParamsOrder = "asc"
	ListUserModsParamsOrderDesc ListUserModsParamsOrder = "desc"
)

// Defines values for ListUserPacksParamsOrder.
const (
	ListUserPacksParamsOrderAsc  ListUserPacksParamsOrder = "asc"
	ListUserPacksParamsOrderDesc ListUserPacksParamsOrder = "desc"
)

// AuthToken defines model for AuthToken.
type AuthToken struct {
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	Token     *string    `json:"token,omitempty"`
}

// AuthVerify defines model for AuthVerify.
type AuthVerify struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Username  *string    `json:"username,omitempty"`
}

// Build Model to represent build
type Build struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Fabric Model to represent fabric
	Fabric   *Fabric `json:"fabric,omitempty"`
	FabricID *string `json:"fabric_id,omitempty"`

	// Forge Model to represent forge
	Forge   *Forge  `json:"forge,omitempty"`
	ForgeID *string `json:"forge_id,omitempty"`
	ID      *string `json:"id,omitempty"`
	Java    *string `json:"java,omitempty"`
	Latest  *bool   `json:"latest,omitempty"`
	Memory  *string `json:"memory,omitempty"`

	// Minecraft Model to represent minecraft
	Minecraft   *Minecraft `json:"minecraft,omitempty"`
	MinecraftID *string    `json:"minecraft_id,omitempty"`
	Name        *string    `json:"name,omitempty"`

	// Neoforge Model to represent neoforge
	Neoforge   *Neoforge `json:"neoforge,omitempty"`
	NeoforgeID *string   `json:"neoforge_id,omitempty"`

	// Pack Model to represent pack
	Pack   *Pack `json:"pack,omitempty"`
	Public *bool `json:"public,omitempty"`

	// Quilt Model to represent quilt
	Quilt       *Quilt     `json:"quilt,omitempty"`
	QuiltID     *string    `json:"quilt_id,omitempty"`
	Recommended *bool      `json:"recommended,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
}

// BuildVersion Model to represent build version
type BuildVersion struct {
	// Build Model to represent build
	Build     *Build     `json:"build,omitempty"`
	BuildID   string     `json:"build_id"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Version Model to represent version
	Version   *Version `json:"version,omitempty"`
	VersionID string   `json:"version_id"`
}

// Fabric Model to represent fabric
type Fabric struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Forge Model to represent forge
type Forge struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Minecraft *string    `json:"minecraft,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Group Model to represent group
type Group struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// GroupMod Model to represent group mod
type GroupMod struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group   *Group `json:"group,omitempty"`
	GroupID string `json:"group_id"`

	// Mod Model to represent mod
	Mod       *Mod          `json:"mod,omitempty"`
	ModID     string        `json:"mod_id"`
	Perm      *GroupModPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time    `json:"updated_at,omitempty"`
}

// GroupModPerm defines model for GroupMod.Perm.
type GroupModPerm string

// GroupPack Model to represent group pack
type GroupPack struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group   *Group `json:"group,omitempty"`
	GroupID string `json:"group_id"`

	// Pack Model to represent pack
	Pack      *Pack          `json:"pack,omitempty"`
	PackID    string         `json:"pack_id"`
	Perm      *GroupPackPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time     `json:"updated_at,omitempty"`
}

// GroupPackPerm defines model for GroupPack.Perm.
type GroupPackPerm string

// Minecraft Model to represent minecraft
type Minecraft struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Type      *string    `json:"type,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Mod Model to represent mod
type Mod struct {
	Author *string `json:"author,omitempty"`

	// Avatar Model to represent mod avatar
	Avatar      *ModAvatar `json:"avatar,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Donate      *string    `json:"donate,omitempty"`
	ID          *string    `json:"id,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Public      *bool      `json:"public,omitempty"`
	Side        *string    `json:"side,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	Website     *string    `json:"website,omitempty"`
}

// ModAvatar Model to represent mod avatar
type ModAvatar struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	URL       *string    `json:"url,omitempty"`
}

// Neoforge Model to represent neoforge
type Neoforge struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Notification Generic response for errors and validations
type Notification struct {
	Errors  *[]Validation `json:"errors,omitempty"`
	Message *string       `json:"message,omitempty"`
	Status  *int          `json:"status,omitempty"`
}

// Pack Model to represent pack
type Pack struct {
	// Avatar Model to represent pack avatar
	Avatar    *PackAvatar `json:"avatar,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`
	ID        *string     `json:"id,omitempty"`
	Name      *string     `json:"name,omitempty"`
	Public    *bool       `json:"public,omitempty"`
	Slug      *string     `json:"slug,omitempty"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
	Website   *string     `json:"website,omitempty"`
}

// PackAvatar Model to represent pack avatar
type PackAvatar struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	URL       *string    `json:"url,omitempty"`
}

// Profile Model to represent profile
type Profile struct {
	Active    *bool        `json:"active,omitempty"`
	Admin     *bool        `json:"admin,omitempty"`
	Auths     *[]UserAuth  `json:"auths,omitempty"`
	CreatedAt *time.Time   `json:"created_at,omitempty"`
	Email     *string      `json:"email,omitempty"`
	Fullname  *string      `json:"fullname,omitempty"`
	Groups    *[]UserGroup `json:"groups,omitempty"`
	ID        *string      `json:"id,omitempty"`
	Mods      *[]UserMod   `json:"mods,omitempty"`
	Packs     *[]UserPack  `json:"packs,omitempty"`
	Password  *string      `json:"password,omitempty"`
	Profile   *string      `json:"profile,omitempty"`
	UpdatedAt *time.Time   `json:"updated_at,omitempty"`
	Username  *string      `json:"username,omitempty"`
}

// Provider Model to represent auth provider
type Provider struct {
	Display *string `json:"display,omitempty"`
	Driver  *string `json:"driver,omitempty"`
	Icon    *string `json:"icon,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// Quilt Model to represent quilt
type Quilt struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// User Model to represent user
type User struct {
	Active    *bool       `json:"active,omitempty"`
	Admin     *bool       `json:"admin,omitempty"`
	Auths     *[]UserAuth `json:"auths,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`
	Email     *string     `json:"email,omitempty"`
	Fullname  *string     `json:"fullname,omitempty"`
	ID        *string     `json:"id,omitempty"`
	Password  *string     `json:"password,omitempty"`
	Profile   *string     `json:"profile,omitempty"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
	Username  *string     `json:"username,omitempty"`
}

// UserAuth Model to represent user auth
type UserAuth struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Provider  *string    `json:"provider,omitempty"`
	Ref       *string    `json:"ref,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// UserGroup Model to represent user group
type UserGroup struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group     *Group         `json:"group,omitempty"`
	GroupID   string         `json:"group_id"`
	Perm      *UserGroupPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time     `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserGroupPerm defines model for UserGroup.Perm.
type UserGroupPerm string

// UserMod Model to represent user mod
type UserMod struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Mod Model to represent mod
	Mod       *Mod         `json:"mod,omitempty"`
	ModID     string       `json:"mod_id"`
	Perm      *UserModPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time   `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserModPerm defines model for UserMod.Perm.
type UserModPerm string

// UserPack Model to represent user pack
type UserPack struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Pack Model to represent pack
	Pack      *Pack         `json:"pack,omitempty"`
	PackID    string        `json:"pack_id"`
	Perm      *UserPackPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time    `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserPackPerm defines model for UserPack.Perm.
type UserPackPerm string

// Validation General structure to show validation errors
type Validation struct {
	Field   *string `json:"field,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Version Model to represent version
type Version struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// File Model to represent version file
	File *VersionFile `json:"file,omitempty"`
	ID   *string      `json:"id,omitempty"`

	// Mod Model to represent mod
	Mod       *Mod       `json:"mod,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Public    *bool      `json:"public,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// VersionFile Model to represent version file
type VersionFile struct {
	ContentType *string    `json:"content_type,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	MD5         *string    `json:"md5,omitempty"`
	Path        *string    `json:"path,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	URL         *string    `json:"url,omitempty"`
}

// AuthCodeParam defines model for AuthCodeParam.
type AuthCodeParam = string

// AuthProviderParam defines model for AuthProviderParam.
type AuthProviderParam = string

// AuthStateParam defines model for AuthStateParam.
type AuthStateParam = string

// BuildID defines model for BuildParam.
type BuildID = string

// FabricID defines model for FabricParam.
type FabricID = string

// ForgeID defines model for ForgeParam.
type ForgeID = string

// GroupID defines model for GroupParam.
type GroupID = string

// MinecraftID defines model for MinecraftParam.
type MinecraftID = string

// ModID defines model for ModParam.
type ModID = string

// NeoforgeID defines model for NeoforgeParam.
type NeoforgeID = string

// PackID defines model for PackParam.
type PackID = string

// PagingLimitParam defines model for PagingLimitParam.
type PagingLimitParam = int

// PagingOffsetParam defines model for PagingOffsetParam.
type PagingOffsetParam = int

// QuiltID defines model for QuiltParam.
type QuiltID = string

// SearchQueryParam defines model for SearchQueryParam.
type SearchQueryParam = string

// SortColumnParam defines model for SortColumnParam.
type SortColumnParam = string

// SortOrderParam defines model for SortOrderParam.
type SortOrderParam string

// UserID defines model for UserParam.
type UserID = string

// VersionID defines model for VersionParam.
type VersionID = string

// ActionFailedError Generic response for errors and validations
type ActionFailedError = Notification

// AlreadyAttachedError Generic response for errors and validations
type AlreadyAttachedError = Notification

// BadCredentialsError Generic response for errors and validations
type BadCredentialsError = Notification

// BadRequestError Generic response for errors and validations
type BadRequestError = Notification

// BuildResponse Model to represent build
type BuildResponse = Build

// BuildVersionsResponse defines model for BuildVersionsResponse.
type BuildVersionsResponse struct {
	// Build Model to represent build
	Build  *Build `json:"build,omitempty"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`

	// Pack Model to represent pack
	Pack     *Pack          `json:"pack,omitempty"`
	Total    int64          `json:"total"`
	Versions []BuildVersion `json:"versions"`
}

// BuildsResponse defines model for BuildsResponse.
type BuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack `json:"pack,omitempty"`
	Total int64 `json:"total"`
}

// FabricBuildsResponse defines model for FabricBuildsResponse.
type FabricBuildsResponse struct {
	Builds []Build `json:"builds"`

	// Fabric Model to represent fabric
	Fabric *Fabric `json:"fabric,omitempty"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
	Total  int64   `json:"total"`
}

// FabricsResponse defines model for FabricsResponse.
type FabricsResponse struct {
	Limit    int64    `json:"limit"`
	Offset   int64    `json:"offset"`
	Total    int64    `json:"total"`
	Versions []Fabric `json:"versions"`
}

// ForgeBuildsResponse defines model for ForgeBuildsResponse.
type ForgeBuildsResponse struct {
	Builds []Build `json:"builds"`

	// Forge Model to represent forge
	Forge  *Forge `json:"forge,omitempty"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Total  int64  `json:"total"`
}

// ForgesResponse defines model for ForgesResponse.
type ForgesResponse struct {
	Limit    int64   `json:"limit"`
	Offset   int64   `json:"offset"`
	Total    int64   `json:"total"`
	Versions []Forge `json:"versions"`
}

// GroupModsResponse defines model for GroupModsResponse.
type GroupModsResponse struct {
	// Group Model to represent group
	Group  *Group     `json:"group,omitempty"`
	Limit  int64      `json:"limit"`
	Mods   []GroupMod `json:"mods"`
	Offset int64      `json:"offset"`
	Total  int64      `json:"total"`
}

// GroupPacksResponse defines model for GroupPacksResponse.
type GroupPacksResponse struct {
	// Group Model to represent group
	Group  *Group      `json:"group,omitempty"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Packs  []GroupPack `json:"packs"`
	Total  int64       `json:"total"`
}

// GroupResponse Model to represent group
type GroupResponse = Group

// GroupUsersResponse defines model for GroupUsersResponse.
type GroupUsersResponse struct {
	// Group Model to represent group
	Group  *Group      `json:"group,omitempty"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`
	Users  []UserGroup `json:"users"`
}

// GroupsResponse defines model for GroupsResponse.
type GroupsResponse struct {
	Groups []Group `json:"groups"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
	Total  int64   `json:"total"`
}

// InternalServerError Generic response for errors and validations
type InternalServerError = Notification

// InvalidTokenError Generic response for errors and validations
type InvalidTokenError = Notification

// LoginResponse defines model for LoginResponse.
type LoginResponse = AuthToken

// MinecraftBuildsResponse defines model for MinecraftBuildsResponse.
type MinecraftBuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`

	// Minecraft Model to represent minecraft
	Minecraft *Minecraft `json:"minecraft,omitempty"`
	Offset    int64      `json:"offset"`
	Total     int64      `json:"total"`
}

// MinecraftsResponse defines model for MinecraftsResponse.
type MinecraftsResponse struct {
	Limit    int64       `json:"limit"`
	Offset   int64       `json:"offset"`
	Total    int64       `json:"total"`
	Versions []Minecraft `json:"versions"`
}

// ModAvatarResponse Model to represent mod avatar
type ModAvatarResponse = ModAvatar

// ModGroupsResponse defines model for ModGroupsResponse.
type ModGroupsResponse struct {
	Groups []GroupMod `json:"groups"`
	Limit  int64      `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod  `json:"mod,omitempty"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`
}

// ModResponse Model to represent mod
type ModResponse = Mod

// ModUsersResponse defines model for ModUsersResponse.
type ModUsersResponse struct {
	Limit int64 `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod      `json:"mod,omitempty"`
	Offset int64     `json:"offset"`
	Total  int64     `json:"total"`
	Users  []UserMod `json:"users"`
}

// ModsResponse defines model for ModsResponse.
type ModsResponse struct {
	Limit  int64 `json:"limit"`
	Mods   []Mod `json:"mods"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`
}

// NeoforgeBuildsResponse defines model for NeoforgeBuildsResponse.
type NeoforgeBuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`

	// Neoforge Model to represent neoforge
	Neoforge *Neoforge `json:"neoforge,omitempty"`
	Offset   int64     `json:"offset"`
	Total    int64     `json:"total"`
}

// NeoforgesResponse defines model for NeoforgesResponse.
type NeoforgesResponse struct {
	Limit    int64      `json:"limit"`
	Offset   int64      `json:"offset"`
	Total    int64      `json:"total"`
	Versions []Neoforge `json:"versions"`
}

// NotAttachedError Generic response for errors and validations
type NotAttachedError = Notification

// NotAuthorizedError Generic response for errors and validations
type NotAuthorizedError = Notification

// NotFoundError Generic response for errors and validations
type NotFoundError = Notification

// PackAvatarResponse Model to represent pack avatar
type PackAvatarResponse = PackAvatar

// PackGroupsResponse defines model for PackGroupsResponse.
type PackGroupsResponse struct {
	Groups []GroupPack `json:"groups"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack `json:"pack,omitempty"`
	Total int64 `json:"total"`
}

// PackResponse Model to represent pack
type PackResponse = Pack

// PackUsersResponse defines model for PackUsersResponse.
type PackUsersResponse struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack      `json:"pack,omitempty"`
	Total int64      `json:"total"`
	Users []UserPack `json:"users"`
}

// PacksResponse defines model for PacksResponse.
type PacksResponse struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Packs  []Pack `json:"packs"`
	Total  int64  `json:"total"`
}

// ProfileResponse Model to represent profile
type ProfileResponse = Profile

// ProvidersResponse defines model for ProvidersResponse.
type ProvidersResponse struct {
	Providers []Provider `json:"providers"`
	Total     int64      `json:"total"`
}

// QuiltBuildsResponse defines model for QuiltBuildsResponse.
type QuiltBuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`

	// Quilt Model to represent quilt
	Quilt *Quilt `json:"quilt,omitempty"`
	Total int64  `json:"total"`
}

// QuiltsResponse defines model for QuiltsResponse.
type QuiltsResponse struct {
	Limit    int64   `json:"limit"`
	Offset   int64   `json:"offset"`
	Total    int64   `json:"total"`
	Versions []Quilt `json:"versions"`
}

// RefreshResponse defines model for RefreshResponse.
type RefreshResponse = AuthToken

// RemoteUnavailableError Generic response for errors and validations
type RemoteUnavailableError = Notification

// SuccessMessage Generic response for errors and validations
type SuccessMessage = Notification

// TokenResponse defines model for TokenResponse.
type TokenResponse = AuthToken

// UserGroupsResponse defines model for UserGroupsResponse.
type UserGroupsResponse struct {
	Groups []UserGroup `json:"groups"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserModsResponse defines model for UserModsResponse.
type UserModsResponse struct {
	Limit  int64     `json:"limit"`
	Mods   []UserMod `json:"mods"`
	Offset int64     `json:"offset"`
	Total  int64     `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserPacksResponse defines model for UserPacksResponse.
type UserPacksResponse struct {
	Limit  int64      `json:"limit"`
	Offset int64      `json:"offset"`
	Packs  []UserPack `json:"packs"`
	Total  int64      `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserResponse Model to represent user
type UserResponse = User

// UsersResponse defines model for UsersResponse.
type UsersResponse struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Total  int64  `json:"total"`
	Users  []User `json:"users"`
}

// ValidationError Generic response for errors and validations
type ValidationError = Notification

// VerifyResponse defines model for VerifyResponse.
type VerifyResponse = AuthVerify

// VersionBuildsResponse defines model for VersionBuildsResponse.
type VersionBuildsResponse struct {
	Builds []BuildVersion `json:"builds"`
	Limit  int64          `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod  `json:"mod,omitempty"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`

	// Version Model to represent version
	Version *Version `json:"version,omitempty"`
}

// VersionResponse Model to represent version
type VersionResponse = Version

// VersionsResponse defines model for VersionsResponse.
type VersionsResponse struct {
	Limit int64 `json:"limit"`

	// Mod Model to represent mod
	Mod      *Mod      `json:"mod,omitempty"`
	Offset   int64     `json:"offset"`
	Total    int64     `json:"total"`
	Versions []Version `json:"versions"`
}

// BuildVersionBody defines model for BuildVersionBody.
type BuildVersionBody struct {
	Mod     string `json:"mod,omitempty"`
	Version string `json:"version,omitempty"`
}

// CreateBuildBody defines model for CreateBuildBody.
type CreateBuildBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// CreateGroupBody defines model for CreateGroupBody.
type CreateGroupBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// CreateModBody defines model for CreateModBody.
type CreateModBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// CreatePackBody defines model for CreatePackBody.
type CreatePackBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// CreateUserBody defines model for CreateUserBody.
type CreateUserBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// CreateVersionBody defines model for CreateVersionBody.
type CreateVersionBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// FabricBuildBody defines model for FabricBuildBody.
type FabricBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ForgeBuildBody defines model for ForgeBuildBody.
type ForgeBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// GroupModDropBody defines model for GroupModDropBody.
type GroupModDropBody struct {
	Mod string `json:"mod"`
}

// GroupModPermBody defines model for GroupModPermBody.
type GroupModPermBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// GroupPackDropBody defines model for GroupPackDropBody.
type GroupPackDropBody struct {
	Pack string `json:"pack"`
}

// GroupPackPermBody defines model for GroupPackPermBody.
type GroupPackPermBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// GroupUserDropBody defines model for GroupUserDropBody.
type GroupUserDropBody struct {
	User string `json:"user"`
}

// GroupUserPermBody defines model for GroupUserPermBody.
type GroupUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// LoginAuthBody defines model for LoginAuthBody.
type LoginAuthBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// MinecraftBuildBody defines model for MinecraftBuildBody.
type MinecraftBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ModGroupDropBody defines model for ModGroupDropBody.
type ModGroupDropBody struct {
	Group string `json:"group"`
}

// ModGroupPermBody defines model for ModGroupPermBody.
type ModGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// ModUserDropBody defines model for ModUserDropBody.
type ModUserDropBody struct {
	User string `json:"user"`
}

// ModUserPermBody defines model for ModUserPermBody.
type ModUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// NeoforgeBuildBody defines model for NeoforgeBuildBody.
type NeoforgeBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// PackGroupDropBody defines model for PackGroupDropBody.
type PackGroupDropBody struct {
	Group string `json:"group"`
}

// PackGroupPermBody defines model for PackGroupPermBody.
type PackGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PackUserDropBody defines model for PackUserDropBody.
type PackUserDropBody struct {
	User string `json:"user"`
}

// PackUserPermBody defines model for PackUserPermBody.
type PackUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// QuiltBuildBody defines model for QuiltBuildBody.
type QuiltBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// RedirectAuthBody defines model for RedirectAuthBody.
type RedirectAuthBody struct {
	Token string `json:"token"`
}

// UpdateBuildBody defines model for UpdateBuildBody.
type UpdateBuildBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// UpdateGroupBody defines model for UpdateGroupBody.
type UpdateGroupBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateModBody defines model for UpdateModBody.
type UpdateModBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// UpdatePackBody defines model for UpdatePackBody.
type UpdatePackBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// UpdateProfileBody defines model for UpdateProfileBody.
type UpdateProfileBody struct {
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateUserBody defines model for UpdateUserBody.
type UpdateUserBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateVersionBody defines model for UpdateVersionBody.
type UpdateVersionBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// UserGroupDropBody defines model for UserGroupDropBody.
type UserGroupDropBody struct {
	Group string `json:"group"`
}

// UserGroupPermBody defines model for UserGroupPermBody.
type UserGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// UserModDropBody defines model for UserModDropBody.
type UserModDropBody struct {
	Mod string `json:"mod"`
}

// UserModPermBody defines model for UserModPermBody.
type UserModPermBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// UserPackDropBody defines model for UserPackDropBody.
type UserPackDropBody struct {
	Pack string `json:"pack"`
}

// UserPackPermBody defines model for UserPackPermBody.
type UserPackPermBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// VersionBuildBody defines model for VersionBuildBody.
type VersionBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// LoginAuthJSONBody defines parameters for LoginAuth.
type LoginAuthJSONBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// RedirectAuthJSONBody defines parameters for RedirectAuth.
type RedirectAuthJSONBody struct {
	Token string `json:"token"`
}

// CallbackProviderParams defines parameters for CallbackProvider.
type CallbackProviderParams struct {
	// State Auth state
	State *AuthStateParam `form:"state,omitempty" json:"state,omitempty"`

	// Code Auth code
	Code *AuthCodeParam `form:"code,omitempty" json:"code,omitempty"`
}

// ListFabricsParams defines parameters for ListFabrics.
type ListFabricsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteFabricFromBuildJSONBody defines parameters for DeleteFabricFromBuild.
type DeleteFabricFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListFabricBuildsParams defines parameters for ListFabricBuilds.
type ListFabricBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListFabricBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListFabricBuildsParamsOrder defines parameters for ListFabricBuilds.
type ListFabricBuildsParamsOrder string

// AttachFabricToBuildJSONBody defines parameters for AttachFabricToBuild.
type AttachFabricToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListForgesParams defines parameters for ListForges.
type ListForgesParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteForgeFromBuildJSONBody defines parameters for DeleteForgeFromBuild.
type DeleteForgeFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListForgeBuildsParams defines parameters for ListForgeBuilds.
type ListForgeBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListForgeBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListForgeBuildsParamsOrder defines parameters for ListForgeBuilds.
type ListForgeBuildsParamsOrder string

// AttachForgeToBuildJSONBody defines parameters for AttachForgeToBuild.
type AttachForgeToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupsParamsOrder defines parameters for ListGroups.
type ListGroupsParamsOrder string

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateGroupJSONBody defines parameters for UpdateGroup.
type UpdateGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// DeleteGroupFromModJSONBody defines parameters for DeleteGroupFromMod.
type DeleteGroupFromModJSONBody struct {
	Mod string `json:"mod"`
}

// ListGroupModsParams defines parameters for ListGroupMods.
type ListGroupModsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupModsParamsOrder defines parameters for ListGroupMods.
type ListGroupModsParamsOrder string

// AttachGroupToModJSONBody defines parameters for AttachGroupToMod.
type AttachGroupToModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// PermitGroupModJSONBody defines parameters for PermitGroupMod.
type PermitGroupModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// DeleteGroupFromPackJSONBody defines parameters for DeleteGroupFromPack.
type DeleteGroupFromPackJSONBody struct {
	Pack string `json:"pack"`
}

// ListGroupPacksParams defines parameters for ListGroupPacks.
type ListGroupPacksParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupPacksParamsOrder defines parameters for ListGroupPacks.
type ListGroupPacksParamsOrder string

// AttachGroupToPackJSONBody defines parameters for AttachGroupToPack.
type AttachGroupToPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// PermitGroupPackJSONBody defines parameters for PermitGroupPack.
type PermitGroupPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// DeleteGroupFromUserJSONBody defines parameters for DeleteGroupFromUser.
type DeleteGroupFromUserJSONBody struct {
	User string `json:"user"`
}

// ListGroupUsersParams defines parameters for ListGroupUsers.
type ListGroupUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupUsersParamsOrder defines parameters for ListGroupUsers.
type ListGroupUsersParamsOrder string

// AttachGroupToUserJSONBody defines parameters for AttachGroupToUser.
type AttachGroupToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitGroupUserJSONBody defines parameters for PermitGroupUser.
type PermitGroupUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// ListMinecraftsParams defines parameters for ListMinecrafts.
type ListMinecraftsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteMinecraftFromBuildJSONBody defines parameters for DeleteMinecraftFromBuild.
type DeleteMinecraftFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListMinecraftBuildsParams defines parameters for ListMinecraftBuilds.
type ListMinecraftBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListMinecraftBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListMinecraftBuildsParamsOrder defines parameters for ListMinecraftBuilds.
type ListMinecraftBuildsParamsOrder string

// AttachMinecraftToBuildJSONBody defines parameters for AttachMinecraftToBuild.
type AttachMinecraftToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListModsParams defines parameters for ListMods.
type ListModsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModsParamsOrder defines parameters for ListMods.
type ListModsParamsOrder string

// CreateModJSONBody defines parameters for CreateMod.
type CreateModJSONBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// UpdateModJSONBody defines parameters for UpdateMod.
type UpdateModJSONBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// CreateModAvatarMultipartBody defines parameters for CreateModAvatar.
type CreateModAvatarMultipartBody struct {
	File *openapi_types.File `json:"file,omitempty"`
}

// DeleteModFromGroupJSONBody defines parameters for DeleteModFromGroup.
type DeleteModFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListModGroupsParams defines parameters for ListModGroups.
type ListModGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModGroupsParamsOrder defines parameters for ListModGroups.
type ListModGroupsParamsOrder string

// AttachModToGroupJSONBody defines parameters for AttachModToGroup.
type AttachModToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitModGroupJSONBody defines parameters for PermitModGroup.
type PermitModGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// DeleteModFromUserJSONBody defines parameters for DeleteModFromUser.
type DeleteModFromUserJSONBody struct {
	User string `json:"user"`
}

// ListModUsersParams defines parameters for ListModUsers.
type ListModUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModUsersParamsOrder defines parameters for ListModUsers.
type ListModUsersParamsOrder string

// AttachModToUserJSONBody defines parameters for AttachModToUser.
type AttachModToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitModUserJSONBody defines parameters for PermitModUser.
type PermitModUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// ListVersionsParams defines parameters for ListVersions.
type ListVersionsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListVersionsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListVersionsParamsOrder defines parameters for ListVersions.
type ListVersionsParamsOrder string

// CreateVersionJSONBody defines parameters for CreateVersion.
type CreateVersionJSONBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// UpdateVersionJSONBody defines parameters for UpdateVersion.
type UpdateVersionJSONBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// DeleteVersionFromBuildJSONBody defines parameters for DeleteVersionFromBuild.
type DeleteVersionFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListVersionBuildsParams defines parameters for ListVersionBuilds.
type ListVersionBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListVersionBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListVersionBuildsParamsOrder defines parameters for ListVersionBuilds.
type ListVersionBuildsParamsOrder string

// AttachVersionToBuildJSONBody defines parameters for AttachVersionToBuild.
type AttachVersionToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListNeoforgesParams defines parameters for ListNeoforges.
type ListNeoforgesParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteNeoforgeFromBuildJSONBody defines parameters for DeleteNeoforgeFromBuild.
type DeleteNeoforgeFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListNeoforgeBuildsParams defines parameters for ListNeoforgeBuilds.
type ListNeoforgeBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListNeoforgeBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListNeoforgeBuildsParamsOrder defines parameters for ListNeoforgeBuilds.
type ListNeoforgeBuildsParamsOrder string

// AttachNeoforgeToBuildJSONBody defines parameters for AttachNeoforgeToBuild.
type AttachNeoforgeToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListPacksParams defines parameters for ListPacks.
type ListPacksParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPacksParamsOrder defines parameters for ListPacks.
type ListPacksParamsOrder string

// CreatePackJSONBody defines parameters for CreatePack.
type CreatePackJSONBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// UpdatePackJSONBody defines parameters for UpdatePack.
type UpdatePackJSONBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// CreatePackAvatarMultipartBody defines parameters for CreatePackAvatar.
type CreatePackAvatarMultipartBody struct {
	File *openapi_types.File `json:"file,omitempty"`
}

// ListBuildsParams defines parameters for ListBuilds.
type ListBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListBuildsParamsOrder defines parameters for ListBuilds.
type ListBuildsParamsOrder string

// CreateBuildJSONBody defines parameters for CreateBuild.
type CreateBuildJSONBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// UpdateBuildJSONBody defines parameters for UpdateBuild.
type UpdateBuildJSONBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// DeleteBuildFromVersionJSONBody defines parameters for DeleteBuildFromVersion.
type DeleteBuildFromVersionJSONBody struct {
	Mod     string `json:"mod,omitempty"`
	Version string `json:"version,omitempty"`
}

// ListBuildVersionsParams defines parameters for ListBuildVersions.
type ListBuildVersionsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListBuildVersionsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListBuildVersionsParamsOrder defines parameters for ListBuildVersions.
type ListBuildVersionsParamsOrder string

// AttachBuildToVersionJSONBody defines parameters for AttachBuildToVersion.
type AttachBuildToVersionJSONBody struct {
	Mod     string `json:"mod,omitempty"`
	Version string `json:"version,omitempty"`
}

// DeletePackFromGroupJSONBody defines parameters for DeletePackFromGroup.
type DeletePackFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListPackGroupsParams defines parameters for ListPackGroups.
type ListPackGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPackGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPackGroupsParamsOrder defines parameters for ListPackGroups.
type ListPackGroupsParamsOrder string

// AttachPackToGroupJSONBody defines parameters for AttachPackToGroup.
type AttachPackToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitPackGroupJSONBody defines parameters for PermitPackGroup.
type PermitPackGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// DeletePackFromUserJSONBody defines parameters for DeletePackFromUser.
type DeletePackFromUserJSONBody struct {
	User string `json:"user"`
}

// ListPackUsersParams defines parameters for ListPackUsers.
type ListPackUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPackUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPackUsersParamsOrder defines parameters for ListPackUsers.
type ListPackUsersParamsOrder string

// AttachPackToUserJSONBody defines parameters for AttachPackToUser.
type AttachPackToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitPackUserJSONBody defines parameters for PermitPackUser.
type PermitPackUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// UpdateProfileJSONBody defines parameters for UpdateProfile.
type UpdateProfileJSONBody struct {
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// ListQuiltsParams defines parameters for ListQuilts.
type ListQuiltsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteQuiltFromBuildJSONBody defines parameters for DeleteQuiltFromBuild.
type DeleteQuiltFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListQuiltBuildsParams defines parameters for ListQuiltBuilds.
type ListQuiltBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListQuiltBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListQuiltBuildsParamsOrder defines parameters for ListQuiltBuilds.
type ListQuiltBuildsParamsOrder string

// AttachQuiltToBuildJSONBody defines parameters for AttachQuiltToBuild.
type AttachQuiltToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUsersParamsOrder defines parameters for ListUsers.
type ListUsersParamsOrder string

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// DeleteUserFromGroupJSONBody defines parameters for DeleteUserFromGroup.
type DeleteUserFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListUserGroupsParams defines parameters for ListUserGroups.
type ListUserGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserGroupsParamsOrder defines parameters for ListUserGroups.
type ListUserGroupsParamsOrder string

// AttachUserToGroupJSONBody defines parameters for AttachUserToGroup.
type AttachUserToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitUserGroupJSONBody defines parameters for PermitUserGroup.
type PermitUserGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// DeleteUserFromModJSONBody defines parameters for DeleteUserFromMod.
type DeleteUserFromModJSONBody struct {
	Mod string `json:"mod"`
}

// ListUserModsParams defines parameters for ListUserMods.
type ListUserModsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserModsParamsOrder defines parameters for ListUserMods.
type ListUserModsParamsOrder string

// AttachUserToModJSONBody defines parameters for AttachUserToMod.
type AttachUserToModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// PermitUserModJSONBody defines parameters for PermitUserMod.
type PermitUserModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// DeleteUserFromPackJSONBody defines parameters for DeleteUserFromPack.
type DeleteUserFromPackJSONBody struct {
	Pack string `json:"pack"`
}

// ListUserPacksParams defines parameters for ListUserPacks.
type ListUserPacksParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserPacksParamsOrder defines parameters for ListUserPacks.
type ListUserPacksParamsOrder string

// AttachUserToPackJSONBody defines parameters for AttachUserToPack.
type AttachUserToPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// PermitUserPackJSONBody defines parameters for PermitUserPack.
type PermitUserPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// LoginAuthJSONRequestBody defines body for LoginAuth for application/json ContentType.
type LoginAuthJSONRequestBody LoginAuthJSONBody

// RedirectAuthJSONRequestBody defines body for RedirectAuth for application/json ContentType.
type RedirectAuthJSONRequestBody RedirectAuthJSONBody

// DeleteFabricFromBuildJSONRequestBody defines body for DeleteFabricFromBuild for application/json ContentType.
type DeleteFabricFromBuildJSONRequestBody DeleteFabricFromBuildJSONBody

// AttachFabricToBuildJSONRequestBody defines body for AttachFabricToBuild for application/json ContentType.
type AttachFabricToBuildJSONRequestBody AttachFabricToBuildJSONBody

// DeleteForgeFromBuildJSONRequestBody defines body for DeleteForgeFromBuild for application/json ContentType.
type DeleteForgeFromBuildJSONRequestBody DeleteForgeFromBuildJSONBody

// AttachForgeToBuildJSONRequestBody defines body for AttachForgeToBuild for application/json ContentType.
type AttachForgeToBuildJSONRequestBody AttachForgeToBuildJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody UpdateGroupJSONBody

// DeleteGroupFromModJSONRequestBody defines body for DeleteGroupFromMod for application/json ContentType.
type DeleteGroupFromModJSONRequestBody DeleteGroupFromModJSONBody

// AttachGroupToModJSONRequestBody defines body for AttachGroupToMod for application/json ContentType.
type AttachGroupToModJSONRequestBody AttachGroupToModJSONBody

// PermitGroupModJSONRequestBody defines body for PermitGroupMod for application/json ContentType.
type PermitGroupModJSONRequestBody PermitGroupModJSONBody

// DeleteGroupFromPackJSONRequestBody defines body for DeleteGroupFromPack for application/json ContentType.
type DeleteGroupFromPackJSONRequestBody DeleteGroupFromPackJSONBody

// AttachGroupToPackJSONRequestBody defines body for AttachGroupToPack for application/json ContentType.
type AttachGroupToPackJSONRequestBody AttachGroupToPackJSONBody

// PermitGroupPackJSONRequestBody defines body for PermitGroupPack for application/json ContentType.
type PermitGroupPackJSONRequestBody PermitGroupPackJSONBody

// DeleteGroupFromUserJSONRequestBody defines body for DeleteGroupFromUser for application/json ContentType.
type DeleteGroupFromUserJSONRequestBody DeleteGroupFromUserJSONBody

// AttachGroupToUserJSONRequestBody defines body for AttachGroupToUser for application/json ContentType.
type AttachGroupToUserJSONRequestBody AttachGroupToUserJSONBody

// PermitGroupUserJSONRequestBody defines body for PermitGroupUser for application/json ContentType.
type PermitGroupUserJSONRequestBody PermitGroupUserJSONBody

// DeleteMinecraftFromBuildJSONRequestBody defines body for DeleteMinecraftFromBuild for application/json ContentType.
type DeleteMinecraftFromBuildJSONRequestBody DeleteMinecraftFromBuildJSONBody

// AttachMinecraftToBuildJSONRequestBody defines body for AttachMinecraftToBuild for application/json ContentType.
type AttachMinecraftToBuildJSONRequestBody AttachMinecraftToBuildJSONBody

// CreateModJSONRequestBody defines body for CreateMod for application/json ContentType.
type CreateModJSONRequestBody CreateModJSONBody

// UpdateModJSONRequestBody defines body for UpdateMod for application/json ContentType.
type UpdateModJSONRequestBody UpdateModJSONBody

// CreateModAvatarMultipartRequestBody defines body for CreateModAvatar for multipart/form-data ContentType.
type CreateModAvatarMultipartRequestBody CreateModAvatarMultipartBody

// DeleteModFromGroupJSONRequestBody defines body for DeleteModFromGroup for application/json ContentType.
type DeleteModFromGroupJSONRequestBody DeleteModFromGroupJSONBody

// AttachModToGroupJSONRequestBody defines body for AttachModToGroup for application/json ContentType.
type AttachModToGroupJSONRequestBody AttachModToGroupJSONBody

// PermitModGroupJSONRequestBody defines body for PermitModGroup for application/json ContentType.
type PermitModGroupJSONRequestBody PermitModGroupJSONBody

// DeleteModFromUserJSONRequestBody defines body for DeleteModFromUser for application/json ContentType.
type DeleteModFromUserJSONRequestBody DeleteModFromUserJSONBody

// AttachModToUserJSONRequestBody defines body for AttachModToUser for application/json ContentType.
type AttachModToUserJSONRequestBody AttachModToUserJSONBody

// PermitModUserJSONRequestBody defines body for PermitModUser for application/json ContentType.
type PermitModUserJSONRequestBody PermitModUserJSONBody

// CreateVersionJSONRequestBody defines body for CreateVersion for application/json ContentType.
type CreateVersionJSONRequestBody CreateVersionJSONBody

// UpdateVersionJSONRequestBody defines body for UpdateVersion for application/json ContentType.
type UpdateVersionJSONRequestBody UpdateVersionJSONBody

// DeleteVersionFromBuildJSONRequestBody defines body for DeleteVersionFromBuild for application/json ContentType.
type DeleteVersionFromBuildJSONRequestBody DeleteVersionFromBuildJSONBody

// AttachVersionToBuildJSONRequestBody defines body for AttachVersionToBuild for application/json ContentType.
type AttachVersionToBuildJSONRequestBody AttachVersionToBuildJSONBody

// DeleteNeoforgeFromBuildJSONRequestBody defines body for DeleteNeoforgeFromBuild for application/json ContentType.
type DeleteNeoforgeFromBuildJSONRequestBody DeleteNeoforgeFromBuildJSONBody

// AttachNeoforgeToBuildJSONRequestBody defines body for AttachNeoforgeToBuild for application/json ContentType.
type AttachNeoforgeToBuildJSONRequestBody AttachNeoforgeToBuildJSONBody

// CreatePackJSONRequestBody defines body for CreatePack for application/json ContentType.
type CreatePackJSONRequestBody CreatePackJSONBody

// UpdatePackJSONRequestBody defines body for UpdatePack for application/json ContentType.
type UpdatePackJSONRequestBody UpdatePackJSONBody

// CreatePackAvatarMultipartRequestBody defines body for CreatePackAvatar for multipart/form-data ContentType.
type CreatePackAvatarMultipartRequestBody CreatePackAvatarMultipartBody

// CreateBuildJSONRequestBody defines body for CreateBuild for application/json ContentType.
type CreateBuildJSONRequestBody CreateBuildJSONBody

// UpdateBuildJSONRequestBody defines body for UpdateBuild for application/json ContentType.
type UpdateBuildJSONRequestBody UpdateBuildJSONBody

// DeleteBuildFromVersionJSONRequestBody defines body for DeleteBuildFromVersion for application/json ContentType.
type DeleteBuildFromVersionJSONRequestBody DeleteBuildFromVersionJSONBody

// AttachBuildToVersionJSONRequestBody defines body for AttachBuildToVersion for application/json ContentType.
type AttachBuildToVersionJSONRequestBody AttachBuildToVersionJSONBody

// DeletePackFromGroupJSONRequestBody defines body for DeletePackFromGroup for application/json ContentType.
type DeletePackFromGroupJSONRequestBody DeletePackFromGroupJSONBody

// AttachPackToGroupJSONRequestBody defines body for AttachPackToGroup for application/json ContentType.
type AttachPackToGroupJSONRequestBody AttachPackToGroupJSONBody

// PermitPackGroupJSONRequestBody defines body for PermitPackGroup for application/json ContentType.
type PermitPackGroupJSONRequestBody PermitPackGroupJSONBody

// DeletePackFromUserJSONRequestBody defines body for DeletePackFromUser for application/json ContentType.
type DeletePackFromUserJSONRequestBody DeletePackFromUserJSONBody

// AttachPackToUserJSONRequestBody defines body for AttachPackToUser for application/json ContentType.
type AttachPackToUserJSONRequestBody AttachPackToUserJSONBody

// PermitPackUserJSONRequestBody defines body for PermitPackUser for application/json ContentType.
type PermitPackUserJSONRequestBody PermitPackUserJSONBody

// UpdateProfileJSONRequestBody defines body for UpdateProfile for application/json ContentType.
type UpdateProfileJSONRequestBody UpdateProfileJSONBody

// DeleteQuiltFromBuildJSONRequestBody defines body for DeleteQuiltFromBuild for application/json ContentType.
type DeleteQuiltFromBuildJSONRequestBody DeleteQuiltFromBuildJSONBody

// AttachQuiltToBuildJSONRequestBody defines body for AttachQuiltToBuild for application/json ContentType.
type AttachQuiltToBuildJSONRequestBody AttachQuiltToBuildJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// DeleteUserFromGroupJSONRequestBody defines body for DeleteUserFromGroup for application/json ContentType.
type DeleteUserFromGroupJSONRequestBody DeleteUserFromGroupJSONBody

// AttachUserToGroupJSONRequestBody defines body for AttachUserToGroup for application/json ContentType.
type AttachUserToGroupJSONRequestBody AttachUserToGroupJSONBody

// PermitUserGroupJSONRequestBody defines body for PermitUserGroup for application/json ContentType.
type PermitUserGroupJSONRequestBody PermitUserGroupJSONBody

// DeleteUserFromModJSONRequestBody defines body for DeleteUserFromMod for application/json ContentType.
type DeleteUserFromModJSONRequestBody DeleteUserFromModJSONBody

// AttachUserToModJSONRequestBody defines body for AttachUserToMod for application/json ContentType.
type AttachUserToModJSONRequestBody AttachUserToModJSONBody

// PermitUserModJSONRequestBody defines body for PermitUserMod for application/json ContentType.
type PermitUserModJSONRequestBody PermitUserModJSONBody

// DeleteUserFromPackJSONRequestBody defines body for DeleteUserFromPack for application/json ContentType.
type DeleteUserFromPackJSONRequestBody DeleteUserFromPackJSONBody

// AttachUserToPackJSONRequestBody defines body for AttachUserToPack for application/json ContentType.
type AttachUserToPackJSONRequestBody AttachUserToPackJSONBody

// PermitUserPackJSONRequestBody defines body for PermitUserPack for application/json ContentType.
type PermitUserPackJSONRequestBody PermitUserPackJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate an user by credentials
	// (POST /auth/login)
	LoginAuth(w http.ResponseWriter, r *http.Request)
	// Fetch the available auth providers
	// (GET /auth/providers)
	ListProviders(w http.ResponseWriter, r *http.Request)
	// Retrieve real token after redirect
	// (POST /auth/redirect)
	RedirectAuth(w http.ResponseWriter, r *http.Request)
	// Refresh an auth token before it expires
	// (GET /auth/refresh)
	RefreshAuth(w http.ResponseWriter, r *http.Request)
	// Verify validity for an authentication token
	// (GET /auth/verify)
	VerifyAuth(w http.ResponseWriter, r *http.Request)
	// Callback to parse the defined provider
	// (GET /auth/{provider}/callback)
	CallbackProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam, params CallbackProviderParams)
	// Request the redirect to defined provider
	// (GET /auth/{provider}/request)
	RequestProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam)
	// Fetch the available Fabric versions
	// (GET /fabric)
	ListFabrics(w http.ResponseWriter, r *http.Request, params ListFabricsParams)
	// Update the available Fabric versions
	// (PUT /fabric)
	UpdateFabric(w http.ResponseWriter, r *http.Request)
	// Unlink a build from a Fabric version
	// (DELETE /fabric/{fabric_id}/builds)
	DeleteFabricFromBuild(w http.ResponseWriter, r *http.Request, fabricID FabricID)
	// Fetch the builds attached to a Fabric version
	// (GET /fabric/{fabric_id}/builds)
	ListFabricBuilds(w http.ResponseWriter, r *http.Request, fabricID FabricID, params ListFabricBuildsParams)
	// Attach a build to a Fabric version
	// (POST /fabric/{fabric_id}/builds)
	AttachFabricToBuild(w http.ResponseWriter, r *http.Request, fabricID FabricID)
	// Fetch the available Forge versions
	// (GET /forge)
	ListForges(w http.ResponseWriter, r *http.Request, params ListForgesParams)
	// Update the available Forge versions
	// (PUT /forge)
	UpdateForge(w http.ResponseWriter, r *http.Request)
	// Unlink a build from a Forge version
	// (DELETE /forge/{forge_id}/builds)
	DeleteForgeFromBuild(w http.ResponseWriter, r *http.Request, forgeID ForgeID)
	// Fetch the builds attached to a Forge version
	// (GET /forge/{forge_id}/builds)
	ListForgeBuilds(w http.ResponseWriter, r *http.Request, forgeID ForgeID, params ListForgeBuildsParams)
	// Attach a build to a Forge version
	// (POST /forge/{forge_id}/builds)
	AttachForgeToBuild(w http.ResponseWriter, r *http.Request, forgeID ForgeID)
	// Fetch all available groups
	// (GET /groups)
	ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams)
	// Create a new group
	// (POST /groups)
	CreateGroup(w http.ResponseWriter, r *http.Request)
	// Delete a specific group
	// (DELETE /groups/{group_id})
	DeleteGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch a specific group
	// (GET /groups/{group_id})
	ShowGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update a specific group
	// (PUT /groups/{group_id})
	UpdateGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Unlink a mod from group
	// (DELETE /groups/{group_id}/mods)
	DeleteGroupFromMod(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch all mods attached to group
	// (GET /groups/{group_id}/mods)
	ListGroupMods(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupModsParams)
	// Attach a mod to group
	// (POST /groups/{group_id}/mods)
	AttachGroupToMod(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update mod perms for group
	// (PUT /groups/{group_id}/mods)
	PermitGroupMod(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Unlink a pack from group
	// (DELETE /groups/{group_id}/packs)
	DeleteGroupFromPack(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch all packs attached to group
	// (GET /groups/{group_id}/packs)
	ListGroupPacks(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupPacksParams)
	// Attach a pack to group
	// (POST /groups/{group_id}/packs)
	AttachGroupToPack(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update pack perms for group
	// (PUT /groups/{group_id}/packs)
	PermitGroupPack(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Unlink a user from group
	// (DELETE /groups/{group_id}/users)
	DeleteGroupFromUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch all users attached to group
	// (GET /groups/{group_id}/users)
	ListGroupUsers(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupUsersParams)
	// Attach a user to group
	// (POST /groups/{group_id}/users)
	AttachGroupToUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update user perms for group
	// (PUT /groups/{group_id}/users)
	PermitGroupUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch the available Minecraft versions
	// (GET /minecraft)
	ListMinecrafts(w http.ResponseWriter, r *http.Request, params ListMinecraftsParams)
	// Update the available Minecraft versions
	// (PUT /minecraft)
	UpdateMinecraft(w http.ResponseWriter, r *http.Request)
	// Unlink a build from a Minecraft version
	// (DELETE /minecraft/{minecraft_id}/builds)
	DeleteMinecraftFromBuild(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID)
	// Fetch the builds attached to a Minecraft version
	// (GET /minecraft/{minecraft_id}/builds)
	ListMinecraftBuilds(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID, params ListMinecraftBuildsParams)
	// Attach a build to a Minecraft version
	// (POST /minecraft/{minecraft_id}/builds)
	AttachMinecraftToBuild(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID)
	// Fetch all available mods
	// (GET /mods)
	ListMods(w http.ResponseWriter, r *http.Request, params ListModsParams)
	// Create a new mod
	// (POST /mods)
	CreateMod(w http.ResponseWriter, r *http.Request)
	// Delete a specific mod
	// (DELETE /mods/{mod_id})
	DeleteMod(w http.ResponseWriter, r *http.Request, modID ModID)
	// Fetch a specific mod
	// (GET /mods/{mod_id})
	ShowMod(w http.ResponseWriter, r *http.Request, modID ModID)
	// Update a specific mod
	// (PUT /mods/{mod_id})
	UpdateMod(w http.ResponseWriter, r *http.Request, modID ModID)
	// Delete the avatar for the defined mod
	// (DELETE /mods/{mod_id}/avatar)
	DeleteModAvatar(w http.ResponseWriter, r *http.Request, modID ModID)
	// Upload an avatar for the defined mod
	// (POST /mods/{mod_id}/avatar)
	CreateModAvatar(w http.ResponseWriter, r *http.Request, modID ModID)
	// Unlink a group from mod
	// (DELETE /mods/{mod_id}/groups)
	DeleteModFromGroup(w http.ResponseWriter, r *http.Request, modID ModID)
	// Fetch all groups attached to mod
	// (GET /mods/{mod_id}/groups)
	ListModGroups(w http.ResponseWriter, r *http.Request, modID ModID, params ListModGroupsParams)
	// Attach a group to mod
	// (POST /mods/{mod_id}/groups)
	AttachModToGroup(w http.ResponseWriter, r *http.Request, modID ModID)
	// Update group perms for mod
	// (PUT /mods/{mod_id}/groups)
	PermitModGroup(w http.ResponseWriter, r *http.Request, modID ModID)
	// Unlink a user from mod
	// (DELETE /mods/{mod_id}/users)
	DeleteModFromUser(w http.ResponseWriter, r *http.Request, modID ModID)
	// Fetch all users attached to mod
	// (GET /mods/{mod_id}/users)
	ListModUsers(w http.ResponseWriter, r *http.Request, modID ModID, params ListModUsersParams)
	// Attach a user to mod
	// (POST /mods/{mod_id}/users)
	AttachModToUser(w http.ResponseWriter, r *http.Request, modID ModID)
	// Update user perms for mod
	// (PUT /mods/{mod_id}/users)
	PermitModUser(w http.ResponseWriter, r *http.Request, modID ModID)
	// Fetch all available versions for a mod
	// (GET /mods/{mod_id}/versions)
	ListVersions(w http.ResponseWriter, r *http.Request, modID ModID, params ListVersionsParams)
	// Create a new version for a mod
	// (POST /mods/{mod_id}/versions)
	CreateVersion(w http.ResponseWriter, r *http.Request, modID ModID)
	// Delete a specific version for a mod
	// (DELETE /mods/{mod_id}/versions/{version_id})
	DeleteVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID)
	// Fetch a specific version for a mod
	// (GET /mods/{mod_id}/versions/{version_id})
	ShowVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID)
	// Update a specific version for a mod
	// (PUT /mods/{mod_id}/versions/{version_id})
	UpdateVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID)
	// Unlink a build from a version
	// (DELETE /mods/{mod_id}/versions/{version_id}/builds)
	DeleteVersionFromBuild(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID)
	// Fetch all builds attached to version
	// (GET /mods/{mod_id}/versions/{version_id}/builds)
	ListVersionBuilds(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID, params ListVersionBuildsParams)
	// Attach a build to a version
	// (POST /mods/{mod_id}/versions/{version_id}/builds)
	AttachVersionToBuild(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID)
	// Fetch the available Neoforge versions
	// (GET /neoforge)
	ListNeoforges(w http.ResponseWriter, r *http.Request, params ListNeoforgesParams)
	// Update the available Neoforge versions
	// (PUT /neoforge)
	UpdateNeoforge(w http.ResponseWriter, r *http.Request)
	// Unlink a build from a Neoforge version
	// (DELETE /neoforge/{neoforge_id}/builds)
	DeleteNeoforgeFromBuild(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID)
	// Fetch the builds attached to a Neoforge version
	// (GET /neoforge/{neoforge_id}/builds)
	ListNeoforgeBuilds(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID, params ListNeoforgeBuildsParams)
	// Attach a build to a Neoforge version
	// (POST /neoforge/{neoforge_id}/builds)
	AttachNeoforgeToBuild(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID)
	// Fetch all available packs
	// (GET /packs)
	ListPacks(w http.ResponseWriter, r *http.Request, params ListPacksParams)
	// Create a new pack
	// (POST /packs)
	CreatePack(w http.ResponseWriter, r *http.Request)
	// Delete a specific pack
	// (DELETE /packs/{pack_id})
	DeletePack(w http.ResponseWriter, r *http.Request, packID PackID)
	// Fetch a specific pack
	// (GET /packs/{pack_id})
	ShowPack(w http.ResponseWriter, r *http.Request, packID PackID)
	// Update a specific pack
	// (PUT /packs/{pack_id})
	UpdatePack(w http.ResponseWriter, r *http.Request, packID PackID)
	// Delete the avatar for the defined pack
	// (DELETE /packs/{pack_id}/avatar)
	DeletePackAvatar(w http.ResponseWriter, r *http.Request, packID PackID)
	// Upload an avatar for the defined pack
	// (POST /packs/{pack_id}/avatar)
	CreatePackAvatar(w http.ResponseWriter, r *http.Request, packID PackID)
	// Fetch all available builds for a pack
	// (GET /packs/{pack_id}/builds)
	ListBuilds(w http.ResponseWriter, r *http.Request, packID PackID, params ListBuildsParams)
	// Create a new build for a pack
	// (POST /packs/{pack_id}/builds)
	CreateBuild(w http.ResponseWriter, r *http.Request, packID PackID)
	// Delete a specific build for a pack
	// (DELETE /packs/{pack_id}/builds/{build_id})
	DeleteBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID)
	// Fetch a specific build for a pack
	// (GET /packs/{pack_id}/builds/{build_id})
	ShowBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID)
	// Update a specific build for a pack
	// (PUT /packs/{pack_id}/builds/{build_id})
	UpdateBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID)
	// Unlink a version from a build
	// (DELETE /packs/{pack_id}/builds/{build_id}/versions)
	DeleteBuildFromVersion(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID)
	// Fetch all versions attached to build
	// (GET /packs/{pack_id}/builds/{build_id}/versions)
	ListBuildVersions(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID, params ListBuildVersionsParams)
	// Attach a version to a build
	// (POST /packs/{pack_id}/builds/{build_id}/versions)
	AttachBuildToVersion(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID)
	// Unlink a group from pack
	// (DELETE /packs/{pack_id}/groups)
	DeletePackFromGroup(w http.ResponseWriter, r *http.Request, packID PackID)
	// Fetch all groups attached to pack
	// (GET /packs/{pack_id}/groups)
	ListPackGroups(w http.ResponseWriter, r *http.Request, packID PackID, params ListPackGroupsParams)
	// Attach a group to pack
	// (POST /packs/{pack_id}/groups)
	AttachPackToGroup(w http.ResponseWriter, r *http.Request, packID PackID)
	// Update group perms for pack
	// (PUT /packs/{pack_id}/groups)
	PermitPackGroup(w http.ResponseWriter, r *http.Request, packID PackID)
	// Unlink a user from pack
	// (DELETE /packs/{pack_id}/users)
	DeletePackFromUser(w http.ResponseWriter, r *http.Request, packID PackID)
	// Fetch all users attached to pack
	// (GET /packs/{pack_id}/users)
	ListPackUsers(w http.ResponseWriter, r *http.Request, packID PackID, params ListPackUsersParams)
	// Attach a user to pack
	// (POST /packs/{pack_id}/users)
	AttachPackToUser(w http.ResponseWriter, r *http.Request, packID PackID)
	// Update user perms for pack
	// (PUT /packs/{pack_id}/users)
	PermitPackUser(w http.ResponseWriter, r *http.Request, packID PackID)
	// Fetch profile details of the personal account
	// (GET /profile/self)
	ShowProfile(w http.ResponseWriter, r *http.Request)
	// Update your own profile information
	// (PUT /profile/self)
	UpdateProfile(w http.ResponseWriter, r *http.Request)
	// Retrieve an unlimited auth token
	// (GET /profile/token)
	TokenProfile(w http.ResponseWriter, r *http.Request)
	// Fetch the available Quilt versions
	// (GET /quilt)
	ListQuilts(w http.ResponseWriter, r *http.Request, params ListQuiltsParams)
	// Update the available Quilt versions
	// (PUT /quilt)
	UpdateQuilt(w http.ResponseWriter, r *http.Request)
	// Unlink a build from a Quilt version
	// (DELETE /quilt/{quilt_id}/builds)
	DeleteQuiltFromBuild(w http.ResponseWriter, r *http.Request, quiltID QuiltID)
	// Fetch the builds attached to a Quilt version
	// (GET /quilt/{quilt_id}/builds)
	ListQuiltBuilds(w http.ResponseWriter, r *http.Request, quiltID QuiltID, params ListQuiltBuildsParams)
	// Attach a build to a Quilt version
	// (POST /quilt/{quilt_id}/builds)
	AttachQuiltToBuild(w http.ResponseWriter, r *http.Request, quiltID QuiltID)
	// Fetch all available users
	// (GET /users)
	ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams)
	// Create a new user
	// (POST /users)
	CreateUser(w http.ResponseWriter, r *http.Request)
	// Delete a specific user
	// (DELETE /users/{user_id})
	DeleteUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch a specific user
	// (GET /users/{user_id})
	ShowUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update a specific user
	// (PUT /users/{user_id})
	UpdateUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Unlink a group from user
	// (DELETE /users/{user_id}/groups)
	DeleteUserFromGroup(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch all groups attached to user
	// (GET /users/{user_id}/groups)
	ListUserGroups(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserGroupsParams)
	// Attach a group to user
	// (POST /users/{user_id}/groups)
	AttachUserToGroup(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update group perms for user
	// (PUT /users/{user_id}/groups)
	PermitUserGroup(w http.ResponseWriter, r *http.Request, userID UserID)
	// Unlink a mod from user
	// (DELETE /users/{user_id}/mods)
	DeleteUserFromMod(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch all mods attached to user
	// (GET /users/{user_id}/mods)
	ListUserMods(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserModsParams)
	// Attach a mod to user
	// (POST /users/{user_id}/mods)
	AttachUserToMod(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update mod perms for user
	// (PUT /users/{user_id}/mods)
	PermitUserMod(w http.ResponseWriter, r *http.Request, userID UserID)
	// Unlink a pack from user
	// (DELETE /users/{user_id}/packs)
	DeleteUserFromPack(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch all packs attached to user
	// (GET /users/{user_id}/packs)
	ListUserPacks(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserPacksParams)
	// Attach a pack to user
	// (POST /users/{user_id}/packs)
	AttachUserToPack(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update pack perms for user
	// (PUT /users/{user_id}/packs)
	PermitUserPack(w http.ResponseWriter, r *http.Request, userID UserID)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Authenticate an user by credentials
// (POST /auth/login)
func (_ Unimplemented) LoginAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available auth providers
// (GET /auth/providers)
func (_ Unimplemented) ListProviders(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve real token after redirect
// (POST /auth/redirect)
func (_ Unimplemented) RedirectAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Refresh an auth token before it expires
// (GET /auth/refresh)
func (_ Unimplemented) RefreshAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Verify validity for an authentication token
// (GET /auth/verify)
func (_ Unimplemented) VerifyAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Callback to parse the defined provider
// (GET /auth/{provider}/callback)
func (_ Unimplemented) CallbackProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam, params CallbackProviderParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Request the redirect to defined provider
// (GET /auth/{provider}/request)
func (_ Unimplemented) RequestProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available Fabric versions
// (GET /fabric)
func (_ Unimplemented) ListFabrics(w http.ResponseWriter, r *http.Request, params ListFabricsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update the available Fabric versions
// (PUT /fabric)
func (_ Unimplemented) UpdateFabric(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a Fabric version
// (DELETE /fabric/{fabric_id}/builds)
func (_ Unimplemented) DeleteFabricFromBuild(w http.ResponseWriter, r *http.Request, fabricID FabricID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the builds attached to a Fabric version
// (GET /fabric/{fabric_id}/builds)
func (_ Unimplemented) ListFabricBuilds(w http.ResponseWriter, r *http.Request, fabricID FabricID, params ListFabricBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a Fabric version
// (POST /fabric/{fabric_id}/builds)
func (_ Unimplemented) AttachFabricToBuild(w http.ResponseWriter, r *http.Request, fabricID FabricID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available Forge versions
// (GET /forge)
func (_ Unimplemented) ListForges(w http.ResponseWriter, r *http.Request, params ListForgesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update the available Forge versions
// (PUT /forge)
func (_ Unimplemented) UpdateForge(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a Forge version
// (DELETE /forge/{forge_id}/builds)
func (_ Unimplemented) DeleteForgeFromBuild(w http.ResponseWriter, r *http.Request, forgeID ForgeID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the builds attached to a Forge version
// (GET /forge/{forge_id}/builds)
func (_ Unimplemented) ListForgeBuilds(w http.ResponseWriter, r *http.Request, forgeID ForgeID, params ListForgeBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a Forge version
// (POST /forge/{forge_id}/builds)
func (_ Unimplemented) AttachForgeToBuild(w http.ResponseWriter, r *http.Request, forgeID ForgeID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available groups
// (GET /groups)
func (_ Unimplemented) ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new group
// (POST /groups)
func (_ Unimplemented) CreateGroup(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific group
// (DELETE /groups/{group_id})
func (_ Unimplemented) DeleteGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific group
// (GET /groups/{group_id})
func (_ Unimplemented) ShowGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific group
// (PUT /groups/{group_id})
func (_ Unimplemented) UpdateGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a mod from group
// (DELETE /groups/{group_id}/mods)
func (_ Unimplemented) DeleteGroupFromMod(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all mods attached to group
// (GET /groups/{group_id}/mods)
func (_ Unimplemented) ListGroupMods(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupModsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a mod to group
// (POST /groups/{group_id}/mods)
func (_ Unimplemented) AttachGroupToMod(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update mod perms for group
// (PUT /groups/{group_id}/mods)
func (_ Unimplemented) PermitGroupMod(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a pack from group
// (DELETE /groups/{group_id}/packs)
func (_ Unimplemented) DeleteGroupFromPack(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all packs attached to group
// (GET /groups/{group_id}/packs)
func (_ Unimplemented) ListGroupPacks(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupPacksParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a pack to group
// (POST /groups/{group_id}/packs)
func (_ Unimplemented) AttachGroupToPack(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update pack perms for group
// (PUT /groups/{group_id}/packs)
func (_ Unimplemented) PermitGroupPack(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a user from group
// (DELETE /groups/{group_id}/users)
func (_ Unimplemented) DeleteGroupFromUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all users attached to group
// (GET /groups/{group_id}/users)
func (_ Unimplemented) ListGroupUsers(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a user to group
// (POST /groups/{group_id}/users)
func (_ Unimplemented) AttachGroupToUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update user perms for group
// (PUT /groups/{group_id}/users)
func (_ Unimplemented) PermitGroupUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available Minecraft versions
// (GET /minecraft)
func (_ Unimplemented) ListMinecrafts(w http.ResponseWriter, r *http.Request, params ListMinecraftsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update the available Minecraft versions
// (PUT /minecraft)
func (_ Unimplemented) UpdateMinecraft(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a Minecraft version
// (DELETE /minecraft/{minecraft_id}/builds)
func (_ Unimplemented) DeleteMinecraftFromBuild(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the builds attached to a Minecraft version
// (GET /minecraft/{minecraft_id}/builds)
func (_ Unimplemented) ListMinecraftBuilds(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID, params ListMinecraftBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a Minecraft version
// (POST /minecraft/{minecraft_id}/builds)
func (_ Unimplemented) AttachMinecraftToBuild(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available mods
// (GET /mods)
func (_ Unimplemented) ListMods(w http.ResponseWriter, r *http.Request, params ListModsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new mod
// (POST /mods)
func (_ Unimplemented) CreateMod(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific mod
// (DELETE /mods/{mod_id})
func (_ Unimplemented) DeleteMod(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific mod
// (GET /mods/{mod_id})
func (_ Unimplemented) ShowMod(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific mod
// (PUT /mods/{mod_id})
func (_ Unimplemented) UpdateMod(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete the avatar for the defined mod
// (DELETE /mods/{mod_id}/avatar)
func (_ Unimplemented) DeleteModAvatar(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upload an avatar for the defined mod
// (POST /mods/{mod_id}/avatar)
func (_ Unimplemented) CreateModAvatar(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a group from mod
// (DELETE /mods/{mod_id}/groups)
func (_ Unimplemented) DeleteModFromGroup(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all groups attached to mod
// (GET /mods/{mod_id}/groups)
func (_ Unimplemented) ListModGroups(w http.ResponseWriter, r *http.Request, modID ModID, params ListModGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a group to mod
// (POST /mods/{mod_id}/groups)
func (_ Unimplemented) AttachModToGroup(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update group perms for mod
// (PUT /mods/{mod_id}/groups)
func (_ Unimplemented) PermitModGroup(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a user from mod
// (DELETE /mods/{mod_id}/users)
func (_ Unimplemented) DeleteModFromUser(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all users attached to mod
// (GET /mods/{mod_id}/users)
func (_ Unimplemented) ListModUsers(w http.ResponseWriter, r *http.Request, modID ModID, params ListModUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a user to mod
// (POST /mods/{mod_id}/users)
func (_ Unimplemented) AttachModToUser(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update user perms for mod
// (PUT /mods/{mod_id}/users)
func (_ Unimplemented) PermitModUser(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available versions for a mod
// (GET /mods/{mod_id}/versions)
func (_ Unimplemented) ListVersions(w http.ResponseWriter, r *http.Request, modID ModID, params ListVersionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new version for a mod
// (POST /mods/{mod_id}/versions)
func (_ Unimplemented) CreateVersion(w http.ResponseWriter, r *http.Request, modID ModID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific version for a mod
// (DELETE /mods/{mod_id}/versions/{version_id})
func (_ Unimplemented) DeleteVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific version for a mod
// (GET /mods/{mod_id}/versions/{version_id})
func (_ Unimplemented) ShowVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific version for a mod
// (PUT /mods/{mod_id}/versions/{version_id})
func (_ Unimplemented) UpdateVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a version
// (DELETE /mods/{mod_id}/versions/{version_id}/builds)
func (_ Unimplemented) DeleteVersionFromBuild(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all builds attached to version
// (GET /mods/{mod_id}/versions/{version_id}/builds)
func (_ Unimplemented) ListVersionBuilds(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID, params ListVersionBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a version
// (POST /mods/{mod_id}/versions/{version_id}/builds)
func (_ Unimplemented) AttachVersionToBuild(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available Neoforge versions
// (GET /neoforge)
func (_ Unimplemented) ListNeoforges(w http.ResponseWriter, r *http.Request, params ListNeoforgesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update the available Neoforge versions
// (PUT /neoforge)
func (_ Unimplemented) UpdateNeoforge(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a Neoforge version
// (DELETE /neoforge/{neoforge_id}/builds)
func (_ Unimplemented) DeleteNeoforgeFromBuild(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the builds attached to a Neoforge version
// (GET /neoforge/{neoforge_id}/builds)
func (_ Unimplemented) ListNeoforgeBuilds(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID, params ListNeoforgeBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a Neoforge version
// (POST /neoforge/{neoforge_id}/builds)
func (_ Unimplemented) AttachNeoforgeToBuild(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available packs
// (GET /packs)
func (_ Unimplemented) ListPacks(w http.ResponseWriter, r *http.Request, params ListPacksParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new pack
// (POST /packs)
func (_ Unimplemented) CreatePack(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific pack
// (DELETE /packs/{pack_id})
func (_ Unimplemented) DeletePack(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific pack
// (GET /packs/{pack_id})
func (_ Unimplemented) ShowPack(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific pack
// (PUT /packs/{pack_id})
func (_ Unimplemented) UpdatePack(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete the avatar for the defined pack
// (DELETE /packs/{pack_id}/avatar)
func (_ Unimplemented) DeletePackAvatar(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upload an avatar for the defined pack
// (POST /packs/{pack_id}/avatar)
func (_ Unimplemented) CreatePackAvatar(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available builds for a pack
// (GET /packs/{pack_id}/builds)
func (_ Unimplemented) ListBuilds(w http.ResponseWriter, r *http.Request, packID PackID, params ListBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new build for a pack
// (POST /packs/{pack_id}/builds)
func (_ Unimplemented) CreateBuild(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific build for a pack
// (DELETE /packs/{pack_id}/builds/{build_id})
func (_ Unimplemented) DeleteBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific build for a pack
// (GET /packs/{pack_id}/builds/{build_id})
func (_ Unimplemented) ShowBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific build for a pack
// (PUT /packs/{pack_id}/builds/{build_id})
func (_ Unimplemented) UpdateBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a version from a build
// (DELETE /packs/{pack_id}/builds/{build_id}/versions)
func (_ Unimplemented) DeleteBuildFromVersion(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all versions attached to build
// (GET /packs/{pack_id}/builds/{build_id}/versions)
func (_ Unimplemented) ListBuildVersions(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID, params ListBuildVersionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a version to a build
// (POST /packs/{pack_id}/builds/{build_id}/versions)
func (_ Unimplemented) AttachBuildToVersion(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a group from pack
// (DELETE /packs/{pack_id}/groups)
func (_ Unimplemented) DeletePackFromGroup(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all groups attached to pack
// (GET /packs/{pack_id}/groups)
func (_ Unimplemented) ListPackGroups(w http.ResponseWriter, r *http.Request, packID PackID, params ListPackGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a group to pack
// (POST /packs/{pack_id}/groups)
func (_ Unimplemented) AttachPackToGroup(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update group perms for pack
// (PUT /packs/{pack_id}/groups)
func (_ Unimplemented) PermitPackGroup(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a user from pack
// (DELETE /packs/{pack_id}/users)
func (_ Unimplemented) DeletePackFromUser(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all users attached to pack
// (GET /packs/{pack_id}/users)
func (_ Unimplemented) ListPackUsers(w http.ResponseWriter, r *http.Request, packID PackID, params ListPackUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a user to pack
// (POST /packs/{pack_id}/users)
func (_ Unimplemented) AttachPackToUser(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update user perms for pack
// (PUT /packs/{pack_id}/users)
func (_ Unimplemented) PermitPackUser(w http.ResponseWriter, r *http.Request, packID PackID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch profile details of the personal account
// (GET /profile/self)
func (_ Unimplemented) ShowProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update your own profile information
// (PUT /profile/self)
func (_ Unimplemented) UpdateProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve an unlimited auth token
// (GET /profile/token)
func (_ Unimplemented) TokenProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available Quilt versions
// (GET /quilt)
func (_ Unimplemented) ListQuilts(w http.ResponseWriter, r *http.Request, params ListQuiltsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update the available Quilt versions
// (PUT /quilt)
func (_ Unimplemented) UpdateQuilt(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a build from a Quilt version
// (DELETE /quilt/{quilt_id}/builds)
func (_ Unimplemented) DeleteQuiltFromBuild(w http.ResponseWriter, r *http.Request, quiltID QuiltID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the builds attached to a Quilt version
// (GET /quilt/{quilt_id}/builds)
func (_ Unimplemented) ListQuiltBuilds(w http.ResponseWriter, r *http.Request, quiltID QuiltID, params ListQuiltBuildsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a build to a Quilt version
// (POST /quilt/{quilt_id}/builds)
func (_ Unimplemented) AttachQuiltToBuild(w http.ResponseWriter, r *http.Request, quiltID QuiltID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available users
// (GET /users)
func (_ Unimplemented) ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new user
// (POST /users)
func (_ Unimplemented) CreateUser(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific user
// (DELETE /users/{user_id})
func (_ Unimplemented) DeleteUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific user
// (GET /users/{user_id})
func (_ Unimplemented) ShowUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific user
// (PUT /users/{user_id})
func (_ Unimplemented) UpdateUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a group from user
// (DELETE /users/{user_id}/groups)
func (_ Unimplemented) DeleteUserFromGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all groups attached to user
// (GET /users/{user_id}/groups)
func (_ Unimplemented) ListUserGroups(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a group to user
// (POST /users/{user_id}/groups)
func (_ Unimplemented) AttachUserToGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update group perms for user
// (PUT /users/{user_id}/groups)
func (_ Unimplemented) PermitUserGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a mod from user
// (DELETE /users/{user_id}/mods)
func (_ Unimplemented) DeleteUserFromMod(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all mods attached to user
// (GET /users/{user_id}/mods)
func (_ Unimplemented) ListUserMods(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserModsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a mod to user
// (POST /users/{user_id}/mods)
func (_ Unimplemented) AttachUserToMod(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update mod perms for user
// (PUT /users/{user_id}/mods)
func (_ Unimplemented) PermitUserMod(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a pack from user
// (DELETE /users/{user_id}/packs)
func (_ Unimplemented) DeleteUserFromPack(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all packs attached to user
// (GET /users/{user_id}/packs)
func (_ Unimplemented) ListUserPacks(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserPacksParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a pack to user
// (POST /users/{user_id}/packs)
func (_ Unimplemented) AttachUserToPack(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update pack perms for user
// (PUT /users/{user_id}/packs)
func (_ Unimplemented) PermitUserPack(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// LoginAuth operation middleware
func (siw *ServerInterfaceWrapper) LoginAuth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LoginAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProviders operation middleware
func (siw *ServerInterfaceWrapper) ListProviders(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviders(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RedirectAuth operation middleware
func (siw *ServerInterfaceWrapper) RedirectAuth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RedirectAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RefreshAuth operation middleware
func (siw *ServerInterfaceWrapper) RefreshAuth(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RefreshAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// VerifyAuth operation middleware
func (siw *ServerInterfaceWrapper) VerifyAuth(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VerifyAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CallbackProvider operation middleware
func (siw *ServerInterfaceWrapper) CallbackProvider(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "provider" -------------
	var provider AuthProviderParam

	err = runtime.BindStyledParameterWithOptions("simple", "provider", chi.URLParam(r, "provider"), &provider, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provider", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CallbackProviderParams

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", r.URL.Query(), &params.Code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CallbackProvider(w, r, provider, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RequestProvider operation middleware
func (siw *ServerInterfaceWrapper) RequestProvider(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "provider" -------------
	var provider AuthProviderParam

	err = runtime.BindStyledParameterWithOptions("simple", "provider", chi.URLParam(r, "provider"), &provider, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provider", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RequestProvider(w, r, provider)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListFabrics operation middleware
func (siw *ServerInterfaceWrapper) ListFabrics(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFabricsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFabrics(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateFabric operation middleware
func (siw *ServerInterfaceWrapper) UpdateFabric(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateFabric(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteFabricFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteFabricFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "fabric_id" -------------
	var fabricID FabricID

	err = runtime.BindStyledParameterWithOptions("simple", "fabric_id", chi.URLParam(r, "fabric_id"), &fabricID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fabric_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFabricFromBuild(w, r, fabricID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListFabricBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListFabricBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "fabric_id" -------------
	var fabricID FabricID

	err = runtime.BindStyledParameterWithOptions("simple", "fabric_id", chi.URLParam(r, "fabric_id"), &fabricID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fabric_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFabricBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFabricBuilds(w, r, fabricID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachFabricToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachFabricToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "fabric_id" -------------
	var fabricID FabricID

	err = runtime.BindStyledParameterWithOptions("simple", "fabric_id", chi.URLParam(r, "fabric_id"), &fabricID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fabric_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachFabricToBuild(w, r, fabricID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListForges operation middleware
func (siw *ServerInterfaceWrapper) ListForges(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListForgesParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListForges(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateForge operation middleware
func (siw *ServerInterfaceWrapper) UpdateForge(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateForge(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteForgeFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteForgeFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "forge_id" -------------
	var forgeID ForgeID

	err = runtime.BindStyledParameterWithOptions("simple", "forge_id", chi.URLParam(r, "forge_id"), &forgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "forge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteForgeFromBuild(w, r, forgeID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListForgeBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListForgeBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "forge_id" -------------
	var forgeID ForgeID

	err = runtime.BindStyledParameterWithOptions("simple", "forge_id", chi.URLParam(r, "forge_id"), &forgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "forge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListForgeBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListForgeBuilds(w, r, forgeID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachForgeToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachForgeToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "forge_id" -------------
	var forgeID ForgeID

	err = runtime.BindStyledParameterWithOptions("simple", "forge_id", chi.URLParam(r, "forge_id"), &forgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "forge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachForgeToBuild(w, r, forgeID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroups operation middleware
func (siw *ServerInterfaceWrapper) ListGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroups(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowGroup operation middleware
func (siw *ServerInterfaceWrapper) ShowGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateGroup operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroupFromMod operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupFromMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupFromMod(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroupMods operation middleware
func (siw *ServerInterfaceWrapper) ListGroupMods(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupModsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupMods(w, r, groupID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachGroupToMod operation middleware
func (siw *ServerInterfaceWrapper) AttachGroupToMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachGroupToMod(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitGroupMod operation middleware
func (siw *ServerInterfaceWrapper) PermitGroupMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitGroupMod(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroupFromPack operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupFromPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupFromPack(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroupPacks operation middleware
func (siw *ServerInterfaceWrapper) ListGroupPacks(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupPacksParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupPacks(w, r, groupID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachGroupToPack operation middleware
func (siw *ServerInterfaceWrapper) AttachGroupToPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachGroupToPack(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitGroupPack operation middleware
func (siw *ServerInterfaceWrapper) PermitGroupPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitGroupPack(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroupFromUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupFromUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupFromUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroupUsers operation middleware
func (siw *ServerInterfaceWrapper) ListGroupUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupUsers(w, r, groupID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachGroupToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachGroupToUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachGroupToUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitGroupUser operation middleware
func (siw *ServerInterfaceWrapper) PermitGroupUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitGroupUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListMinecrafts operation middleware
func (siw *ServerInterfaceWrapper) ListMinecrafts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMinecraftsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListMinecrafts(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateMinecraft operation middleware
func (siw *ServerInterfaceWrapper) UpdateMinecraft(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateMinecraft(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteMinecraftFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteMinecraftFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "minecraft_id" -------------
	var minecraftID MinecraftID

	err = runtime.BindStyledParameterWithOptions("simple", "minecraft_id", chi.URLParam(r, "minecraft_id"), &minecraftID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "minecraft_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteMinecraftFromBuild(w, r, minecraftID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListMinecraftBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListMinecraftBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "minecraft_id" -------------
	var minecraftID MinecraftID

	err = runtime.BindStyledParameterWithOptions("simple", "minecraft_id", chi.URLParam(r, "minecraft_id"), &minecraftID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "minecraft_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMinecraftBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListMinecraftBuilds(w, r, minecraftID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachMinecraftToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachMinecraftToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "minecraft_id" -------------
	var minecraftID MinecraftID

	err = runtime.BindStyledParameterWithOptions("simple", "minecraft_id", chi.URLParam(r, "minecraft_id"), &minecraftID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "minecraft_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachMinecraftToBuild(w, r, minecraftID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListMods operation middleware
func (siw *ServerInterfaceWrapper) ListMods(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListModsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListMods(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateMod operation middleware
func (siw *ServerInterfaceWrapper) CreateMod(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateMod(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteMod operation middleware
func (siw *ServerInterfaceWrapper) DeleteMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteMod(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowMod operation middleware
func (siw *ServerInterfaceWrapper) ShowMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowMod(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateMod operation middleware
func (siw *ServerInterfaceWrapper) UpdateMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateMod(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteModAvatar operation middleware
func (siw *ServerInterfaceWrapper) DeleteModAvatar(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteModAvatar(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateModAvatar operation middleware
func (siw *ServerInterfaceWrapper) CreateModAvatar(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateModAvatar(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteModFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteModFromGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteModFromGroup(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModGroups operation middleware
func (siw *ServerInterfaceWrapper) ListModGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListModGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModGroups(w, r, modID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachModToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachModToGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachModToGroup(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitModGroup operation middleware
func (siw *ServerInterfaceWrapper) PermitModGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitModGroup(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteModFromUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteModFromUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteModFromUser(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModUsers operation middleware
func (siw *ServerInterfaceWrapper) ListModUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListModUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModUsers(w, r, modID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachModToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachModToUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachModToUser(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitModUser operation middleware
func (siw *ServerInterfaceWrapper) PermitModUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitModUser(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListVersions operation middleware
func (siw *ServerInterfaceWrapper) ListVersions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListVersionsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListVersions(w, r, modID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateVersion operation middleware
func (siw *ServerInterfaceWrapper) CreateVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateVersion(w, r, modID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteVersion operation middleware
func (siw *ServerInterfaceWrapper) DeleteVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteVersion(w, r, modID, versionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowVersion operation middleware
func (siw *ServerInterfaceWrapper) ShowVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowVersion(w, r, modID, versionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateVersion operation middleware
func (siw *ServerInterfaceWrapper) UpdateVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateVersion(w, r, modID, versionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteVersionFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteVersionFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteVersionFromBuild(w, r, modID, versionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListVersionBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListVersionBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListVersionBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListVersionBuilds(w, r, modID, versionID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachVersionToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachVersionToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "mod_id" -------------
	var modID ModID

	err = runtime.BindStyledParameterWithOptions("simple", "mod_id", chi.URLParam(r, "mod_id"), &modID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mod_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionID VersionID

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", chi.URLParam(r, "version_id"), &versionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachVersionToBuild(w, r, modID, versionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListNeoforges operation middleware
func (siw *ServerInterfaceWrapper) ListNeoforges(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNeoforgesParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNeoforges(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateNeoforge operation middleware
func (siw *ServerInterfaceWrapper) UpdateNeoforge(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateNeoforge(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteNeoforgeFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteNeoforgeFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "neoforge_id" -------------
	var neoforgeID NeoforgeID

	err = runtime.BindStyledParameterWithOptions("simple", "neoforge_id", chi.URLParam(r, "neoforge_id"), &neoforgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "neoforge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteNeoforgeFromBuild(w, r, neoforgeID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListNeoforgeBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListNeoforgeBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "neoforge_id" -------------
	var neoforgeID NeoforgeID

	err = runtime.BindStyledParameterWithOptions("simple", "neoforge_id", chi.URLParam(r, "neoforge_id"), &neoforgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "neoforge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNeoforgeBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNeoforgeBuilds(w, r, neoforgeID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachNeoforgeToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachNeoforgeToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "neoforge_id" -------------
	var neoforgeID NeoforgeID

	err = runtime.BindStyledParameterWithOptions("simple", "neoforge_id", chi.URLParam(r, "neoforge_id"), &neoforgeID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "neoforge_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachNeoforgeToBuild(w, r, neoforgeID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListPacks operation middleware
func (siw *ServerInterfaceWrapper) ListPacks(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPacksParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPacks(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePack operation middleware
func (siw *ServerInterfaceWrapper) CreatePack(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePack(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePack operation middleware
func (siw *ServerInterfaceWrapper) DeletePack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePack(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowPack operation middleware
func (siw *ServerInterfaceWrapper) ShowPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowPack(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdatePack operation middleware
func (siw *ServerInterfaceWrapper) UpdatePack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePack(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePackAvatar operation middleware
func (siw *ServerInterfaceWrapper) DeletePackAvatar(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePackAvatar(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePackAvatar operation middleware
func (siw *ServerInterfaceWrapper) CreatePackAvatar(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePackAvatar(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBuilds(w, r, packID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateBuild operation middleware
func (siw *ServerInterfaceWrapper) CreateBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBuild(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBuild(w, r, packID, buildID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowBuild operation middleware
func (siw *ServerInterfaceWrapper) ShowBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowBuild(w, r, packID, buildID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateBuild operation middleware
func (siw *ServerInterfaceWrapper) UpdateBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateBuild(w, r, packID, buildID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteBuildFromVersion operation middleware
func (siw *ServerInterfaceWrapper) DeleteBuildFromVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBuildFromVersion(w, r, packID, buildID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListBuildVersions operation middleware
func (siw *ServerInterfaceWrapper) ListBuildVersions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBuildVersionsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBuildVersions(w, r, packID, buildID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachBuildToVersion operation middleware
func (siw *ServerInterfaceWrapper) AttachBuildToVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	// ------------- Path parameter "build_id" -------------
	var buildID BuildID

	err = runtime.BindStyledParameterWithOptions("simple", "build_id", chi.URLParam(r, "build_id"), &buildID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "build_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachBuildToVersion(w, r, packID, buildID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePackFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DeletePackFromGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePackFromGroup(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListPackGroups operation middleware
func (siw *ServerInterfaceWrapper) ListPackGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPackGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPackGroups(w, r, packID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachPackToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachPackToGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPackToGroup(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitPackGroup operation middleware
func (siw *ServerInterfaceWrapper) PermitPackGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitPackGroup(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePackFromUser operation middleware
func (siw *ServerInterfaceWrapper) DeletePackFromUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePackFromUser(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListPackUsers operation middleware
func (siw *ServerInterfaceWrapper) ListPackUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPackUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPackUsers(w, r, packID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachPackToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachPackToUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPackToUser(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitPackUser operation middleware
func (siw *ServerInterfaceWrapper) PermitPackUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "pack_id" -------------
	var packID PackID

	err = runtime.BindStyledParameterWithOptions("simple", "pack_id", chi.URLParam(r, "pack_id"), &packID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pack_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitPackUser(w, r, packID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProfile operation middleware
func (siw *ServerInterfaceWrapper) ShowProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProfile operation middleware
func (siw *ServerInterfaceWrapper) UpdateProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenProfile operation middleware
func (siw *ServerInterfaceWrapper) TokenProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListQuilts operation middleware
func (siw *ServerInterfaceWrapper) ListQuilts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListQuiltsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListQuilts(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateQuilt operation middleware
func (siw *ServerInterfaceWrapper) UpdateQuilt(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateQuilt(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteQuiltFromBuild operation middleware
func (siw *ServerInterfaceWrapper) DeleteQuiltFromBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "quilt_id" -------------
	var quiltID QuiltID

	err = runtime.BindStyledParameterWithOptions("simple", "quilt_id", chi.URLParam(r, "quilt_id"), &quiltID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "quilt_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteQuiltFromBuild(w, r, quiltID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListQuiltBuilds operation middleware
func (siw *ServerInterfaceWrapper) ListQuiltBuilds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "quilt_id" -------------
	var quiltID QuiltID

	err = runtime.BindStyledParameterWithOptions("simple", "quilt_id", chi.URLParam(r, "quilt_id"), &quiltID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "quilt_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListQuiltBuildsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListQuiltBuilds(w, r, quiltID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachQuiltToBuild operation middleware
func (siw *ServerInterfaceWrapper) AttachQuiltToBuild(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "quilt_id" -------------
	var quiltID QuiltID

	err = runtime.BindStyledParameterWithOptions("simple", "quilt_id", chi.URLParam(r, "quilt_id"), &quiltID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "quilt_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachQuiltToBuild(w, r, quiltID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUsers operation middleware
func (siw *ServerInterfaceWrapper) ListUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUsers(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowUser operation middleware
func (siw *ServerInterfaceWrapper) ShowUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserFromGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserFromGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUserGroups operation middleware
func (siw *ServerInterfaceWrapper) ListUserGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserGroups(w, r, userID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachUserToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachUserToGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachUserToGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitUserGroup operation middleware
func (siw *ServerInterfaceWrapper) PermitUserGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitUserGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserFromMod operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserFromMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserFromMod(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUserMods operation middleware
func (siw *ServerInterfaceWrapper) ListUserMods(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserModsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserMods(w, r, userID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachUserToMod operation middleware
func (siw *ServerInterfaceWrapper) AttachUserToMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachUserToMod(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitUserMod operation middleware
func (siw *ServerInterfaceWrapper) PermitUserMod(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitUserMod(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserFromPack operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserFromPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserFromPack(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUserPacks operation middleware
func (siw *ServerInterfaceWrapper) ListUserPacks(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserPacksParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserPacks(w, r, userID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachUserToPack operation middleware
func (siw *ServerInterfaceWrapper) AttachUserToPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachUserToPack(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitUserPack operation middleware
func (siw *ServerInterfaceWrapper) PermitUserPack(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitUserPack(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/login", wrapper.LoginAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/providers", wrapper.ListProviders)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/redirect", wrapper.RedirectAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/refresh", wrapper.RefreshAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/verify", wrapper.VerifyAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/{provider}/callback", wrapper.CallbackProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/{provider}/request", wrapper.RequestProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/fabric", wrapper.ListFabrics)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/fabric", wrapper.UpdateFabric)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/fabric/{fabric_id}/builds", wrapper.DeleteFabricFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/fabric/{fabric_id}/builds", wrapper.ListFabricBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/fabric/{fabric_id}/builds", wrapper.AttachFabricToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/forge", wrapper.ListForges)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/forge", wrapper.UpdateForge)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/forge/{forge_id}/builds", wrapper.DeleteForgeFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/forge/{forge_id}/builds", wrapper.ListForgeBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/forge/{forge_id}/builds", wrapper.AttachForgeToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups", wrapper.ListGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}", wrapper.DeleteGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}", wrapper.ShowGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}", wrapper.UpdateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}/mods", wrapper.DeleteGroupFromMod)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}/mods", wrapper.ListGroupMods)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups/{group_id}/mods", wrapper.AttachGroupToMod)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}/mods", wrapper.PermitGroupMod)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}/packs", wrapper.DeleteGroupFromPack)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}/packs", wrapper.ListGroupPacks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups/{group_id}/packs", wrapper.AttachGroupToPack)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}/packs", wrapper.PermitGroupPack)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}/users", wrapper.DeleteGroupFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}/users", wrapper.ListGroupUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups/{group_id}/users", wrapper.AttachGroupToUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}/users", wrapper.PermitGroupUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/minecraft", wrapper.ListMinecrafts)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/minecraft", wrapper.UpdateMinecraft)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/minecraft/{minecraft_id}/builds", wrapper.DeleteMinecraftFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/minecraft/{minecraft_id}/builds", wrapper.ListMinecraftBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/minecraft/{minecraft_id}/builds", wrapper.AttachMinecraftToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods", wrapper.ListMods)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods", wrapper.CreateMod)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}", wrapper.DeleteMod)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}", wrapper.ShowMod)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/mods/{mod_id}", wrapper.UpdateMod)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}/avatar", wrapper.DeleteModAvatar)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods/{mod_id}/avatar", wrapper.CreateModAvatar)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}/groups", wrapper.DeleteModFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}/groups", wrapper.ListModGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods/{mod_id}/groups", wrapper.AttachModToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/mods/{mod_id}/groups", wrapper.PermitModGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}/users", wrapper.DeleteModFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}/users", wrapper.ListModUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods/{mod_id}/users", wrapper.AttachModToUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/mods/{mod_id}/users", wrapper.PermitModUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}/versions", wrapper.ListVersions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods/{mod_id}/versions", wrapper.CreateVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}/versions/{version_id}", wrapper.DeleteVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}/versions/{version_id}", wrapper.ShowVersion)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/mods/{mod_id}/versions/{version_id}", wrapper.UpdateVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/mods/{mod_id}/versions/{version_id}/builds", wrapper.DeleteVersionFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/mods/{mod_id}/versions/{version_id}/builds", wrapper.ListVersionBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mods/{mod_id}/versions/{version_id}/builds", wrapper.AttachVersionToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/neoforge", wrapper.ListNeoforges)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/neoforge", wrapper.UpdateNeoforge)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/neoforge/{neoforge_id}/builds", wrapper.DeleteNeoforgeFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/neoforge/{neoforge_id}/builds", wrapper.ListNeoforgeBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/neoforge/{neoforge_id}/builds", wrapper.AttachNeoforgeToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs", wrapper.ListPacks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs", wrapper.CreatePack)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}", wrapper.DeletePack)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}", wrapper.ShowPack)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/packs/{pack_id}", wrapper.UpdatePack)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}/avatar", wrapper.DeletePackAvatar)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs/{pack_id}/avatar", wrapper.CreatePackAvatar)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}/builds", wrapper.ListBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs/{pack_id}/builds", wrapper.CreateBuild)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}/builds/{build_id}", wrapper.DeleteBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}/builds/{build_id}", wrapper.ShowBuild)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/packs/{pack_id}/builds/{build_id}", wrapper.UpdateBuild)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}/builds/{build_id}/versions", wrapper.DeleteBuildFromVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}/builds/{build_id}/versions", wrapper.ListBuildVersions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs/{pack_id}/builds/{build_id}/versions", wrapper.AttachBuildToVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}/groups", wrapper.DeletePackFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}/groups", wrapper.ListPackGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs/{pack_id}/groups", wrapper.AttachPackToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/packs/{pack_id}/groups", wrapper.PermitPackGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/packs/{pack_id}/users", wrapper.DeletePackFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/packs/{pack_id}/users", wrapper.ListPackUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/packs/{pack_id}/users", wrapper.AttachPackToUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/packs/{pack_id}/users", wrapper.PermitPackUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/profile/self", wrapper.ShowProfile)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/profile/self", wrapper.UpdateProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/profile/token", wrapper.TokenProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/quilt", wrapper.ListQuilts)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/quilt", wrapper.UpdateQuilt)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/quilt/{quilt_id}/builds", wrapper.DeleteQuiltFromBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/quilt/{quilt_id}/builds", wrapper.ListQuiltBuilds)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/quilt/{quilt_id}/builds", wrapper.AttachQuiltToBuild)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users", wrapper.ListUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}", wrapper.DeleteUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}", wrapper.ShowUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}", wrapper.UpdateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}/groups", wrapper.DeleteUserFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}/groups", wrapper.ListUserGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users/{user_id}/groups", wrapper.AttachUserToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}/groups", wrapper.PermitUserGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}/mods", wrapper.DeleteUserFromMod)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}/mods", wrapper.ListUserMods)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users/{user_id}/mods", wrapper.AttachUserToMod)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}/mods", wrapper.PermitUserMod)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}/packs", wrapper.DeleteUserFromPack)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}/packs", wrapper.ListUserPacks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users/{user_id}/packs", wrapper.AttachUserToPack)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}/packs", wrapper.PermitUserPack)
	})

	return r
}

type ActionFailedErrorJSONResponse Notification

type AlreadyAttachedErrorJSONResponse Notification

type BadCredentialsErrorJSONResponse Notification

type BadRequestErrorJSONResponse Notification

type BuildResponseJSONResponse Build

type BuildVersionsResponseJSONResponse struct {
	// Build Model to represent build
	Build  *Build `json:"build,omitempty"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`

	// Pack Model to represent pack
	Pack     *Pack          `json:"pack,omitempty"`
	Total    int64          `json:"total"`
	Versions []BuildVersion `json:"versions"`
}

type BuildsResponseJSONResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack `json:"pack,omitempty"`
	Total int64 `json:"total"`
}

type FabricBuildsResponseJSONResponse struct {
	Builds []Build `json:"builds"`

	// Fabric Model to represent fabric
	Fabric *Fabric `json:"fabric,omitempty"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
	Total  int64   `json:"total"`
}

type FabricsResponseJSONResponse struct {
	Limit    int64    `json:"limit"`
	Offset   int64    `json:"offset"`
	Total    int64    `json:"total"`
	Versions []Fabric `json:"versions"`
}

type ForgeBuildsResponseJSONResponse struct {
	Builds []Build `json:"builds"`

	// Forge Model to represent forge
	Forge  *Forge `json:"forge,omitempty"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Total  int64  `json:"total"`
}

type ForgesResponseJSONResponse struct {
	Limit    int64   `json:"limit"`
	Offset   int64   `json:"offset"`
	Total    int64   `json:"total"`
	Versions []Forge `json:"versions"`
}

type GroupModsResponseJSONResponse struct {
	// Group Model to represent group
	Group  *Group     `json:"group,omitempty"`
	Limit  int64      `json:"limit"`
	Mods   []GroupMod `json:"mods"`
	Offset int64      `json:"offset"`
	Total  int64      `json:"total"`
}

type GroupPacksResponseJSONResponse struct {
	// Group Model to represent group
	Group  *Group      `json:"group,omitempty"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Packs  []GroupPack `json:"packs"`
	Total  int64       `json:"total"`
}

type GroupResponseJSONResponse Group

type GroupUsersResponseJSONResponse struct {
	// Group Model to represent group
	Group  *Group      `json:"group,omitempty"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`
	Users  []UserGroup `json:"users"`
}

type GroupsResponseJSONResponse struct {
	Groups []Group `json:"groups"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
	Total  int64   `json:"total"`
}

type InternalServerErrorJSONResponse Notification

type InvalidTokenErrorJSONResponse Notification

type LoginResponseJSONResponse AuthToken

type MinecraftBuildsResponseJSONResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`

	// Minecraft Model to represent minecraft
	Minecraft *Minecraft `json:"minecraft,omitempty"`
	Offset    int64      `json:"offset"`
	Total     int64      `json:"total"`
}

type MinecraftsResponseJSONResponse struct {
	Limit    int64       `json:"limit"`
	Offset   int64       `json:"offset"`
	Total    int64       `json:"total"`
	Versions []Minecraft `json:"versions"`
}

type ModAvatarResponseJSONResponse ModAvatar

type ModGroupsResponseJSONResponse struct {
	Groups []GroupMod `json:"groups"`
	Limit  int64      `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod  `json:"mod,omitempty"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`
}

type ModResponseJSONResponse Mod

type ModUsersResponseJSONResponse struct {
	Limit int64 `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod      `json:"mod,omitempty"`
	Offset int64     `json:"offset"`
	Total  int64     `json:"total"`
	Users  []UserMod `json:"users"`
}

type ModsResponseJSONResponse struct {
	Limit  int64 `json:"limit"`
	Mods   []Mod `json:"mods"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`
}

type NeoforgeBuildsResponseJSONResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`

	// Neoforge Model to represent neoforge
	Neoforge *Neoforge `json:"neoforge,omitempty"`
	Offset   int64     `json:"offset"`
	Total    int64     `json:"total"`
}

type NeoforgesResponseJSONResponse struct {
	Limit    int64      `json:"limit"`
	Offset   int64      `json:"offset"`
	Total    int64      `json:"total"`
	Versions []Neoforge `json:"versions"`
}

type NotAttachedErrorJSONResponse Notification

type NotAuthorizedErrorJSONResponse Notification

type NotFoundErrorJSONResponse Notification

type PackAvatarResponseJSONResponse PackAvatar

type PackGroupsResponseJSONResponse struct {
	Groups []GroupPack `json:"groups"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack `json:"pack,omitempty"`
	Total int64 `json:"total"`
}

type PackResponseJSONResponse Pack

type PackUsersResponseJSONResponse struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack      `json:"pack,omitempty"`
	Total int64      `json:"total"`
	Users []UserPack `json:"users"`
}

type PacksResponseJSONResponse struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Packs  []Pack `json:"packs"`
	Total  int64  `json:"total"`
}

type ProfileResponseJSONResponse Profile

type ProvidersResponseJSONResponse struct {
	Providers []Provider `json:"providers"`
	Total     int64      `json:"total"`
}

type QuiltBuildsResponseJSONResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`

	// Quilt Model to represent quilt
	Quilt *Quilt `json:"quilt,omitempty"`
	Total int64  `json:"total"`
}

type QuiltsResponseJSONResponse struct {
	Limit    int64   `json:"limit"`
	Offset   int64   `json:"offset"`
	Total    int64   `json:"total"`
	Versions []Quilt `json:"versions"`
}

type RefreshResponseJSONResponse AuthToken

type RemoteUnavailableErrorJSONResponse Notification

type SuccessMessageJSONResponse Notification

type TokenResponseJSONResponse AuthToken

type UserGroupsResponseJSONResponse struct {
	Groups []UserGroup `json:"groups"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

type UserModsResponseJSONResponse struct {
	Limit  int64     `json:"limit"`
	Mods   []UserMod `json:"mods"`
	Offset int64     `json:"offset"`
	Total  int64     `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

type UserPacksResponseJSONResponse struct {
	Limit  int64      `json:"limit"`
	Offset int64      `json:"offset"`
	Packs  []UserPack `json:"packs"`
	Total  int64      `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

type UserResponseJSONResponse User

type UsersResponseJSONResponse struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Total  int64  `json:"total"`
	Users  []User `json:"users"`
}

type ValidationErrorJSONResponse Notification

type VerifyResponseJSONResponse AuthVerify

type VersionBuildsResponseJSONResponse struct {
	Builds []BuildVersion `json:"builds"`
	Limit  int64          `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod  `json:"mod,omitempty"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`

	// Version Model to represent version
	Version *Version `json:"version,omitempty"`
}

type VersionResponseJSONResponse Version

type VersionsResponseJSONResponse struct {
	Limit int64 `json:"limit"`

	// Mod Model to represent mod
	Mod      *Mod      `json:"mod,omitempty"`
	Offset   int64     `json:"offset"`
	Total    int64     `json:"total"`
	Versions []Version `json:"versions"`
}

type LoginAuthRequestObject struct {
	Body *LoginAuthJSONRequestBody
}

type LoginAuthResponseObject interface {
	VisitLoginAuthResponse(w http.ResponseWriter) error
}

type LoginAuth200JSONResponse struct{ LoginResponseJSONResponse }

func (response LoginAuth200JSONResponse) VisitLoginAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type LoginAuth400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response LoginAuth400JSONResponse) VisitLoginAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type LoginAuth401JSONResponse struct {
	BadCredentialsErrorJSONResponse
}

func (response LoginAuth401JSONResponse) VisitLoginAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type LoginAuth500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response LoginAuth500JSONResponse) VisitLoginAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListProvidersRequestObject struct {
}

type ListProvidersResponseObject interface {
	VisitListProvidersResponse(w http.ResponseWriter) error
}

type ListProviders200JSONResponse struct{ ProvidersResponseJSONResponse }

func (response ListProviders200JSONResponse) VisitListProvidersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RedirectAuthRequestObject struct {
	Body *RedirectAuthJSONRequestBody
}

type RedirectAuthResponseObject interface {
	VisitRedirectAuthResponse(w http.ResponseWriter) error
}

type RedirectAuth200JSONResponse struct{ TokenResponseJSONResponse }

func (response RedirectAuth200JSONResponse) VisitRedirectAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RedirectAuth400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response RedirectAuth400JSONResponse) VisitRedirectAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RedirectAuth401JSONResponse struct{ InvalidTokenErrorJSONResponse }

func (response RedirectAuth401JSONResponse) VisitRedirectAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type RedirectAuth500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response RedirectAuth500JSONResponse) VisitRedirectAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RefreshAuthRequestObject struct {
}

type RefreshAuthResponseObject interface {
	VisitRefreshAuthResponse(w http.ResponseWriter) error
}

type RefreshAuth200JSONResponse struct{ RefreshResponseJSONResponse }

func (response RefreshAuth200JSONResponse) VisitRefreshAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RefreshAuth401JSONResponse struct{ InvalidTokenErrorJSONResponse }

func (response RefreshAuth401JSONResponse) VisitRefreshAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type RefreshAuth500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response RefreshAuth500JSONResponse) VisitRefreshAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type VerifyAuthRequestObject struct {
}

type VerifyAuthResponseObject interface {
	VisitVerifyAuthResponse(w http.ResponseWriter) error
}

type VerifyAuth200JSONResponse struct{ VerifyResponseJSONResponse }

func (response VerifyAuth200JSONResponse) VisitVerifyAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type VerifyAuth401JSONResponse struct{ InvalidTokenErrorJSONResponse }

func (response VerifyAuth401JSONResponse) VisitVerifyAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type VerifyAuth500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response VerifyAuth500JSONResponse) VisitVerifyAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CallbackProviderRequestObject struct {
	Provider AuthProviderParam `json:"provider"`
	Params   CallbackProviderParams
}

type CallbackProviderResponseObject interface {
	VisitCallbackProviderResponse(w http.ResponseWriter) error
}

type CallbackProvider308TexthtmlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response CallbackProvider308TexthtmlResponse) VisitCallbackProviderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/html")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(308)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CallbackProvider404TexthtmlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response CallbackProvider404TexthtmlResponse) VisitCallbackProviderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/html")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(404)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CallbackProvider412TexthtmlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response CallbackProvider412TexthtmlResponse) VisitCallbackProviderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/html")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(412)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CallbackProvider500TexthtmlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response CallbackProvider500TexthtmlResponse) VisitCallbackProviderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/html")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(500)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type RequestProviderRequestObject struct {
	Provider AuthProviderParam `json:"provider"`
}

type RequestProviderResponseObject interface {
	VisitRequestProviderResponse(w http.ResponseWriter) error
}

type RequestProvider308TexthtmlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response RequestProvider308TexthtmlResponse) VisitRequestProviderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/html")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(308)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type RequestProvider404TexthtmlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response RequestProvider404TexthtmlResponse) VisitRequestProviderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/html")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(404)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type RequestProvider500TexthtmlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response RequestProvider500TexthtmlResponse) VisitRequestProviderResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/html")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(500)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type ListFabricsRequestObject struct {
	Params ListFabricsParams
}

type ListFabricsResponseObject interface {
	VisitListFabricsResponse(w http.ResponseWriter) error
}

type ListFabrics200JSONResponse struct{ FabricsResponseJSONResponse }

func (response ListFabrics200JSONResponse) VisitListFabricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListFabrics403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListFabrics403JSONResponse) VisitListFabricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListFabrics500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListFabrics500JSONResponse) VisitListFabricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateFabricRequestObject struct {
}

type UpdateFabricResponseObject interface {
	VisitUpdateFabricResponse(w http.ResponseWriter) error
}

type UpdateFabric200JSONResponse struct{ SuccessMessageJSONResponse }

func (response UpdateFabric200JSONResponse) VisitUpdateFabricResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateFabric403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdateFabric403JSONResponse) VisitUpdateFabricResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateFabric500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateFabric500JSONResponse) VisitUpdateFabricResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateFabric503JSONResponse struct {
	RemoteUnavailableErrorJSONResponse
}

func (response UpdateFabric503JSONResponse) VisitUpdateFabricResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type DeleteFabricFromBuildRequestObject struct {
	FabricID FabricID `json:"fabric_id"`
	Body     *DeleteFabricFromBuildJSONRequestBody
}

type DeleteFabricFromBuildResponseObject interface {
	VisitDeleteFabricFromBuildResponse(w http.ResponseWriter) error
}

type DeleteFabricFromBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteFabricFromBuild200JSONResponse) VisitDeleteFabricFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteFabricFromBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteFabricFromBuild400JSONResponse) VisitDeleteFabricFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteFabricFromBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteFabricFromBuild403JSONResponse) VisitDeleteFabricFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteFabricFromBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteFabricFromBuild404JSONResponse) VisitDeleteFabricFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteFabricFromBuild412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteFabricFromBuild412JSONResponse) VisitDeleteFabricFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteFabricFromBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteFabricFromBuild500JSONResponse) VisitDeleteFabricFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListFabricBuildsRequestObject struct {
	FabricID FabricID `json:"fabric_id"`
	Params   ListFabricBuildsParams
}

type ListFabricBuildsResponseObject interface {
	VisitListFabricBuildsResponse(w http.ResponseWriter) error
}

type ListFabricBuilds200JSONResponse struct {
	FabricBuildsResponseJSONResponse
}

func (response ListFabricBuilds200JSONResponse) VisitListFabricBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListFabricBuilds403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListFabricBuilds403JSONResponse) VisitListFabricBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListFabricBuilds404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListFabricBuilds404JSONResponse) VisitListFabricBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListFabricBuilds500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListFabricBuilds500JSONResponse) VisitListFabricBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachFabricToBuildRequestObject struct {
	FabricID FabricID `json:"fabric_id"`
	Body     *AttachFabricToBuildJSONRequestBody
}

type AttachFabricToBuildResponseObject interface {
	VisitAttachFabricToBuildResponse(w http.ResponseWriter) error
}

type AttachFabricToBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachFabricToBuild200JSONResponse) VisitAttachFabricToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachFabricToBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachFabricToBuild400JSONResponse) VisitAttachFabricToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachFabricToBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachFabricToBuild403JSONResponse) VisitAttachFabricToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachFabricToBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachFabricToBuild404JSONResponse) VisitAttachFabricToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachFabricToBuild412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachFabricToBuild412JSONResponse) VisitAttachFabricToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachFabricToBuild422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachFabricToBuild422JSONResponse) VisitAttachFabricToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachFabricToBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachFabricToBuild500JSONResponse) VisitAttachFabricToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListForgesRequestObject struct {
	Params ListForgesParams
}

type ListForgesResponseObject interface {
	VisitListForgesResponse(w http.ResponseWriter) error
}

type ListForges200JSONResponse struct{ ForgesResponseJSONResponse }

func (response ListForges200JSONResponse) VisitListForgesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListForges403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListForges403JSONResponse) VisitListForgesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListForges500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListForges500JSONResponse) VisitListForgesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateForgeRequestObject struct {
}

type UpdateForgeResponseObject interface {
	VisitUpdateForgeResponse(w http.ResponseWriter) error
}

type UpdateForge200JSONResponse struct{ SuccessMessageJSONResponse }

func (response UpdateForge200JSONResponse) VisitUpdateForgeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateForge403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdateForge403JSONResponse) VisitUpdateForgeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateForge500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateForge500JSONResponse) VisitUpdateForgeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateForge503JSONResponse struct {
	RemoteUnavailableErrorJSONResponse
}

func (response UpdateForge503JSONResponse) VisitUpdateForgeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type DeleteForgeFromBuildRequestObject struct {
	ForgeID ForgeID `json:"forge_id"`
	Body    *DeleteForgeFromBuildJSONRequestBody
}

type DeleteForgeFromBuildResponseObject interface {
	VisitDeleteForgeFromBuildResponse(w http.ResponseWriter) error
}

type DeleteForgeFromBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteForgeFromBuild200JSONResponse) VisitDeleteForgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteForgeFromBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteForgeFromBuild400JSONResponse) VisitDeleteForgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteForgeFromBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteForgeFromBuild403JSONResponse) VisitDeleteForgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteForgeFromBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteForgeFromBuild404JSONResponse) VisitDeleteForgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteForgeFromBuild412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteForgeFromBuild412JSONResponse) VisitDeleteForgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteForgeFromBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteForgeFromBuild500JSONResponse) VisitDeleteForgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListForgeBuildsRequestObject struct {
	ForgeID ForgeID `json:"forge_id"`
	Params  ListForgeBuildsParams
}

type ListForgeBuildsResponseObject interface {
	VisitListForgeBuildsResponse(w http.ResponseWriter) error
}

type ListForgeBuilds200JSONResponse struct {
	ForgeBuildsResponseJSONResponse
}

func (response ListForgeBuilds200JSONResponse) VisitListForgeBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListForgeBuilds403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListForgeBuilds403JSONResponse) VisitListForgeBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListForgeBuilds404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListForgeBuilds404JSONResponse) VisitListForgeBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListForgeBuilds500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListForgeBuilds500JSONResponse) VisitListForgeBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachForgeToBuildRequestObject struct {
	ForgeID ForgeID `json:"forge_id"`
	Body    *AttachForgeToBuildJSONRequestBody
}

type AttachForgeToBuildResponseObject interface {
	VisitAttachForgeToBuildResponse(w http.ResponseWriter) error
}

type AttachForgeToBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachForgeToBuild200JSONResponse) VisitAttachForgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachForgeToBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachForgeToBuild400JSONResponse) VisitAttachForgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachForgeToBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachForgeToBuild403JSONResponse) VisitAttachForgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachForgeToBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachForgeToBuild404JSONResponse) VisitAttachForgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachForgeToBuild412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachForgeToBuild412JSONResponse) VisitAttachForgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachForgeToBuild422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachForgeToBuild422JSONResponse) VisitAttachForgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachForgeToBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachForgeToBuild500JSONResponse) VisitAttachForgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupsRequestObject struct {
	Params ListGroupsParams
}

type ListGroupsResponseObject interface {
	VisitListGroupsResponse(w http.ResponseWriter) error
}

type ListGroups200JSONResponse struct{ GroupsResponseJSONResponse }

func (response ListGroups200JSONResponse) VisitListGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListGroups403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListGroups403JSONResponse) VisitListGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListGroups500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListGroups500JSONResponse) VisitListGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateGroupRequestObject struct {
	Body *CreateGroupJSONRequestBody
}

type CreateGroupResponseObject interface {
	VisitCreateGroupResponse(w http.ResponseWriter) error
}

type CreateGroup200JSONResponse struct{ GroupResponseJSONResponse }

func (response CreateGroup200JSONResponse) VisitCreateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateGroup400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response CreateGroup400JSONResponse) VisitCreateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response CreateGroup403JSONResponse) VisitCreateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateGroup422JSONResponse struct{ ValidationErrorJSONResponse }

func (response CreateGroup422JSONResponse) VisitCreateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CreateGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreateGroup500JSONResponse) VisitCreateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupRequestObject struct {
	GroupID GroupID `json:"group_id"`
}

type DeleteGroupResponseObject interface {
	VisitDeleteGroupResponse(w http.ResponseWriter) error
}

type DeleteGroup200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteGroup200JSONResponse) VisitDeleteGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroup400JSONResponse struct{ ActionFailedErrorJSONResponse }

func (response DeleteGroup400JSONResponse) VisitDeleteGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteGroup403JSONResponse) VisitDeleteGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteGroup404JSONResponse) VisitDeleteGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteGroup500JSONResponse) VisitDeleteGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ShowGroupRequestObject struct {
	GroupID GroupID `json:"group_id"`
}

type ShowGroupResponseObject interface {
	VisitShowGroupResponse(w http.ResponseWriter) error
}

type ShowGroup200JSONResponse struct{ GroupResponseJSONResponse }

func (response ShowGroup200JSONResponse) VisitShowGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ShowGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ShowGroup403JSONResponse) VisitShowGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ShowGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ShowGroup404JSONResponse) VisitShowGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ShowGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ShowGroup500JSONResponse) VisitShowGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroupRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Body    *UpdateGroupJSONRequestBody
}

type UpdateGroupResponseObject interface {
	VisitUpdateGroupResponse(w http.ResponseWriter) error
}

type UpdateGroup200JSONResponse struct{ GroupResponseJSONResponse }

func (response UpdateGroup200JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroup400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response UpdateGroup400JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdateGroup403JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response UpdateGroup404JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroup422JSONResponse struct{ ValidationErrorJSONResponse }

func (response UpdateGroup422JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type UpdateGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateGroup500JSONResponse) VisitUpdateGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromModRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Body    *DeleteGroupFromModJSONRequestBody
}

type DeleteGroupFromModResponseObject interface {
	VisitDeleteGroupFromModResponse(w http.ResponseWriter) error
}

type DeleteGroupFromMod200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteGroupFromMod200JSONResponse) VisitDeleteGroupFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromMod400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteGroupFromMod400JSONResponse) VisitDeleteGroupFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromMod403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteGroupFromMod403JSONResponse) VisitDeleteGroupFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromMod404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteGroupFromMod404JSONResponse) VisitDeleteGroupFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromMod412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteGroupFromMod412JSONResponse) VisitDeleteGroupFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromMod500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteGroupFromMod500JSONResponse) VisitDeleteGroupFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupModsRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Params  ListGroupModsParams
}

type ListGroupModsResponseObject interface {
	VisitListGroupModsResponse(w http.ResponseWriter) error
}

type ListGroupMods200JSONResponse struct{ GroupModsResponseJSONResponse }

func (response ListGroupMods200JSONResponse) VisitListGroupModsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupMods403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListGroupMods403JSONResponse) VisitListGroupModsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupMods404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListGroupMods404JSONResponse) VisitListGroupModsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupMods500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListGroupMods500JSONResponse) VisitListGroupModsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToModRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Body    *AttachGroupToModJSONRequestBody
}

type AttachGroupToModResponseObject interface {
	VisitAttachGroupToModResponse(w http.ResponseWriter) error
}

type AttachGroupToMod200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachGroupToMod200JSONResponse) VisitAttachGroupToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToMod400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachGroupToMod400JSONResponse) VisitAttachGroupToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToMod403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachGroupToMod403JSONResponse) VisitAttachGroupToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToMod404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachGroupToMod404JSONResponse) VisitAttachGroupToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToMod412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachGroupToMod412JSONResponse) VisitAttachGroupToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToMod422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachGroupToMod422JSONResponse) VisitAttachGroupToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToMod500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachGroupToMod500JSONResponse) VisitAttachGroupToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupModRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Body    *PermitGroupModJSONRequestBody
}

type PermitGroupModResponseObject interface {
	VisitPermitGroupModResponse(w http.ResponseWriter) error
}

type PermitGroupMod200JSONResponse struct{ SuccessMessageJSONResponse }

func (response PermitGroupMod200JSONResponse) VisitPermitGroupModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupMod400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PermitGroupMod400JSONResponse) VisitPermitGroupModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupMod403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response PermitGroupMod403JSONResponse) VisitPermitGroupModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupMod404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response PermitGroupMod404JSONResponse) VisitPermitGroupModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupMod412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response PermitGroupMod412JSONResponse) VisitPermitGroupModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupMod422JSONResponse struct{ ValidationErrorJSONResponse }

func (response PermitGroupMod422JSONResponse) VisitPermitGroupModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupMod500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response PermitGroupMod500JSONResponse) VisitPermitGroupModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromPackRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Body    *DeleteGroupFromPackJSONRequestBody
}

type DeleteGroupFromPackResponseObject interface {
	VisitDeleteGroupFromPackResponse(w http.ResponseWriter) error
}

type DeleteGroupFromPack200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteGroupFromPack200JSONResponse) VisitDeleteGroupFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromPack400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteGroupFromPack400JSONResponse) VisitDeleteGroupFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromPack403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteGroupFromPack403JSONResponse) VisitDeleteGroupFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromPack404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteGroupFromPack404JSONResponse) VisitDeleteGroupFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromPack412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteGroupFromPack412JSONResponse) VisitDeleteGroupFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromPack500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteGroupFromPack500JSONResponse) VisitDeleteGroupFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupPacksRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Params  ListGroupPacksParams
}

type ListGroupPacksResponseObject interface {
	VisitListGroupPacksResponse(w http.ResponseWriter) error
}

type ListGroupPacks200JSONResponse struct{ GroupPacksResponseJSONResponse }

func (response ListGroupPacks200JSONResponse) VisitListGroupPacksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupPacks403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListGroupPacks403JSONResponse) VisitListGroupPacksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupPacks404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListGroupPacks404JSONResponse) VisitListGroupPacksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupPacks500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListGroupPacks500JSONResponse) VisitListGroupPacksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToPackRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Body    *AttachGroupToPackJSONRequestBody
}

type AttachGroupToPackResponseObject interface {
	VisitAttachGroupToPackResponse(w http.ResponseWriter) error
}

type AttachGroupToPack200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachGroupToPack200JSONResponse) VisitAttachGroupToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToPack400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachGroupToPack400JSONResponse) VisitAttachGroupToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToPack403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachGroupToPack403JSONResponse) VisitAttachGroupToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToPack404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachGroupToPack404JSONResponse) VisitAttachGroupToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToPack412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachGroupToPack412JSONResponse) VisitAttachGroupToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToPack422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachGroupToPack422JSONResponse) VisitAttachGroupToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToPack500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachGroupToPack500JSONResponse) VisitAttachGroupToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupPackRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Body    *PermitGroupPackJSONRequestBody
}

type PermitGroupPackResponseObject interface {
	VisitPermitGroupPackResponse(w http.ResponseWriter) error
}

type PermitGroupPack200JSONResponse struct{ SuccessMessageJSONResponse }

func (response PermitGroupPack200JSONResponse) VisitPermitGroupPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupPack400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PermitGroupPack400JSONResponse) VisitPermitGroupPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupPack403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response PermitGroupPack403JSONResponse) VisitPermitGroupPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupPack404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response PermitGroupPack404JSONResponse) VisitPermitGroupPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupPack412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response PermitGroupPack412JSONResponse) VisitPermitGroupPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupPack422JSONResponse struct{ ValidationErrorJSONResponse }

func (response PermitGroupPack422JSONResponse) VisitPermitGroupPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupPack500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response PermitGroupPack500JSONResponse) VisitPermitGroupPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromUserRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Body    *DeleteGroupFromUserJSONRequestBody
}

type DeleteGroupFromUserResponseObject interface {
	VisitDeleteGroupFromUserResponse(w http.ResponseWriter) error
}

type DeleteGroupFromUser200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteGroupFromUser200JSONResponse) VisitDeleteGroupFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromUser400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteGroupFromUser400JSONResponse) VisitDeleteGroupFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteGroupFromUser403JSONResponse) VisitDeleteGroupFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteGroupFromUser404JSONResponse) VisitDeleteGroupFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromUser412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteGroupFromUser412JSONResponse) VisitDeleteGroupFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteGroupFromUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteGroupFromUser500JSONResponse) VisitDeleteGroupFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupUsersRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Params  ListGroupUsersParams
}

type ListGroupUsersResponseObject interface {
	VisitListGroupUsersResponse(w http.ResponseWriter) error
}

type ListGroupUsers200JSONResponse struct{ GroupUsersResponseJSONResponse }

func (response ListGroupUsers200JSONResponse) VisitListGroupUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupUsers403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListGroupUsers403JSONResponse) VisitListGroupUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupUsers404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListGroupUsers404JSONResponse) VisitListGroupUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListGroupUsers500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListGroupUsers500JSONResponse) VisitListGroupUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToUserRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Body    *AttachGroupToUserJSONRequestBody
}

type AttachGroupToUserResponseObject interface {
	VisitAttachGroupToUserResponse(w http.ResponseWriter) error
}

type AttachGroupToUser200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachGroupToUser200JSONResponse) VisitAttachGroupToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToUser400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachGroupToUser400JSONResponse) VisitAttachGroupToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachGroupToUser403JSONResponse) VisitAttachGroupToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachGroupToUser404JSONResponse) VisitAttachGroupToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToUser412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachGroupToUser412JSONResponse) VisitAttachGroupToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToUser422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachGroupToUser422JSONResponse) VisitAttachGroupToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachGroupToUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachGroupToUser500JSONResponse) VisitAttachGroupToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupUserRequestObject struct {
	GroupID GroupID `json:"group_id"`
	Body    *PermitGroupUserJSONRequestBody
}

type PermitGroupUserResponseObject interface {
	VisitPermitGroupUserResponse(w http.ResponseWriter) error
}

type PermitGroupUser200JSONResponse struct{ SuccessMessageJSONResponse }

func (response PermitGroupUser200JSONResponse) VisitPermitGroupUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupUser400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PermitGroupUser400JSONResponse) VisitPermitGroupUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response PermitGroupUser403JSONResponse) VisitPermitGroupUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response PermitGroupUser404JSONResponse) VisitPermitGroupUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupUser412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response PermitGroupUser412JSONResponse) VisitPermitGroupUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupUser422JSONResponse struct{ ValidationErrorJSONResponse }

func (response PermitGroupUser422JSONResponse) VisitPermitGroupUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type PermitGroupUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response PermitGroupUser500JSONResponse) VisitPermitGroupUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListMinecraftsRequestObject struct {
	Params ListMinecraftsParams
}

type ListMinecraftsResponseObject interface {
	VisitListMinecraftsResponse(w http.ResponseWriter) error
}

type ListMinecrafts200JSONResponse struct{ MinecraftsResponseJSONResponse }

func (response ListMinecrafts200JSONResponse) VisitListMinecraftsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListMinecrafts403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListMinecrafts403JSONResponse) VisitListMinecraftsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListMinecrafts500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListMinecrafts500JSONResponse) VisitListMinecraftsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateMinecraftRequestObject struct {
}

type UpdateMinecraftResponseObject interface {
	VisitUpdateMinecraftResponse(w http.ResponseWriter) error
}

type UpdateMinecraft200JSONResponse struct{ SuccessMessageJSONResponse }

func (response UpdateMinecraft200JSONResponse) VisitUpdateMinecraftResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateMinecraft403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdateMinecraft403JSONResponse) VisitUpdateMinecraftResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateMinecraft500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateMinecraft500JSONResponse) VisitUpdateMinecraftResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateMinecraft503JSONResponse struct {
	RemoteUnavailableErrorJSONResponse
}

func (response UpdateMinecraft503JSONResponse) VisitUpdateMinecraftResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type DeleteMinecraftFromBuildRequestObject struct {
	MinecraftID MinecraftID `json:"minecraft_id"`
	Body        *DeleteMinecraftFromBuildJSONRequestBody
}

type DeleteMinecraftFromBuildResponseObject interface {
	VisitDeleteMinecraftFromBuildResponse(w http.ResponseWriter) error
}

type DeleteMinecraftFromBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteMinecraftFromBuild200JSONResponse) VisitDeleteMinecraftFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteMinecraftFromBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteMinecraftFromBuild400JSONResponse) VisitDeleteMinecraftFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteMinecraftFromBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteMinecraftFromBuild403JSONResponse) VisitDeleteMinecraftFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteMinecraftFromBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteMinecraftFromBuild404JSONResponse) VisitDeleteMinecraftFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteMinecraftFromBuild412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteMinecraftFromBuild412JSONResponse) VisitDeleteMinecraftFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteMinecraftFromBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteMinecraftFromBuild500JSONResponse) VisitDeleteMinecraftFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListMinecraftBuildsRequestObject struct {
	MinecraftID MinecraftID `json:"minecraft_id"`
	Params      ListMinecraftBuildsParams
}

type ListMinecraftBuildsResponseObject interface {
	VisitListMinecraftBuildsResponse(w http.ResponseWriter) error
}

type ListMinecraftBuilds200JSONResponse struct {
	MinecraftBuildsResponseJSONResponse
}

func (response ListMinecraftBuilds200JSONResponse) VisitListMinecraftBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListMinecraftBuilds403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListMinecraftBuilds403JSONResponse) VisitListMinecraftBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListMinecraftBuilds404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListMinecraftBuilds404JSONResponse) VisitListMinecraftBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListMinecraftBuilds500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListMinecraftBuilds500JSONResponse) VisitListMinecraftBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachMinecraftToBuildRequestObject struct {
	MinecraftID MinecraftID `json:"minecraft_id"`
	Body        *AttachMinecraftToBuildJSONRequestBody
}

type AttachMinecraftToBuildResponseObject interface {
	VisitAttachMinecraftToBuildResponse(w http.ResponseWriter) error
}

type AttachMinecraftToBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachMinecraftToBuild200JSONResponse) VisitAttachMinecraftToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachMinecraftToBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachMinecraftToBuild400JSONResponse) VisitAttachMinecraftToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachMinecraftToBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachMinecraftToBuild403JSONResponse) VisitAttachMinecraftToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachMinecraftToBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachMinecraftToBuild404JSONResponse) VisitAttachMinecraftToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachMinecraftToBuild412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachMinecraftToBuild412JSONResponse) VisitAttachMinecraftToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachMinecraftToBuild422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachMinecraftToBuild422JSONResponse) VisitAttachMinecraftToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachMinecraftToBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachMinecraftToBuild500JSONResponse) VisitAttachMinecraftToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListModsRequestObject struct {
	Params ListModsParams
}

type ListModsResponseObject interface {
	VisitListModsResponse(w http.ResponseWriter) error
}

type ListMods200JSONResponse struct{ ModsResponseJSONResponse }

func (response ListMods200JSONResponse) VisitListModsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListMods403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListMods403JSONResponse) VisitListModsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListMods500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListMods500JSONResponse) VisitListModsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateModRequestObject struct {
	Body *CreateModJSONRequestBody
}

type CreateModResponseObject interface {
	VisitCreateModResponse(w http.ResponseWriter) error
}

type CreateMod200JSONResponse struct{ ModResponseJSONResponse }

func (response CreateMod200JSONResponse) VisitCreateModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateMod400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response CreateMod400JSONResponse) VisitCreateModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateMod403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response CreateMod403JSONResponse) VisitCreateModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateMod422JSONResponse struct{ ValidationErrorJSONResponse }

func (response CreateMod422JSONResponse) VisitCreateModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CreateMod500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreateMod500JSONResponse) VisitCreateModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModRequestObject struct {
	ModID ModID `json:"mod_id"`
}

type DeleteModResponseObject interface {
	VisitDeleteModResponse(w http.ResponseWriter) error
}

type DeleteMod200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteMod200JSONResponse) VisitDeleteModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteMod400JSONResponse struct{ ActionFailedErrorJSONResponse }

func (response DeleteMod400JSONResponse) VisitDeleteModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteMod403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteMod403JSONResponse) VisitDeleteModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteMod404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteMod404JSONResponse) VisitDeleteModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteMod500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteMod500JSONResponse) VisitDeleteModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ShowModRequestObject struct {
	ModID ModID `json:"mod_id"`
}

type ShowModResponseObject interface {
	VisitShowModResponse(w http.ResponseWriter) error
}

type ShowMod200JSONResponse struct{ ModResponseJSONResponse }

func (response ShowMod200JSONResponse) VisitShowModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ShowMod403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ShowMod403JSONResponse) VisitShowModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ShowMod404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ShowMod404JSONResponse) VisitShowModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ShowMod500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ShowMod500JSONResponse) VisitShowModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateModRequestObject struct {
	ModID ModID `json:"mod_id"`
	Body  *UpdateModJSONRequestBody
}

type UpdateModResponseObject interface {
	VisitUpdateModResponse(w http.ResponseWriter) error
}

type UpdateMod200JSONResponse struct{ ModResponseJSONResponse }

func (response UpdateMod200JSONResponse) VisitUpdateModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateMod400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response UpdateMod400JSONResponse) VisitUpdateModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateMod403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdateMod403JSONResponse) VisitUpdateModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateMod404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response UpdateMod404JSONResponse) VisitUpdateModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateMod422JSONResponse struct{ ValidationErrorJSONResponse }

func (response UpdateMod422JSONResponse) VisitUpdateModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type UpdateMod500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateMod500JSONResponse) VisitUpdateModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModAvatarRequestObject struct {
	ModID ModID `json:"mod_id"`
}

type DeleteModAvatarResponseObject interface {
	VisitDeleteModAvatarResponse(w http.ResponseWriter) error
}

type DeleteModAvatar200JSONResponse struct{ ModAvatarResponseJSONResponse }

func (response DeleteModAvatar200JSONResponse) VisitDeleteModAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModAvatar400JSONResponse struct{ ActionFailedErrorJSONResponse }

func (response DeleteModAvatar400JSONResponse) VisitDeleteModAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModAvatar403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteModAvatar403JSONResponse) VisitDeleteModAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModAvatar404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteModAvatar404JSONResponse) VisitDeleteModAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModAvatar500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteModAvatar500JSONResponse) VisitDeleteModAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateModAvatarRequestObject struct {
	ModID ModID `json:"mod_id"`
	Body  *multipart.Reader
}

type CreateModAvatarResponseObject interface {
	VisitCreateModAvatarResponse(w http.ResponseWriter) error
}

type CreateModAvatar200JSONResponse struct{ ModAvatarResponseJSONResponse }

func (response CreateModAvatar200JSONResponse) VisitCreateModAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateModAvatar400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response CreateModAvatar400JSONResponse) VisitCreateModAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateModAvatar403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response CreateModAvatar403JSONResponse) VisitCreateModAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateModAvatar404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response CreateModAvatar404JSONResponse) VisitCreateModAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateModAvatar422JSONResponse struct{ ValidationErrorJSONResponse }

func (response CreateModAvatar422JSONResponse) VisitCreateModAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CreateModAvatar500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreateModAvatar500JSONResponse) VisitCreateModAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromGroupRequestObject struct {
	ModID ModID `json:"mod_id"`
	Body  *DeleteModFromGroupJSONRequestBody
}

type DeleteModFromGroupResponseObject interface {
	VisitDeleteModFromGroupResponse(w http.ResponseWriter) error
}

type DeleteModFromGroup200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteModFromGroup200JSONResponse) VisitDeleteModFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromGroup400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteModFromGroup400JSONResponse) VisitDeleteModFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteModFromGroup403JSONResponse) VisitDeleteModFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteModFromGroup404JSONResponse) VisitDeleteModFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromGroup412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteModFromGroup412JSONResponse) VisitDeleteModFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteModFromGroup500JSONResponse) VisitDeleteModFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListModGroupsRequestObject struct {
	ModID  ModID `json:"mod_id"`
	Params ListModGroupsParams
}

type ListModGroupsResponseObject interface {
	VisitListModGroupsResponse(w http.ResponseWriter) error
}

type ListModGroups200JSONResponse struct{ ModGroupsResponseJSONResponse }

func (response ListModGroups200JSONResponse) VisitListModGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListModGroups403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListModGroups403JSONResponse) VisitListModGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListModGroups404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListModGroups404JSONResponse) VisitListModGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListModGroups500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListModGroups500JSONResponse) VisitListModGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToGroupRequestObject struct {
	ModID ModID `json:"mod_id"`
	Body  *AttachModToGroupJSONRequestBody
}

type AttachModToGroupResponseObject interface {
	VisitAttachModToGroupResponse(w http.ResponseWriter) error
}

type AttachModToGroup200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachModToGroup200JSONResponse) VisitAttachModToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToGroup400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachModToGroup400JSONResponse) VisitAttachModToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachModToGroup403JSONResponse) VisitAttachModToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachModToGroup404JSONResponse) VisitAttachModToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToGroup412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachModToGroup412JSONResponse) VisitAttachModToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToGroup422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachModToGroup422JSONResponse) VisitAttachModToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachModToGroup500JSONResponse) VisitAttachModToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PermitModGroupRequestObject struct {
	ModID ModID `json:"mod_id"`
	Body  *PermitModGroupJSONRequestBody
}

type PermitModGroupResponseObject interface {
	VisitPermitModGroupResponse(w http.ResponseWriter) error
}

type PermitModGroup200JSONResponse struct{ SuccessMessageJSONResponse }

func (response PermitModGroup200JSONResponse) VisitPermitModGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PermitModGroup400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PermitModGroup400JSONResponse) VisitPermitModGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PermitModGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response PermitModGroup403JSONResponse) VisitPermitModGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PermitModGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response PermitModGroup404JSONResponse) VisitPermitModGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PermitModGroup412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response PermitModGroup412JSONResponse) VisitPermitModGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type PermitModGroup422JSONResponse struct{ ValidationErrorJSONResponse }

func (response PermitModGroup422JSONResponse) VisitPermitModGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type PermitModGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response PermitModGroup500JSONResponse) VisitPermitModGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromUserRequestObject struct {
	ModID ModID `json:"mod_id"`
	Body  *DeleteModFromUserJSONRequestBody
}

type DeleteModFromUserResponseObject interface {
	VisitDeleteModFromUserResponse(w http.ResponseWriter) error
}

type DeleteModFromUser200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteModFromUser200JSONResponse) VisitDeleteModFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromUser400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteModFromUser400JSONResponse) VisitDeleteModFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteModFromUser403JSONResponse) VisitDeleteModFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteModFromUser404JSONResponse) VisitDeleteModFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromUser412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteModFromUser412JSONResponse) VisitDeleteModFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteModFromUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteModFromUser500JSONResponse) VisitDeleteModFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListModUsersRequestObject struct {
	ModID  ModID `json:"mod_id"`
	Params ListModUsersParams
}

type ListModUsersResponseObject interface {
	VisitListModUsersResponse(w http.ResponseWriter) error
}

type ListModUsers200JSONResponse struct{ ModUsersResponseJSONResponse }

func (response ListModUsers200JSONResponse) VisitListModUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListModUsers403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListModUsers403JSONResponse) VisitListModUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListModUsers404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListModUsers404JSONResponse) VisitListModUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListModUsers500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListModUsers500JSONResponse) VisitListModUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToUserRequestObject struct {
	ModID ModID `json:"mod_id"`
	Body  *AttachModToUserJSONRequestBody
}

type AttachModToUserResponseObject interface {
	VisitAttachModToUserResponse(w http.ResponseWriter) error
}

type AttachModToUser200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachModToUser200JSONResponse) VisitAttachModToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToUser400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachModToUser400JSONResponse) VisitAttachModToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachModToUser403JSONResponse) VisitAttachModToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachModToUser404JSONResponse) VisitAttachModToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToUser412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachModToUser412JSONResponse) VisitAttachModToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToUser422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachModToUser422JSONResponse) VisitAttachModToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachModToUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachModToUser500JSONResponse) VisitAttachModToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PermitModUserRequestObject struct {
	ModID ModID `json:"mod_id"`
	Body  *PermitModUserJSONRequestBody
}

type PermitModUserResponseObject interface {
	VisitPermitModUserResponse(w http.ResponseWriter) error
}

type PermitModUser200JSONResponse struct{ SuccessMessageJSONResponse }

func (response PermitModUser200JSONResponse) VisitPermitModUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PermitModUser400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PermitModUser400JSONResponse) VisitPermitModUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PermitModUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response PermitModUser403JSONResponse) VisitPermitModUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PermitModUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response PermitModUser404JSONResponse) VisitPermitModUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PermitModUser412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response PermitModUser412JSONResponse) VisitPermitModUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type PermitModUser422JSONResponse struct{ ValidationErrorJSONResponse }

func (response PermitModUser422JSONResponse) VisitPermitModUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type PermitModUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response PermitModUser500JSONResponse) VisitPermitModUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListVersionsRequestObject struct {
	ModID  ModID `json:"mod_id"`
	Params ListVersionsParams
}

type ListVersionsResponseObject interface {
	VisitListVersionsResponse(w http.ResponseWriter) error
}

type ListVersions200JSONResponse struct{ VersionsResponseJSONResponse }

func (response ListVersions200JSONResponse) VisitListVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListVersions403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListVersions403JSONResponse) VisitListVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListVersions404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListVersions404JSONResponse) VisitListVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListVersions500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListVersions500JSONResponse) VisitListVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateVersionRequestObject struct {
	ModID ModID `json:"mod_id"`
	Body  *CreateVersionJSONRequestBody
}

type CreateVersionResponseObject interface {
	VisitCreateVersionResponse(w http.ResponseWriter) error
}

type CreateVersion200JSONResponse struct{ VersionResponseJSONResponse }

func (response CreateVersion200JSONResponse) VisitCreateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateVersion400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response CreateVersion400JSONResponse) VisitCreateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateVersion403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response CreateVersion403JSONResponse) VisitCreateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateVersion404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response CreateVersion404JSONResponse) VisitCreateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateVersion422JSONResponse struct{ ValidationErrorJSONResponse }

func (response CreateVersion422JSONResponse) VisitCreateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CreateVersion500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreateVersion500JSONResponse) VisitCreateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteVersionRequestObject struct {
	ModID     ModID     `json:"mod_id"`
	VersionID VersionID `json:"version_id"`
}

type DeleteVersionResponseObject interface {
	VisitDeleteVersionResponse(w http.ResponseWriter) error
}

type DeleteVersion200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteVersion200JSONResponse) VisitDeleteVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteVersion400JSONResponse struct{ ActionFailedErrorJSONResponse }

func (response DeleteVersion400JSONResponse) VisitDeleteVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteVersion403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteVersion403JSONResponse) VisitDeleteVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteVersion404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteVersion404JSONResponse) VisitDeleteVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteVersion500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteVersion500JSONResponse) VisitDeleteVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ShowVersionRequestObject struct {
	ModID     ModID     `json:"mod_id"`
	VersionID VersionID `json:"version_id"`
}

type ShowVersionResponseObject interface {
	VisitShowVersionResponse(w http.ResponseWriter) error
}

type ShowVersion200JSONResponse struct{ VersionResponseJSONResponse }

func (response ShowVersion200JSONResponse) VisitShowVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ShowVersion403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ShowVersion403JSONResponse) VisitShowVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ShowVersion404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ShowVersion404JSONResponse) VisitShowVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ShowVersion500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ShowVersion500JSONResponse) VisitShowVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateVersionRequestObject struct {
	ModID     ModID     `json:"mod_id"`
	VersionID VersionID `json:"version_id"`
	Body      *UpdateVersionJSONRequestBody
}

type UpdateVersionResponseObject interface {
	VisitUpdateVersionResponse(w http.ResponseWriter) error
}

type UpdateVersion200JSONResponse struct{ VersionResponseJSONResponse }

func (response UpdateVersion200JSONResponse) VisitUpdateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateVersion400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response UpdateVersion400JSONResponse) VisitUpdateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateVersion403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdateVersion403JSONResponse) VisitUpdateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateVersion404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response UpdateVersion404JSONResponse) VisitUpdateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateVersion422JSONResponse struct{ ValidationErrorJSONResponse }

func (response UpdateVersion422JSONResponse) VisitUpdateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type UpdateVersion500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateVersion500JSONResponse) VisitUpdateVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteVersionFromBuildRequestObject struct {
	ModID     ModID     `json:"mod_id"`
	VersionID VersionID `json:"version_id"`
	Body      *DeleteVersionFromBuildJSONRequestBody
}

type DeleteVersionFromBuildResponseObject interface {
	VisitDeleteVersionFromBuildResponse(w http.ResponseWriter) error
}

type DeleteVersionFromBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteVersionFromBuild200JSONResponse) VisitDeleteVersionFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteVersionFromBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteVersionFromBuild400JSONResponse) VisitDeleteVersionFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteVersionFromBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteVersionFromBuild403JSONResponse) VisitDeleteVersionFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteVersionFromBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteVersionFromBuild404JSONResponse) VisitDeleteVersionFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteVersionFromBuild412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteVersionFromBuild412JSONResponse) VisitDeleteVersionFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteVersionFromBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteVersionFromBuild500JSONResponse) VisitDeleteVersionFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListVersionBuildsRequestObject struct {
	ModID     ModID     `json:"mod_id"`
	VersionID VersionID `json:"version_id"`
	Params    ListVersionBuildsParams
}

type ListVersionBuildsResponseObject interface {
	VisitListVersionBuildsResponse(w http.ResponseWriter) error
}

type ListVersionBuilds200JSONResponse struct {
	VersionBuildsResponseJSONResponse
}

func (response ListVersionBuilds200JSONResponse) VisitListVersionBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListVersionBuilds403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListVersionBuilds403JSONResponse) VisitListVersionBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListVersionBuilds404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListVersionBuilds404JSONResponse) VisitListVersionBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListVersionBuilds500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListVersionBuilds500JSONResponse) VisitListVersionBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachVersionToBuildRequestObject struct {
	ModID     ModID     `json:"mod_id"`
	VersionID VersionID `json:"version_id"`
	Body      *AttachVersionToBuildJSONRequestBody
}

type AttachVersionToBuildResponseObject interface {
	VisitAttachVersionToBuildResponse(w http.ResponseWriter) error
}

type AttachVersionToBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachVersionToBuild200JSONResponse) VisitAttachVersionToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachVersionToBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachVersionToBuild400JSONResponse) VisitAttachVersionToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachVersionToBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachVersionToBuild403JSONResponse) VisitAttachVersionToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachVersionToBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachVersionToBuild404JSONResponse) VisitAttachVersionToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachVersionToBuild412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachVersionToBuild412JSONResponse) VisitAttachVersionToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachVersionToBuild422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachVersionToBuild422JSONResponse) VisitAttachVersionToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachVersionToBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachVersionToBuild500JSONResponse) VisitAttachVersionToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListNeoforgesRequestObject struct {
	Params ListNeoforgesParams
}

type ListNeoforgesResponseObject interface {
	VisitListNeoforgesResponse(w http.ResponseWriter) error
}

type ListNeoforges200JSONResponse struct{ NeoforgesResponseJSONResponse }

func (response ListNeoforges200JSONResponse) VisitListNeoforgesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListNeoforges403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListNeoforges403JSONResponse) VisitListNeoforgesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListNeoforges500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListNeoforges500JSONResponse) VisitListNeoforgesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNeoforgeRequestObject struct {
}

type UpdateNeoforgeResponseObject interface {
	VisitUpdateNeoforgeResponse(w http.ResponseWriter) error
}

type UpdateNeoforge200JSONResponse struct{ SuccessMessageJSONResponse }

func (response UpdateNeoforge200JSONResponse) VisitUpdateNeoforgeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNeoforge403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdateNeoforge403JSONResponse) VisitUpdateNeoforgeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNeoforge500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateNeoforge500JSONResponse) VisitUpdateNeoforgeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNeoforge503JSONResponse struct {
	RemoteUnavailableErrorJSONResponse
}

func (response UpdateNeoforge503JSONResponse) VisitUpdateNeoforgeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type DeleteNeoforgeFromBuildRequestObject struct {
	NeoforgeID NeoforgeID `json:"neoforge_id"`
	Body       *DeleteNeoforgeFromBuildJSONRequestBody
}

type DeleteNeoforgeFromBuildResponseObject interface {
	VisitDeleteNeoforgeFromBuildResponse(w http.ResponseWriter) error
}

type DeleteNeoforgeFromBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteNeoforgeFromBuild200JSONResponse) VisitDeleteNeoforgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteNeoforgeFromBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteNeoforgeFromBuild400JSONResponse) VisitDeleteNeoforgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteNeoforgeFromBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteNeoforgeFromBuild403JSONResponse) VisitDeleteNeoforgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteNeoforgeFromBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteNeoforgeFromBuild404JSONResponse) VisitDeleteNeoforgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteNeoforgeFromBuild412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteNeoforgeFromBuild412JSONResponse) VisitDeleteNeoforgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteNeoforgeFromBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteNeoforgeFromBuild500JSONResponse) VisitDeleteNeoforgeFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListNeoforgeBuildsRequestObject struct {
	NeoforgeID NeoforgeID `json:"neoforge_id"`
	Params     ListNeoforgeBuildsParams
}

type ListNeoforgeBuildsResponseObject interface {
	VisitListNeoforgeBuildsResponse(w http.ResponseWriter) error
}

type ListNeoforgeBuilds200JSONResponse struct {
	NeoforgeBuildsResponseJSONResponse
}

func (response ListNeoforgeBuilds200JSONResponse) VisitListNeoforgeBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListNeoforgeBuilds403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListNeoforgeBuilds403JSONResponse) VisitListNeoforgeBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListNeoforgeBuilds404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListNeoforgeBuilds404JSONResponse) VisitListNeoforgeBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListNeoforgeBuilds500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListNeoforgeBuilds500JSONResponse) VisitListNeoforgeBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachNeoforgeToBuildRequestObject struct {
	NeoforgeID NeoforgeID `json:"neoforge_id"`
	Body       *AttachNeoforgeToBuildJSONRequestBody
}

type AttachNeoforgeToBuildResponseObject interface {
	VisitAttachNeoforgeToBuildResponse(w http.ResponseWriter) error
}

type AttachNeoforgeToBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachNeoforgeToBuild200JSONResponse) VisitAttachNeoforgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachNeoforgeToBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachNeoforgeToBuild400JSONResponse) VisitAttachNeoforgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachNeoforgeToBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachNeoforgeToBuild403JSONResponse) VisitAttachNeoforgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachNeoforgeToBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachNeoforgeToBuild404JSONResponse) VisitAttachNeoforgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachNeoforgeToBuild412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachNeoforgeToBuild412JSONResponse) VisitAttachNeoforgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachNeoforgeToBuild422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachNeoforgeToBuild422JSONResponse) VisitAttachNeoforgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachNeoforgeToBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachNeoforgeToBuild500JSONResponse) VisitAttachNeoforgeToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListPacksRequestObject struct {
	Params ListPacksParams
}

type ListPacksResponseObject interface {
	VisitListPacksResponse(w http.ResponseWriter) error
}

type ListPacks200JSONResponse struct{ PacksResponseJSONResponse }

func (response ListPacks200JSONResponse) VisitListPacksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListPacks403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListPacks403JSONResponse) VisitListPacksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListPacks500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListPacks500JSONResponse) VisitListPacksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreatePackRequestObject struct {
	Body *CreatePackJSONRequestBody
}

type CreatePackResponseObject interface {
	VisitCreatePackResponse(w http.ResponseWriter) error
}

type CreatePack200JSONResponse struct{ PackResponseJSONResponse }

func (response CreatePack200JSONResponse) VisitCreatePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreatePack400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response CreatePack400JSONResponse) VisitCreatePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreatePack403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response CreatePack403JSONResponse) VisitCreatePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreatePack422JSONResponse struct{ ValidationErrorJSONResponse }

func (response CreatePack422JSONResponse) VisitCreatePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CreatePack500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreatePack500JSONResponse) VisitCreatePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackRequestObject struct {
	PackID PackID `json:"pack_id"`
}

type DeletePackResponseObject interface {
	VisitDeletePackResponse(w http.ResponseWriter) error
}

type DeletePack200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeletePack200JSONResponse) VisitDeletePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeletePack400JSONResponse struct{ ActionFailedErrorJSONResponse }

func (response DeletePack400JSONResponse) VisitDeletePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeletePack403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeletePack403JSONResponse) VisitDeletePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeletePack404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeletePack404JSONResponse) VisitDeletePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeletePack500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeletePack500JSONResponse) VisitDeletePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ShowPackRequestObject struct {
	PackID PackID `json:"pack_id"`
}

type ShowPackResponseObject interface {
	VisitShowPackResponse(w http.ResponseWriter) error
}

type ShowPack200JSONResponse struct{ PackResponseJSONResponse }

func (response ShowPack200JSONResponse) VisitShowPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ShowPack403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ShowPack403JSONResponse) VisitShowPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ShowPack404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ShowPack404JSONResponse) VisitShowPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ShowPack500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ShowPack500JSONResponse) VisitShowPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePackRequestObject struct {
	PackID PackID `json:"pack_id"`
	Body   *UpdatePackJSONRequestBody
}

type UpdatePackResponseObject interface {
	VisitUpdatePackResponse(w http.ResponseWriter) error
}

type UpdatePack200JSONResponse struct{ PackResponseJSONResponse }

func (response UpdatePack200JSONResponse) VisitUpdatePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePack400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response UpdatePack400JSONResponse) VisitUpdatePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePack403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdatePack403JSONResponse) VisitUpdatePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePack404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response UpdatePack404JSONResponse) VisitUpdatePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePack422JSONResponse struct{ ValidationErrorJSONResponse }

func (response UpdatePack422JSONResponse) VisitUpdatePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePack500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdatePack500JSONResponse) VisitUpdatePackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackAvatarRequestObject struct {
	PackID PackID `json:"pack_id"`
}

type DeletePackAvatarResponseObject interface {
	VisitDeletePackAvatarResponse(w http.ResponseWriter) error
}

type DeletePackAvatar200JSONResponse struct{ PackAvatarResponseJSONResponse }

func (response DeletePackAvatar200JSONResponse) VisitDeletePackAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackAvatar400JSONResponse struct{ ActionFailedErrorJSONResponse }

func (response DeletePackAvatar400JSONResponse) VisitDeletePackAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackAvatar403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeletePackAvatar403JSONResponse) VisitDeletePackAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackAvatar404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeletePackAvatar404JSONResponse) VisitDeletePackAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackAvatar500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeletePackAvatar500JSONResponse) VisitDeletePackAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreatePackAvatarRequestObject struct {
	PackID PackID `json:"pack_id"`
	Body   *multipart.Reader
}

type CreatePackAvatarResponseObject interface {
	VisitCreatePackAvatarResponse(w http.ResponseWriter) error
}

type CreatePackAvatar200JSONResponse struct{ PackAvatarResponseJSONResponse }

func (response CreatePackAvatar200JSONResponse) VisitCreatePackAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreatePackAvatar400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response CreatePackAvatar400JSONResponse) VisitCreatePackAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreatePackAvatar403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response CreatePackAvatar403JSONResponse) VisitCreatePackAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreatePackAvatar404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response CreatePackAvatar404JSONResponse) VisitCreatePackAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreatePackAvatar422JSONResponse struct{ ValidationErrorJSONResponse }

func (response CreatePackAvatar422JSONResponse) VisitCreatePackAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CreatePackAvatar500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreatePackAvatar500JSONResponse) VisitCreatePackAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListBuildsRequestObject struct {
	PackID PackID `json:"pack_id"`
	Params ListBuildsParams
}

type ListBuildsResponseObject interface {
	VisitListBuildsResponse(w http.ResponseWriter) error
}

type ListBuilds200JSONResponse struct{ BuildsResponseJSONResponse }

func (response ListBuilds200JSONResponse) VisitListBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListBuilds403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListBuilds403JSONResponse) VisitListBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListBuilds404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListBuilds404JSONResponse) VisitListBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListBuilds500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListBuilds500JSONResponse) VisitListBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateBuildRequestObject struct {
	PackID PackID `json:"pack_id"`
	Body   *CreateBuildJSONRequestBody
}

type CreateBuildResponseObject interface {
	VisitCreateBuildResponse(w http.ResponseWriter) error
}

type CreateBuild200JSONResponse struct{ BuildResponseJSONResponse }

func (response CreateBuild200JSONResponse) VisitCreateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response CreateBuild400JSONResponse) VisitCreateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response CreateBuild403JSONResponse) VisitCreateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response CreateBuild404JSONResponse) VisitCreateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateBuild422JSONResponse struct{ ValidationErrorJSONResponse }

func (response CreateBuild422JSONResponse) VisitCreateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CreateBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreateBuild500JSONResponse) VisitCreateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBuildRequestObject struct {
	PackID  PackID  `json:"pack_id"`
	BuildID BuildID `json:"build_id"`
}

type DeleteBuildResponseObject interface {
	VisitDeleteBuildResponse(w http.ResponseWriter) error
}

type DeleteBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteBuild200JSONResponse) VisitDeleteBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBuild400JSONResponse struct{ ActionFailedErrorJSONResponse }

func (response DeleteBuild400JSONResponse) VisitDeleteBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteBuild403JSONResponse) VisitDeleteBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteBuild404JSONResponse) VisitDeleteBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteBuild500JSONResponse) VisitDeleteBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ShowBuildRequestObject struct {
	PackID  PackID  `json:"pack_id"`
	BuildID BuildID `json:"build_id"`
}

type ShowBuildResponseObject interface {
	VisitShowBuildResponse(w http.ResponseWriter) error
}

type ShowBuild200JSONResponse struct{ BuildResponseJSONResponse }

func (response ShowBuild200JSONResponse) VisitShowBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ShowBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ShowBuild403JSONResponse) VisitShowBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ShowBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ShowBuild404JSONResponse) VisitShowBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ShowBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ShowBuild500JSONResponse) VisitShowBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateBuildRequestObject struct {
	PackID  PackID  `json:"pack_id"`
	BuildID BuildID `json:"build_id"`
	Body    *UpdateBuildJSONRequestBody
}

type UpdateBuildResponseObject interface {
	VisitUpdateBuildResponse(w http.ResponseWriter) error
}

type UpdateBuild200JSONResponse struct{ BuildResponseJSONResponse }

func (response UpdateBuild200JSONResponse) VisitUpdateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response UpdateBuild400JSONResponse) VisitUpdateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdateBuild403JSONResponse) VisitUpdateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response UpdateBuild404JSONResponse) VisitUpdateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateBuild422JSONResponse struct{ ValidationErrorJSONResponse }

func (response UpdateBuild422JSONResponse) VisitUpdateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type UpdateBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateBuild500JSONResponse) VisitUpdateBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBuildFromVersionRequestObject struct {
	PackID  PackID  `json:"pack_id"`
	BuildID BuildID `json:"build_id"`
	Body    *DeleteBuildFromVersionJSONRequestBody
}

type DeleteBuildFromVersionResponseObject interface {
	VisitDeleteBuildFromVersionResponse(w http.ResponseWriter) error
}

type DeleteBuildFromVersion200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteBuildFromVersion200JSONResponse) VisitDeleteBuildFromVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBuildFromVersion400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteBuildFromVersion400JSONResponse) VisitDeleteBuildFromVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBuildFromVersion403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteBuildFromVersion403JSONResponse) VisitDeleteBuildFromVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBuildFromVersion404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteBuildFromVersion404JSONResponse) VisitDeleteBuildFromVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBuildFromVersion412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteBuildFromVersion412JSONResponse) VisitDeleteBuildFromVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBuildFromVersion500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteBuildFromVersion500JSONResponse) VisitDeleteBuildFromVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListBuildVersionsRequestObject struct {
	PackID  PackID  `json:"pack_id"`
	BuildID BuildID `json:"build_id"`
	Params  ListBuildVersionsParams
}

type ListBuildVersionsResponseObject interface {
	VisitListBuildVersionsResponse(w http.ResponseWriter) error
}

type ListBuildVersions200JSONResponse struct {
	BuildVersionsResponseJSONResponse
}

func (response ListBuildVersions200JSONResponse) VisitListBuildVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListBuildVersions403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListBuildVersions403JSONResponse) VisitListBuildVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListBuildVersions404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListBuildVersions404JSONResponse) VisitListBuildVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListBuildVersions500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListBuildVersions500JSONResponse) VisitListBuildVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachBuildToVersionRequestObject struct {
	PackID  PackID  `json:"pack_id"`
	BuildID BuildID `json:"build_id"`
	Body    *AttachBuildToVersionJSONRequestBody
}

type AttachBuildToVersionResponseObject interface {
	VisitAttachBuildToVersionResponse(w http.ResponseWriter) error
}

type AttachBuildToVersion200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachBuildToVersion200JSONResponse) VisitAttachBuildToVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachBuildToVersion400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachBuildToVersion400JSONResponse) VisitAttachBuildToVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachBuildToVersion403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachBuildToVersion403JSONResponse) VisitAttachBuildToVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachBuildToVersion404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachBuildToVersion404JSONResponse) VisitAttachBuildToVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachBuildToVersion412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachBuildToVersion412JSONResponse) VisitAttachBuildToVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachBuildToVersion422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachBuildToVersion422JSONResponse) VisitAttachBuildToVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachBuildToVersion500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachBuildToVersion500JSONResponse) VisitAttachBuildToVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromGroupRequestObject struct {
	PackID PackID `json:"pack_id"`
	Body   *DeletePackFromGroupJSONRequestBody
}

type DeletePackFromGroupResponseObject interface {
	VisitDeletePackFromGroupResponse(w http.ResponseWriter) error
}

type DeletePackFromGroup200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeletePackFromGroup200JSONResponse) VisitDeletePackFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromGroup400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeletePackFromGroup400JSONResponse) VisitDeletePackFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeletePackFromGroup403JSONResponse) VisitDeletePackFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeletePackFromGroup404JSONResponse) VisitDeletePackFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromGroup412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeletePackFromGroup412JSONResponse) VisitDeletePackFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeletePackFromGroup500JSONResponse) VisitDeletePackFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListPackGroupsRequestObject struct {
	PackID PackID `json:"pack_id"`
	Params ListPackGroupsParams
}

type ListPackGroupsResponseObject interface {
	VisitListPackGroupsResponse(w http.ResponseWriter) error
}

type ListPackGroups200JSONResponse struct{ PackGroupsResponseJSONResponse }

func (response ListPackGroups200JSONResponse) VisitListPackGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListPackGroups403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListPackGroups403JSONResponse) VisitListPackGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListPackGroups404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListPackGroups404JSONResponse) VisitListPackGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListPackGroups500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListPackGroups500JSONResponse) VisitListPackGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToGroupRequestObject struct {
	PackID PackID `json:"pack_id"`
	Body   *AttachPackToGroupJSONRequestBody
}

type AttachPackToGroupResponseObject interface {
	VisitAttachPackToGroupResponse(w http.ResponseWriter) error
}

type AttachPackToGroup200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachPackToGroup200JSONResponse) VisitAttachPackToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToGroup400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachPackToGroup400JSONResponse) VisitAttachPackToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachPackToGroup403JSONResponse) VisitAttachPackToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachPackToGroup404JSONResponse) VisitAttachPackToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToGroup412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachPackToGroup412JSONResponse) VisitAttachPackToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToGroup422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachPackToGroup422JSONResponse) VisitAttachPackToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachPackToGroup500JSONResponse) VisitAttachPackToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackGroupRequestObject struct {
	PackID PackID `json:"pack_id"`
	Body   *PermitPackGroupJSONRequestBody
}

type PermitPackGroupResponseObject interface {
	VisitPermitPackGroupResponse(w http.ResponseWriter) error
}

type PermitPackGroup200JSONResponse struct{ SuccessMessageJSONResponse }

func (response PermitPackGroup200JSONResponse) VisitPermitPackGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackGroup400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PermitPackGroup400JSONResponse) VisitPermitPackGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response PermitPackGroup403JSONResponse) VisitPermitPackGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response PermitPackGroup404JSONResponse) VisitPermitPackGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackGroup412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response PermitPackGroup412JSONResponse) VisitPermitPackGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackGroup422JSONResponse struct{ ValidationErrorJSONResponse }

func (response PermitPackGroup422JSONResponse) VisitPermitPackGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response PermitPackGroup500JSONResponse) VisitPermitPackGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromUserRequestObject struct {
	PackID PackID `json:"pack_id"`
	Body   *DeletePackFromUserJSONRequestBody
}

type DeletePackFromUserResponseObject interface {
	VisitDeletePackFromUserResponse(w http.ResponseWriter) error
}

type DeletePackFromUser200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeletePackFromUser200JSONResponse) VisitDeletePackFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromUser400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeletePackFromUser400JSONResponse) VisitDeletePackFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeletePackFromUser403JSONResponse) VisitDeletePackFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeletePackFromUser404JSONResponse) VisitDeletePackFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromUser412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeletePackFromUser412JSONResponse) VisitDeletePackFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeletePackFromUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeletePackFromUser500JSONResponse) VisitDeletePackFromUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListPackUsersRequestObject struct {
	PackID PackID `json:"pack_id"`
	Params ListPackUsersParams
}

type ListPackUsersResponseObject interface {
	VisitListPackUsersResponse(w http.ResponseWriter) error
}

type ListPackUsers200JSONResponse struct{ PackUsersResponseJSONResponse }

func (response ListPackUsers200JSONResponse) VisitListPackUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListPackUsers403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListPackUsers403JSONResponse) VisitListPackUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListPackUsers404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListPackUsers404JSONResponse) VisitListPackUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListPackUsers500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListPackUsers500JSONResponse) VisitListPackUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToUserRequestObject struct {
	PackID PackID `json:"pack_id"`
	Body   *AttachPackToUserJSONRequestBody
}

type AttachPackToUserResponseObject interface {
	VisitAttachPackToUserResponse(w http.ResponseWriter) error
}

type AttachPackToUser200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachPackToUser200JSONResponse) VisitAttachPackToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToUser400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachPackToUser400JSONResponse) VisitAttachPackToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachPackToUser403JSONResponse) VisitAttachPackToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachPackToUser404JSONResponse) VisitAttachPackToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToUser412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachPackToUser412JSONResponse) VisitAttachPackToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToUser422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachPackToUser422JSONResponse) VisitAttachPackToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachPackToUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachPackToUser500JSONResponse) VisitAttachPackToUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackUserRequestObject struct {
	PackID PackID `json:"pack_id"`
	Body   *PermitPackUserJSONRequestBody
}

type PermitPackUserResponseObject interface {
	VisitPermitPackUserResponse(w http.ResponseWriter) error
}

type PermitPackUser200JSONResponse struct{ SuccessMessageJSONResponse }

func (response PermitPackUser200JSONResponse) VisitPermitPackUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackUser400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PermitPackUser400JSONResponse) VisitPermitPackUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response PermitPackUser403JSONResponse) VisitPermitPackUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response PermitPackUser404JSONResponse) VisitPermitPackUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackUser412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response PermitPackUser412JSONResponse) VisitPermitPackUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackUser422JSONResponse struct{ ValidationErrorJSONResponse }

func (response PermitPackUser422JSONResponse) VisitPermitPackUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type PermitPackUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response PermitPackUser500JSONResponse) VisitPermitPackUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ShowProfileRequestObject struct {
}

type ShowProfileResponseObject interface {
	VisitShowProfileResponse(w http.ResponseWriter) error
}

type ShowProfile200JSONResponse struct{ ProfileResponseJSONResponse }

func (response ShowProfile200JSONResponse) VisitShowProfileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ShowProfile403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ShowProfile403JSONResponse) VisitShowProfileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ShowProfile500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ShowProfile500JSONResponse) VisitShowProfileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateProfileRequestObject struct {
	Body *UpdateProfileJSONRequestBody
}

type UpdateProfileResponseObject interface {
	VisitUpdateProfileResponse(w http.ResponseWriter) error
}

type UpdateProfile200JSONResponse struct{ ProfileResponseJSONResponse }

func (response UpdateProfile200JSONResponse) VisitUpdateProfileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateProfile400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response UpdateProfile400JSONResponse) VisitUpdateProfileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateProfile403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdateProfile403JSONResponse) VisitUpdateProfileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateProfile422JSONResponse struct{ ValidationErrorJSONResponse }

func (response UpdateProfile422JSONResponse) VisitUpdateProfileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type UpdateProfile500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateProfile500JSONResponse) VisitUpdateProfileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type TokenProfileRequestObject struct {
}

type TokenProfileResponseObject interface {
	VisitTokenProfileResponse(w http.ResponseWriter) error
}

type TokenProfile200JSONResponse struct{ TokenResponseJSONResponse }

func (response TokenProfile200JSONResponse) VisitTokenProfileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type TokenProfile403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response TokenProfile403JSONResponse) VisitTokenProfileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type TokenProfile500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response TokenProfile500JSONResponse) VisitTokenProfileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListQuiltsRequestObject struct {
	Params ListQuiltsParams
}

type ListQuiltsResponseObject interface {
	VisitListQuiltsResponse(w http.ResponseWriter) error
}

type ListQuilts200JSONResponse struct{ QuiltsResponseJSONResponse }

func (response ListQuilts200JSONResponse) VisitListQuiltsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListQuilts403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListQuilts403JSONResponse) VisitListQuiltsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListQuilts500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListQuilts500JSONResponse) VisitListQuiltsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateQuiltRequestObject struct {
}

type UpdateQuiltResponseObject interface {
	VisitUpdateQuiltResponse(w http.ResponseWriter) error
}

type UpdateQuilt200JSONResponse struct{ SuccessMessageJSONResponse }

func (response UpdateQuilt200JSONResponse) VisitUpdateQuiltResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateQuilt403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdateQuilt403JSONResponse) VisitUpdateQuiltResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateQuilt500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateQuilt500JSONResponse) VisitUpdateQuiltResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateQuilt503JSONResponse struct {
	RemoteUnavailableErrorJSONResponse
}

func (response UpdateQuilt503JSONResponse) VisitUpdateQuiltResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type DeleteQuiltFromBuildRequestObject struct {
	QuiltID QuiltID `json:"quilt_id"`
	Body    *DeleteQuiltFromBuildJSONRequestBody
}

type DeleteQuiltFromBuildResponseObject interface {
	VisitDeleteQuiltFromBuildResponse(w http.ResponseWriter) error
}

type DeleteQuiltFromBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteQuiltFromBuild200JSONResponse) VisitDeleteQuiltFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteQuiltFromBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteQuiltFromBuild400JSONResponse) VisitDeleteQuiltFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteQuiltFromBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteQuiltFromBuild403JSONResponse) VisitDeleteQuiltFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteQuiltFromBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteQuiltFromBuild404JSONResponse) VisitDeleteQuiltFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteQuiltFromBuild412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteQuiltFromBuild412JSONResponse) VisitDeleteQuiltFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteQuiltFromBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteQuiltFromBuild500JSONResponse) VisitDeleteQuiltFromBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListQuiltBuildsRequestObject struct {
	QuiltID QuiltID `json:"quilt_id"`
	Params  ListQuiltBuildsParams
}

type ListQuiltBuildsResponseObject interface {
	VisitListQuiltBuildsResponse(w http.ResponseWriter) error
}

type ListQuiltBuilds200JSONResponse struct {
	QuiltBuildsResponseJSONResponse
}

func (response ListQuiltBuilds200JSONResponse) VisitListQuiltBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListQuiltBuilds403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListQuiltBuilds403JSONResponse) VisitListQuiltBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListQuiltBuilds404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListQuiltBuilds404JSONResponse) VisitListQuiltBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListQuiltBuilds500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListQuiltBuilds500JSONResponse) VisitListQuiltBuildsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachQuiltToBuildRequestObject struct {
	QuiltID QuiltID `json:"quilt_id"`
	Body    *AttachQuiltToBuildJSONRequestBody
}

type AttachQuiltToBuildResponseObject interface {
	VisitAttachQuiltToBuildResponse(w http.ResponseWriter) error
}

type AttachQuiltToBuild200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachQuiltToBuild200JSONResponse) VisitAttachQuiltToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachQuiltToBuild400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachQuiltToBuild400JSONResponse) VisitAttachQuiltToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachQuiltToBuild403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachQuiltToBuild403JSONResponse) VisitAttachQuiltToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachQuiltToBuild404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachQuiltToBuild404JSONResponse) VisitAttachQuiltToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachQuiltToBuild412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachQuiltToBuild412JSONResponse) VisitAttachQuiltToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachQuiltToBuild422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachQuiltToBuild422JSONResponse) VisitAttachQuiltToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachQuiltToBuild500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachQuiltToBuild500JSONResponse) VisitAttachQuiltToBuildResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListUsersRequestObject struct {
	Params ListUsersParams
}

type ListUsersResponseObject interface {
	VisitListUsersResponse(w http.ResponseWriter) error
}

type ListUsers200JSONResponse struct{ UsersResponseJSONResponse }

func (response ListUsers200JSONResponse) VisitListUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListUsers403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListUsers403JSONResponse) VisitListUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListUsers500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListUsers500JSONResponse) VisitListUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateUserRequestObject struct {
	Body *CreateUserJSONRequestBody
}

type CreateUserResponseObject interface {
	VisitCreateUserResponse(w http.ResponseWriter) error
}

type CreateUser200JSONResponse struct{ UserResponseJSONResponse }

func (response CreateUser200JSONResponse) VisitCreateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateUser400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response CreateUser400JSONResponse) VisitCreateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response CreateUser403JSONResponse) VisitCreateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateUser422JSONResponse struct{ ValidationErrorJSONResponse }

func (response CreateUser422JSONResponse) VisitCreateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CreateUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreateUser500JSONResponse) VisitCreateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserRequestObject struct {
	UserID UserID `json:"user_id"`
}

type DeleteUserResponseObject interface {
	VisitDeleteUserResponse(w http.ResponseWriter) error
}

type DeleteUser200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteUser200JSONResponse) VisitDeleteUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUser400JSONResponse struct{ ActionFailedErrorJSONResponse }

func (response DeleteUser400JSONResponse) VisitDeleteUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteUser403JSONResponse) VisitDeleteUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteUser404JSONResponse) VisitDeleteUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteUser500JSONResponse) VisitDeleteUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ShowUserRequestObject struct {
	UserID UserID `json:"user_id"`
}

type ShowUserResponseObject interface {
	VisitShowUserResponse(w http.ResponseWriter) error
}

type ShowUser200JSONResponse struct{ UserResponseJSONResponse }

func (response ShowUser200JSONResponse) VisitShowUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ShowUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ShowUser403JSONResponse) VisitShowUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ShowUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ShowUser404JSONResponse) VisitShowUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ShowUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ShowUser500JSONResponse) VisitShowUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateUserRequestObject struct {
	UserID UserID `json:"user_id"`
	Body   *UpdateUserJSONRequestBody
}

type UpdateUserResponseObject interface {
	VisitUpdateUserResponse(w http.ResponseWriter) error
}

type UpdateUser200JSONResponse struct{ UserResponseJSONResponse }

func (response UpdateUser200JSONResponse) VisitUpdateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateUser400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response UpdateUser400JSONResponse) VisitUpdateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateUser403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response UpdateUser403JSONResponse) VisitUpdateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateUser404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response UpdateUser404JSONResponse) VisitUpdateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateUser422JSONResponse struct{ ValidationErrorJSONResponse }

func (response UpdateUser422JSONResponse) VisitUpdateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type UpdateUser500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response UpdateUser500JSONResponse) VisitUpdateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromGroupRequestObject struct {
	UserID UserID `json:"user_id"`
	Body   *DeleteUserFromGroupJSONRequestBody
}

type DeleteUserFromGroupResponseObject interface {
	VisitDeleteUserFromGroupResponse(w http.ResponseWriter) error
}

type DeleteUserFromGroup200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteUserFromGroup200JSONResponse) VisitDeleteUserFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromGroup400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteUserFromGroup400JSONResponse) VisitDeleteUserFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteUserFromGroup403JSONResponse) VisitDeleteUserFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteUserFromGroup404JSONResponse) VisitDeleteUserFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromGroup412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteUserFromGroup412JSONResponse) VisitDeleteUserFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteUserFromGroup500JSONResponse) VisitDeleteUserFromGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListUserGroupsRequestObject struct {
	UserID UserID `json:"user_id"`
	Params ListUserGroupsParams
}

type ListUserGroupsResponseObject interface {
	VisitListUserGroupsResponse(w http.ResponseWriter) error
}

type ListUserGroups200JSONResponse struct{ UserGroupsResponseJSONResponse }

func (response ListUserGroups200JSONResponse) VisitListUserGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListUserGroups403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListUserGroups403JSONResponse) VisitListUserGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListUserGroups404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListUserGroups404JSONResponse) VisitListUserGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListUserGroups500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListUserGroups500JSONResponse) VisitListUserGroupsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToGroupRequestObject struct {
	UserID UserID `json:"user_id"`
	Body   *AttachUserToGroupJSONRequestBody
}

type AttachUserToGroupResponseObject interface {
	VisitAttachUserToGroupResponse(w http.ResponseWriter) error
}

type AttachUserToGroup200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachUserToGroup200JSONResponse) VisitAttachUserToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToGroup400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachUserToGroup400JSONResponse) VisitAttachUserToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachUserToGroup403JSONResponse) VisitAttachUserToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachUserToGroup404JSONResponse) VisitAttachUserToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToGroup412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachUserToGroup412JSONResponse) VisitAttachUserToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToGroup422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachUserToGroup422JSONResponse) VisitAttachUserToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachUserToGroup500JSONResponse) VisitAttachUserToGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserGroupRequestObject struct {
	UserID UserID `json:"user_id"`
	Body   *PermitUserGroupJSONRequestBody
}

type PermitUserGroupResponseObject interface {
	VisitPermitUserGroupResponse(w http.ResponseWriter) error
}

type PermitUserGroup200JSONResponse struct{ SuccessMessageJSONResponse }

func (response PermitUserGroup200JSONResponse) VisitPermitUserGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserGroup400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PermitUserGroup400JSONResponse) VisitPermitUserGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserGroup403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response PermitUserGroup403JSONResponse) VisitPermitUserGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserGroup404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response PermitUserGroup404JSONResponse) VisitPermitUserGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserGroup412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response PermitUserGroup412JSONResponse) VisitPermitUserGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserGroup422JSONResponse struct{ ValidationErrorJSONResponse }

func (response PermitUserGroup422JSONResponse) VisitPermitUserGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserGroup500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response PermitUserGroup500JSONResponse) VisitPermitUserGroupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromModRequestObject struct {
	UserID UserID `json:"user_id"`
	Body   *DeleteUserFromModJSONRequestBody
}

type DeleteUserFromModResponseObject interface {
	VisitDeleteUserFromModResponse(w http.ResponseWriter) error
}

type DeleteUserFromMod200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteUserFromMod200JSONResponse) VisitDeleteUserFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromMod400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteUserFromMod400JSONResponse) VisitDeleteUserFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromMod403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteUserFromMod403JSONResponse) VisitDeleteUserFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromMod404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteUserFromMod404JSONResponse) VisitDeleteUserFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromMod412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteUserFromMod412JSONResponse) VisitDeleteUserFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromMod500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteUserFromMod500JSONResponse) VisitDeleteUserFromModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListUserModsRequestObject struct {
	UserID UserID `json:"user_id"`
	Params ListUserModsParams
}

type ListUserModsResponseObject interface {
	VisitListUserModsResponse(w http.ResponseWriter) error
}

type ListUserMods200JSONResponse struct{ UserModsResponseJSONResponse }

func (response ListUserMods200JSONResponse) VisitListUserModsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListUserMods403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListUserMods403JSONResponse) VisitListUserModsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListUserMods404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListUserMods404JSONResponse) VisitListUserModsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListUserMods500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListUserMods500JSONResponse) VisitListUserModsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToModRequestObject struct {
	UserID UserID `json:"user_id"`
	Body   *AttachUserToModJSONRequestBody
}

type AttachUserToModResponseObject interface {
	VisitAttachUserToModResponse(w http.ResponseWriter) error
}

type AttachUserToMod200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachUserToMod200JSONResponse) VisitAttachUserToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToMod400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachUserToMod400JSONResponse) VisitAttachUserToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToMod403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachUserToMod403JSONResponse) VisitAttachUserToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToMod404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachUserToMod404JSONResponse) VisitAttachUserToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToMod412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachUserToMod412JSONResponse) VisitAttachUserToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToMod422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachUserToMod422JSONResponse) VisitAttachUserToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToMod500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachUserToMod500JSONResponse) VisitAttachUserToModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserModRequestObject struct {
	UserID UserID `json:"user_id"`
	Body   *PermitUserModJSONRequestBody
}

type PermitUserModResponseObject interface {
	VisitPermitUserModResponse(w http.ResponseWriter) error
}

type PermitUserMod200JSONResponse struct{ SuccessMessageJSONResponse }

func (response PermitUserMod200JSONResponse) VisitPermitUserModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserMod400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PermitUserMod400JSONResponse) VisitPermitUserModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserMod403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response PermitUserMod403JSONResponse) VisitPermitUserModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserMod404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response PermitUserMod404JSONResponse) VisitPermitUserModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserMod412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response PermitUserMod412JSONResponse) VisitPermitUserModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserMod422JSONResponse struct{ ValidationErrorJSONResponse }

func (response PermitUserMod422JSONResponse) VisitPermitUserModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserMod500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response PermitUserMod500JSONResponse) VisitPermitUserModResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromPackRequestObject struct {
	UserID UserID `json:"user_id"`
	Body   *DeleteUserFromPackJSONRequestBody
}

type DeleteUserFromPackResponseObject interface {
	VisitDeleteUserFromPackResponse(w http.ResponseWriter) error
}

type DeleteUserFromPack200JSONResponse struct{ SuccessMessageJSONResponse }

func (response DeleteUserFromPack200JSONResponse) VisitDeleteUserFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromPack400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteUserFromPack400JSONResponse) VisitDeleteUserFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromPack403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response DeleteUserFromPack403JSONResponse) VisitDeleteUserFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromPack404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteUserFromPack404JSONResponse) VisitDeleteUserFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromPack412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response DeleteUserFromPack412JSONResponse) VisitDeleteUserFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserFromPack500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteUserFromPack500JSONResponse) VisitDeleteUserFromPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListUserPacksRequestObject struct {
	UserID UserID `json:"user_id"`
	Params ListUserPacksParams
}

type ListUserPacksResponseObject interface {
	VisitListUserPacksResponse(w http.ResponseWriter) error
}

type ListUserPacks200JSONResponse struct{ UserPacksResponseJSONResponse }

func (response ListUserPacks200JSONResponse) VisitListUserPacksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListUserPacks403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response ListUserPacks403JSONResponse) VisitListUserPacksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ListUserPacks404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListUserPacks404JSONResponse) VisitListUserPacksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListUserPacks500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListUserPacks500JSONResponse) VisitListUserPacksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToPackRequestObject struct {
	UserID UserID `json:"user_id"`
	Body   *AttachUserToPackJSONRequestBody
}

type AttachUserToPackResponseObject interface {
	VisitAttachUserToPackResponse(w http.ResponseWriter) error
}

type AttachUserToPack200JSONResponse struct{ SuccessMessageJSONResponse }

func (response AttachUserToPack200JSONResponse) VisitAttachUserToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToPack400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response AttachUserToPack400JSONResponse) VisitAttachUserToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToPack403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response AttachUserToPack403JSONResponse) VisitAttachUserToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToPack404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response AttachUserToPack404JSONResponse) VisitAttachUserToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToPack412JSONResponse struct {
	AlreadyAttachedErrorJSONResponse
}

func (response AttachUserToPack412JSONResponse) VisitAttachUserToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToPack422JSONResponse struct{ ValidationErrorJSONResponse }

func (response AttachUserToPack422JSONResponse) VisitAttachUserToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AttachUserToPack500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AttachUserToPack500JSONResponse) VisitAttachUserToPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserPackRequestObject struct {
	UserID UserID `json:"user_id"`
	Body   *PermitUserPackJSONRequestBody
}

type PermitUserPackResponseObject interface {
	VisitPermitUserPackResponse(w http.ResponseWriter) error
}

type PermitUserPack200JSONResponse struct{ SuccessMessageJSONResponse }

func (response PermitUserPack200JSONResponse) VisitPermitUserPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserPack400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PermitUserPack400JSONResponse) VisitPermitUserPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserPack403JSONResponse struct{ NotAuthorizedErrorJSONResponse }

func (response PermitUserPack403JSONResponse) VisitPermitUserPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserPack404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response PermitUserPack404JSONResponse) VisitPermitUserPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserPack412JSONResponse struct{ NotAttachedErrorJSONResponse }

func (response PermitUserPack412JSONResponse) VisitPermitUserPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserPack422JSONResponse struct{ ValidationErrorJSONResponse }

func (response PermitUserPack422JSONResponse) VisitPermitUserPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type PermitUserPack500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response PermitUserPack500JSONResponse) VisitPermitUserPackResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Authenticate an user by credentials
	// (POST /auth/login)
	LoginAuth(ctx context.Context, request LoginAuthRequestObject) (LoginAuthResponseObject, error)
	// Fetch the available auth providers
	// (GET /auth/providers)
	ListProviders(ctx context.Context, request ListProvidersRequestObject) (ListProvidersResponseObject, error)
	// Retrieve real token after redirect
	// (POST /auth/redirect)
	RedirectAuth(ctx context.Context, request RedirectAuthRequestObject) (RedirectAuthResponseObject, error)
	// Refresh an auth token before it expires
	// (GET /auth/refresh)
	RefreshAuth(ctx context.Context, request RefreshAuthRequestObject) (RefreshAuthResponseObject, error)
	// Verify validity for an authentication token
	// (GET /auth/verify)
	VerifyAuth(ctx context.Context, request VerifyAuthRequestObject) (VerifyAuthResponseObject, error)
	// Callback to parse the defined provider
	// (GET /auth/{provider}/callback)
	CallbackProvider(ctx context.Context, request CallbackProviderRequestObject) (CallbackProviderResponseObject, error)
	// Request the redirect to defined provider
	// (GET /auth/{provider}/request)
	RequestProvider(ctx context.Context, request RequestProviderRequestObject) (RequestProviderResponseObject, error)
	// Fetch the available Fabric versions
	// (GET /fabric)
	ListFabrics(ctx context.Context, request ListFabricsRequestObject) (ListFabricsResponseObject, error)
	// Update the available Fabric versions
	// (PUT /fabric)
	UpdateFabric(ctx context.Context, request UpdateFabricRequestObject) (UpdateFabricResponseObject, error)
	// Unlink a build from a Fabric version
	// (DELETE /fabric/{fabric_id}/builds)
	DeleteFabricFromBuild(ctx context.Context, request DeleteFabricFromBuildRequestObject) (DeleteFabricFromBuildResponseObject, error)
	// Fetch the builds attached to a Fabric version
	// (GET /fabric/{fabric_id}/builds)
	ListFabricBuilds(ctx context.Context, request ListFabricBuildsRequestObject) (ListFabricBuildsResponseObject, error)
	// Attach a build to a Fabric version
	// (POST /fabric/{fabric_id}/builds)
	AttachFabricToBuild(ctx context.Context, request AttachFabricToBuildRequestObject) (AttachFabricToBuildResponseObject, error)
	// Fetch the available Forge versions
	// (GET /forge)
	ListForges(ctx context.Context, request ListForgesRequestObject) (ListForgesResponseObject, error)
	// Update the available Forge versions
	// (PUT /forge)
	UpdateForge(ctx context.Context, request UpdateForgeRequestObject) (UpdateForgeResponseObject, error)
	// Unlink a build from a Forge version
	// (DELETE /forge/{forge_id}/builds)
	DeleteForgeFromBuild(ctx context.Context, request DeleteForgeFromBuildRequestObject) (DeleteForgeFromBuildResponseObject, error)
	// Fetch the builds attached to a Forge version
	// (GET /forge/{forge_id}/builds)
	ListForgeBuilds(ctx context.Context, request ListForgeBuildsRequestObject) (ListForgeBuildsResponseObject, error)
	// Attach a build to a Forge version
	// (POST /forge/{forge_id}/builds)
	AttachForgeToBuild(ctx context.Context, request AttachForgeToBuildRequestObject) (AttachForgeToBuildResponseObject, error)
	// Fetch all available groups
	// (GET /groups)
	ListGroups(ctx context.Context, request ListGroupsRequestObject) (ListGroupsResponseObject, error)
	// Create a new group
	// (POST /groups)
	CreateGroup(ctx context.Context, request CreateGroupRequestObject) (CreateGroupResponseObject, error)
	// Delete a specific group
	// (DELETE /groups/{group_id})
	DeleteGroup(ctx context.Context, request DeleteGroupRequestObject) (DeleteGroupResponseObject, error)
	// Fetch a specific group
	// (GET /groups/{group_id})
	ShowGroup(ctx context.Context, request ShowGroupRequestObject) (ShowGroupResponseObject, error)
	// Update a specific group
	// (PUT /groups/{group_id})
	UpdateGroup(ctx context.Context, request UpdateGroupRequestObject) (UpdateGroupResponseObject, error)
	// Unlink a mod from group
	// (DELETE /groups/{group_id}/mods)
	DeleteGroupFromMod(ctx context.Context, request DeleteGroupFromModRequestObject) (DeleteGroupFromModResponseObject, error)
	// Fetch all mods attached to group
	// (GET /groups/{group_id}/mods)
	ListGroupMods(ctx context.Context, request ListGroupModsRequestObject) (ListGroupModsResponseObject, error)
	// Attach a mod to group
	// (POST /groups/{group_id}/mods)
	AttachGroupToMod(ctx context.Context, request AttachGroupToModRequestObject) (AttachGroupToModResponseObject, error)
	// Update mod perms for group
	// (PUT /groups/{group_id}/mods)
	PermitGroupMod(ctx context.Context, request PermitGroupModRequestObject) (PermitGroupModResponseObject, error)
	// Unlink a pack from group
	// (DELETE /groups/{group_id}/packs)
	DeleteGroupFromPack(ctx context.Context, request DeleteGroupFromPackRequestObject) (DeleteGroupFromPackResponseObject, error)
	// Fetch all packs attached to group
	// (GET /groups/{group_id}/packs)
	ListGroupPacks(ctx context.Context, request ListGroupPacksRequestObject) (ListGroupPacksResponseObject, error)
	// Attach a pack to group
	// (POST /groups/{group_id}/packs)
	AttachGroupToPack(ctx context.Context, request AttachGroupToPackRequestObject) (AttachGroupToPackResponseObject, error)
	// Update pack perms for group
	// (PUT /groups/{group_id}/packs)
	PermitGroupPack(ctx context.Context, request PermitGroupPackRequestObject) (PermitGroupPackResponseObject, error)
	// Unlink a user from group
	// (DELETE /groups/{group_id}/users)
	DeleteGroupFromUser(ctx context.Context, request DeleteGroupFromUserRequestObject) (DeleteGroupFromUserResponseObject, error)
	// Fetch all users attached to group
	// (GET /groups/{group_id}/users)
	ListGroupUsers(ctx context.Context, request ListGroupUsersRequestObject) (ListGroupUsersResponseObject, error)
	// Attach a user to group
	// (POST /groups/{group_id}/users)
	AttachGroupToUser(ctx context.Context, request AttachGroupToUserRequestObject) (AttachGroupToUserResponseObject, error)
	// Update user perms for group
	// (PUT /groups/{group_id}/users)
	PermitGroupUser(ctx context.Context, request PermitGroupUserRequestObject) (PermitGroupUserResponseObject, error)
	// Fetch the available Minecraft versions
	// (GET /minecraft)
	ListMinecrafts(ctx context.Context, request ListMinecraftsRequestObject) (ListMinecraftsResponseObject, error)
	// Update the available Minecraft versions
	// (PUT /minecraft)
	UpdateMinecraft(ctx context.Context, request UpdateMinecraftRequestObject) (UpdateMinecraftResponseObject, error)
	// Unlink a build from a Minecraft version
	// (DELETE /minecraft/{minecraft_id}/builds)
	DeleteMinecraftFromBuild(ctx context.Context, request DeleteMinecraftFromBuildRequestObject) (DeleteMinecraftFromBuildResponseObject, error)
	// Fetch the builds attached to a Minecraft version
	// (GET /minecraft/{minecraft_id}/builds)
	ListMinecraftBuilds(ctx context.Context, request ListMinecraftBuildsRequestObject) (ListMinecraftBuildsResponseObject, error)
	// Attach a build to a Minecraft version
	// (POST /minecraft/{minecraft_id}/builds)
	AttachMinecraftToBuild(ctx context.Context, request AttachMinecraftToBuildRequestObject) (AttachMinecraftToBuildResponseObject, error)
	// Fetch all available mods
	// (GET /mods)
	ListMods(ctx context.Context, request ListModsRequestObject) (ListModsResponseObject, error)
	// Create a new mod
	// (POST /mods)
	CreateMod(ctx context.Context, request CreateModRequestObject) (CreateModResponseObject, error)
	// Delete a specific mod
	// (DELETE /mods/{mod_id})
	DeleteMod(ctx context.Context, request DeleteModRequestObject) (DeleteModResponseObject, error)
	// Fetch a specific mod
	// (GET /mods/{mod_id})
	ShowMod(ctx context.Context, request ShowModRequestObject) (ShowModResponseObject, error)
	// Update a specific mod
	// (PUT /mods/{mod_id})
	UpdateMod(ctx context.Context, request UpdateModRequestObject) (UpdateModResponseObject, error)
	// Delete the avatar for the defined mod
	// (DELETE /mods/{mod_id}/avatar)
	DeleteModAvatar(ctx context.Context, request DeleteModAvatarRequestObject) (DeleteModAvatarResponseObject, error)
	// Upload an avatar for the defined mod
	// (POST /mods/{mod_id}/avatar)
	CreateModAvatar(ctx context.Context, request CreateModAvatarRequestObject) (CreateModAvatarResponseObject, error)
	// Unlink a group from mod
	// (DELETE /mods/{mod_id}/groups)
	DeleteModFromGroup(ctx context.Context, request DeleteModFromGroupRequestObject) (DeleteModFromGroupResponseObject, error)
	// Fetch all groups attached to mod
	// (GET /mods/{mod_id}/groups)
	ListModGroups(ctx context.Context, request ListModGroupsRequestObject) (ListModGroupsResponseObject, error)
	// Attach a group to mod
	// (POST /mods/{mod_id}/groups)
	AttachModToGroup(ctx context.Context, request AttachModToGroupRequestObject) (AttachModToGroupResponseObject, error)
	// Update group perms for mod
	// (PUT /mods/{mod_id}/groups)
	PermitModGroup(ctx context.Context, request PermitModGroupRequestObject) (PermitModGroupResponseObject, error)
	// Unlink a user from mod
	// (DELETE /mods/{mod_id}/users)
	DeleteModFromUser(ctx context.Context, request DeleteModFromUserRequestObject) (DeleteModFromUserResponseObject, error)
	// Fetch all users attached to mod
	// (GET /mods/{mod_id}/users)
	ListModUsers(ctx context.Context, request ListModUsersRequestObject) (ListModUsersResponseObject, error)
	// Attach a user to mod
	// (POST /mods/{mod_id}/users)
	AttachModToUser(ctx context.Context, request AttachModToUserRequestObject) (AttachModToUserResponseObject, error)
	// Update user perms for mod
	// (PUT /mods/{mod_id}/users)
	PermitModUser(ctx context.Context, request PermitModUserRequestObject) (PermitModUserResponseObject, error)
	// Fetch all available versions for a mod
	// (GET /mods/{mod_id}/versions)
	ListVersions(ctx context.Context, request ListVersionsRequestObject) (ListVersionsResponseObject, error)
	// Create a new version for a mod
	// (POST /mods/{mod_id}/versions)
	CreateVersion(ctx context.Context, request CreateVersionRequestObject) (CreateVersionResponseObject, error)
	// Delete a specific version for a mod
	// (DELETE /mods/{mod_id}/versions/{version_id})
	DeleteVersion(ctx context.Context, request DeleteVersionRequestObject) (DeleteVersionResponseObject, error)
	// Fetch a specific version for a mod
	// (GET /mods/{mod_id}/versions/{version_id})
	ShowVersion(ctx context.Context, request ShowVersionRequestObject) (ShowVersionResponseObject, error)
	// Update a specific version for a mod
	// (PUT /mods/{mod_id}/versions/{version_id})
	UpdateVersion(ctx context.Context, request UpdateVersionRequestObject) (UpdateVersionResponseObject, error)
	// Unlink a build from a version
	// (DELETE /mods/{mod_id}/versions/{version_id}/builds)
	DeleteVersionFromBuild(ctx context.Context, request DeleteVersionFromBuildRequestObject) (DeleteVersionFromBuildResponseObject, error)
	// Fetch all builds attached to version
	// (GET /mods/{mod_id}/versions/{version_id}/builds)
	ListVersionBuilds(ctx context.Context, request ListVersionBuildsRequestObject) (ListVersionBuildsResponseObject, error)
	// Attach a build to a version
	// (POST /mods/{mod_id}/versions/{version_id}/builds)
	AttachVersionToBuild(ctx context.Context, request AttachVersionToBuildRequestObject) (AttachVersionToBuildResponseObject, error)
	// Fetch the available Neoforge versions
	// (GET /neoforge)
	ListNeoforges(ctx context.Context, request ListNeoforgesRequestObject) (ListNeoforgesResponseObject, error)
	// Update the available Neoforge versions
	// (PUT /neoforge)
	UpdateNeoforge(ctx context.Context, request UpdateNeoforgeRequestObject) (UpdateNeoforgeResponseObject, error)
	// Unlink a build from a Neoforge version
	// (DELETE /neoforge/{neoforge_id}/builds)
	DeleteNeoforgeFromBuild(ctx context.Context, request DeleteNeoforgeFromBuildRequestObject) (DeleteNeoforgeFromBuildResponseObject, error)
	// Fetch the builds attached to a Neoforge version
	// (GET /neoforge/{neoforge_id}/builds)
	ListNeoforgeBuilds(ctx context.Context, request ListNeoforgeBuildsRequestObject) (ListNeoforgeBuildsResponseObject, error)
	// Attach a build to a Neoforge version
	// (POST /neoforge/{neoforge_id}/builds)
	AttachNeoforgeToBuild(ctx context.Context, request AttachNeoforgeToBuildRequestObject) (AttachNeoforgeToBuildResponseObject, error)
	// Fetch all available packs
	// (GET /packs)
	ListPacks(ctx context.Context, request ListPacksRequestObject) (ListPacksResponseObject, error)
	// Create a new pack
	// (POST /packs)
	CreatePack(ctx context.Context, request CreatePackRequestObject) (CreatePackResponseObject, error)
	// Delete a specific pack
	// (DELETE /packs/{pack_id})
	DeletePack(ctx context.Context, request DeletePackRequestObject) (DeletePackResponseObject, error)
	// Fetch a specific pack
	// (GET /packs/{pack_id})
	ShowPack(ctx context.Context, request ShowPackRequestObject) (ShowPackResponseObject, error)
	// Update a specific pack
	// (PUT /packs/{pack_id})
	UpdatePack(ctx context.Context, request UpdatePackRequestObject) (UpdatePackResponseObject, error)
	// Delete the avatar for the defined pack
	// (DELETE /packs/{pack_id}/avatar)
	DeletePackAvatar(ctx context.Context, request DeletePackAvatarRequestObject) (DeletePackAvatarResponseObject, error)
	// Upload an avatar for the defined pack
	// (POST /packs/{pack_id}/avatar)
	CreatePackAvatar(ctx context.Context, request CreatePackAvatarRequestObject) (CreatePackAvatarResponseObject, error)
	// Fetch all available builds for a pack
	// (GET /packs/{pack_id}/builds)
	ListBuilds(ctx context.Context, request ListBuildsRequestObject) (ListBuildsResponseObject, error)
	// Create a new build for a pack
	// (POST /packs/{pack_id}/builds)
	CreateBuild(ctx context.Context, request CreateBuildRequestObject) (CreateBuildResponseObject, error)
	// Delete a specific build for a pack
	// (DELETE /packs/{pack_id}/builds/{build_id})
	DeleteBuild(ctx context.Context, request DeleteBuildRequestObject) (DeleteBuildResponseObject, error)
	// Fetch a specific build for a pack
	// (GET /packs/{pack_id}/builds/{build_id})
	ShowBuild(ctx context.Context, request ShowBuildRequestObject) (ShowBuildResponseObject, error)
	// Update a specific build for a pack
	// (PUT /packs/{pack_id}/builds/{build_id})
	UpdateBuild(ctx context.Context, request UpdateBuildRequestObject) (UpdateBuildResponseObject, error)
	// Unlink a version from a build
	// (DELETE /packs/{pack_id}/builds/{build_id}/versions)
	DeleteBuildFromVersion(ctx context.Context, request DeleteBuildFromVersionRequestObject) (DeleteBuildFromVersionResponseObject, error)
	// Fetch all versions attached to build
	// (GET /packs/{pack_id}/builds/{build_id}/versions)
	ListBuildVersions(ctx context.Context, request ListBuildVersionsRequestObject) (ListBuildVersionsResponseObject, error)
	// Attach a version to a build
	// (POST /packs/{pack_id}/builds/{build_id}/versions)
	AttachBuildToVersion(ctx context.Context, request AttachBuildToVersionRequestObject) (AttachBuildToVersionResponseObject, error)
	// Unlink a group from pack
	// (DELETE /packs/{pack_id}/groups)
	DeletePackFromGroup(ctx context.Context, request DeletePackFromGroupRequestObject) (DeletePackFromGroupResponseObject, error)
	// Fetch all groups attached to pack
	// (GET /packs/{pack_id}/groups)
	ListPackGroups(ctx context.Context, request ListPackGroupsRequestObject) (ListPackGroupsResponseObject, error)
	// Attach a group to pack
	// (POST /packs/{pack_id}/groups)
	AttachPackToGroup(ctx context.Context, request AttachPackToGroupRequestObject) (AttachPackToGroupResponseObject, error)
	// Update group perms for pack
	// (PUT /packs/{pack_id}/groups)
	PermitPackGroup(ctx context.Context, request PermitPackGroupRequestObject) (PermitPackGroupResponseObject, error)
	// Unlink a user from pack
	// (DELETE /packs/{pack_id}/users)
	DeletePackFromUser(ctx context.Context, request DeletePackFromUserRequestObject) (DeletePackFromUserResponseObject, error)
	// Fetch all users attached to pack
	// (GET /packs/{pack_id}/users)
	ListPackUsers(ctx context.Context, request ListPackUsersRequestObject) (ListPackUsersResponseObject, error)
	// Attach a user to pack
	// (POST /packs/{pack_id}/users)
	AttachPackToUser(ctx context.Context, request AttachPackToUserRequestObject) (AttachPackToUserResponseObject, error)
	// Update user perms for pack
	// (PUT /packs/{pack_id}/users)
	PermitPackUser(ctx context.Context, request PermitPackUserRequestObject) (PermitPackUserResponseObject, error)
	// Fetch profile details of the personal account
	// (GET /profile/self)
	ShowProfile(ctx context.Context, request ShowProfileRequestObject) (ShowProfileResponseObject, error)
	// Update your own profile information
	// (PUT /profile/self)
	UpdateProfile(ctx context.Context, request UpdateProfileRequestObject) (UpdateProfileResponseObject, error)
	// Retrieve an unlimited auth token
	// (GET /profile/token)
	TokenProfile(ctx context.Context, request TokenProfileRequestObject) (TokenProfileResponseObject, error)
	// Fetch the available Quilt versions
	// (GET /quilt)
	ListQuilts(ctx context.Context, request ListQuiltsRequestObject) (ListQuiltsResponseObject, error)
	// Update the available Quilt versions
	// (PUT /quilt)
	UpdateQuilt(ctx context.Context, request UpdateQuiltRequestObject) (UpdateQuiltResponseObject, error)
	// Unlink a build from a Quilt version
	// (DELETE /quilt/{quilt_id}/builds)
	DeleteQuiltFromBuild(ctx context.Context, request DeleteQuiltFromBuildRequestObject) (DeleteQuiltFromBuildResponseObject, error)
	// Fetch the builds attached to a Quilt version
	// (GET /quilt/{quilt_id}/builds)
	ListQuiltBuilds(ctx context.Context, request ListQuiltBuildsRequestObject) (ListQuiltBuildsResponseObject, error)
	// Attach a build to a Quilt version
	// (POST /quilt/{quilt_id}/builds)
	AttachQuiltToBuild(ctx context.Context, request AttachQuiltToBuildRequestObject) (AttachQuiltToBuildResponseObject, error)
	// Fetch all available users
	// (GET /users)
	ListUsers(ctx context.Context, request ListUsersRequestObject) (ListUsersResponseObject, error)
	// Create a new user
	// (POST /users)
	CreateUser(ctx context.Context, request CreateUserRequestObject) (CreateUserResponseObject, error)
	// Delete a specific user
	// (DELETE /users/{user_id})
	DeleteUser(ctx context.Context, request DeleteUserRequestObject) (DeleteUserResponseObject, error)
	// Fetch a specific user
	// (GET /users/{user_id})
	ShowUser(ctx context.Context, request ShowUserRequestObject) (ShowUserResponseObject, error)
	// Update a specific user
	// (PUT /users/{user_id})
	UpdateUser(ctx context.Context, request UpdateUserRequestObject) (UpdateUserResponseObject, error)
	// Unlink a group from user
	// (DELETE /users/{user_id}/groups)
	DeleteUserFromGroup(ctx context.Context, request DeleteUserFromGroupRequestObject) (DeleteUserFromGroupResponseObject, error)
	// Fetch all groups attached to user
	// (GET /users/{user_id}/groups)
	ListUserGroups(ctx context.Context, request ListUserGroupsRequestObject) (ListUserGroupsResponseObject, error)
	// Attach a group to user
	// (POST /users/{user_id}/groups)
	AttachUserToGroup(ctx context.Context, request AttachUserToGroupRequestObject) (AttachUserToGroupResponseObject, error)
	// Update group perms for user
	// (PUT /users/{user_id}/groups)
	PermitUserGroup(ctx context.Context, request PermitUserGroupRequestObject) (PermitUserGroupResponseObject, error)
	// Unlink a mod from user
	// (DELETE /users/{user_id}/mods)
	DeleteUserFromMod(ctx context.Context, request DeleteUserFromModRequestObject) (DeleteUserFromModResponseObject, error)
	// Fetch all mods attached to user
	// (GET /users/{user_id}/mods)
	ListUserMods(ctx context.Context, request ListUserModsRequestObject) (ListUserModsResponseObject, error)
	// Attach a mod to user
	// (POST /users/{user_id}/mods)
	AttachUserToMod(ctx context.Context, request AttachUserToModRequestObject) (AttachUserToModResponseObject, error)
	// Update mod perms for user
	// (PUT /users/{user_id}/mods)
	PermitUserMod(ctx context.Context, request PermitUserModRequestObject) (PermitUserModResponseObject, error)
	// Unlink a pack from user
	// (DELETE /users/{user_id}/packs)
	DeleteUserFromPack(ctx context.Context, request DeleteUserFromPackRequestObject) (DeleteUserFromPackResponseObject, error)
	// Fetch all packs attached to user
	// (GET /users/{user_id}/packs)
	ListUserPacks(ctx context.Context, request ListUserPacksRequestObject) (ListUserPacksResponseObject, error)
	// Attach a pack to user
	// (POST /users/{user_id}/packs)
	AttachUserToPack(ctx context.Context, request AttachUserToPackRequestObject) (AttachUserToPackResponseObject, error)
	// Update pack perms for user
	// (PUT /users/{user_id}/packs)
	PermitUserPack(ctx context.Context, request PermitUserPackRequestObject) (PermitUserPackResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// LoginAuth operation middleware
func (sh *strictHandler) LoginAuth(w http.ResponseWriter, r *http.Request) {
	var request LoginAuthRequestObject

	var body LoginAuthJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.LoginAuth(ctx, request.(LoginAuthRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "LoginAuth")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(LoginAuthResponseObject); ok {
		if err := validResponse.VisitLoginAuthResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListProviders operation middleware
func (sh *strictHandler) ListProviders(w http.ResponseWriter, r *http.Request) {
	var request ListProvidersRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListProviders(ctx, request.(ListProvidersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListProviders")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListProvidersResponseObject); ok {
		if err := validResponse.VisitListProvidersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RedirectAuth operation middleware
func (sh *strictHandler) RedirectAuth(w http.ResponseWriter, r *http.Request) {
	var request RedirectAuthRequestObject

	var body RedirectAuthJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RedirectAuth(ctx, request.(RedirectAuthRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RedirectAuth")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RedirectAuthResponseObject); ok {
		if err := validResponse.VisitRedirectAuthResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RefreshAuth operation middleware
func (sh *strictHandler) RefreshAuth(w http.ResponseWriter, r *http.Request) {
	var request RefreshAuthRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RefreshAuth(ctx, request.(RefreshAuthRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RefreshAuth")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RefreshAuthResponseObject); ok {
		if err := validResponse.VisitRefreshAuthResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// VerifyAuth operation middleware
func (sh *strictHandler) VerifyAuth(w http.ResponseWriter, r *http.Request) {
	var request VerifyAuthRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.VerifyAuth(ctx, request.(VerifyAuthRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "VerifyAuth")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(VerifyAuthResponseObject); ok {
		if err := validResponse.VisitVerifyAuthResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CallbackProvider operation middleware
func (sh *strictHandler) CallbackProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam, params CallbackProviderParams) {
	var request CallbackProviderRequestObject

	request.Provider = provider
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CallbackProvider(ctx, request.(CallbackProviderRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CallbackProvider")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CallbackProviderResponseObject); ok {
		if err := validResponse.VisitCallbackProviderResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RequestProvider operation middleware
func (sh *strictHandler) RequestProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam) {
	var request RequestProviderRequestObject

	request.Provider = provider

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RequestProvider(ctx, request.(RequestProviderRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RequestProvider")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RequestProviderResponseObject); ok {
		if err := validResponse.VisitRequestProviderResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListFabrics operation middleware
func (sh *strictHandler) ListFabrics(w http.ResponseWriter, r *http.Request, params ListFabricsParams) {
	var request ListFabricsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListFabrics(ctx, request.(ListFabricsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListFabrics")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListFabricsResponseObject); ok {
		if err := validResponse.VisitListFabricsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateFabric operation middleware
func (sh *strictHandler) UpdateFabric(w http.ResponseWriter, r *http.Request) {
	var request UpdateFabricRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateFabric(ctx, request.(UpdateFabricRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateFabric")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateFabricResponseObject); ok {
		if err := validResponse.VisitUpdateFabricResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteFabricFromBuild operation middleware
func (sh *strictHandler) DeleteFabricFromBuild(w http.ResponseWriter, r *http.Request, fabricID FabricID) {
	var request DeleteFabricFromBuildRequestObject

	request.FabricID = fabricID

	var body DeleteFabricFromBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteFabricFromBuild(ctx, request.(DeleteFabricFromBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteFabricFromBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteFabricFromBuildResponseObject); ok {
		if err := validResponse.VisitDeleteFabricFromBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListFabricBuilds operation middleware
func (sh *strictHandler) ListFabricBuilds(w http.ResponseWriter, r *http.Request, fabricID FabricID, params ListFabricBuildsParams) {
	var request ListFabricBuildsRequestObject

	request.FabricID = fabricID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListFabricBuilds(ctx, request.(ListFabricBuildsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListFabricBuilds")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListFabricBuildsResponseObject); ok {
		if err := validResponse.VisitListFabricBuildsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachFabricToBuild operation middleware
func (sh *strictHandler) AttachFabricToBuild(w http.ResponseWriter, r *http.Request, fabricID FabricID) {
	var request AttachFabricToBuildRequestObject

	request.FabricID = fabricID

	var body AttachFabricToBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachFabricToBuild(ctx, request.(AttachFabricToBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachFabricToBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachFabricToBuildResponseObject); ok {
		if err := validResponse.VisitAttachFabricToBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListForges operation middleware
func (sh *strictHandler) ListForges(w http.ResponseWriter, r *http.Request, params ListForgesParams) {
	var request ListForgesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListForges(ctx, request.(ListForgesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListForges")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListForgesResponseObject); ok {
		if err := validResponse.VisitListForgesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateForge operation middleware
func (sh *strictHandler) UpdateForge(w http.ResponseWriter, r *http.Request) {
	var request UpdateForgeRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateForge(ctx, request.(UpdateForgeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateForge")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateForgeResponseObject); ok {
		if err := validResponse.VisitUpdateForgeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteForgeFromBuild operation middleware
func (sh *strictHandler) DeleteForgeFromBuild(w http.ResponseWriter, r *http.Request, forgeID ForgeID) {
	var request DeleteForgeFromBuildRequestObject

	request.ForgeID = forgeID

	var body DeleteForgeFromBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteForgeFromBuild(ctx, request.(DeleteForgeFromBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteForgeFromBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteForgeFromBuildResponseObject); ok {
		if err := validResponse.VisitDeleteForgeFromBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListForgeBuilds operation middleware
func (sh *strictHandler) ListForgeBuilds(w http.ResponseWriter, r *http.Request, forgeID ForgeID, params ListForgeBuildsParams) {
	var request ListForgeBuildsRequestObject

	request.ForgeID = forgeID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListForgeBuilds(ctx, request.(ListForgeBuildsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListForgeBuilds")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListForgeBuildsResponseObject); ok {
		if err := validResponse.VisitListForgeBuildsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachForgeToBuild operation middleware
func (sh *strictHandler) AttachForgeToBuild(w http.ResponseWriter, r *http.Request, forgeID ForgeID) {
	var request AttachForgeToBuildRequestObject

	request.ForgeID = forgeID

	var body AttachForgeToBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachForgeToBuild(ctx, request.(AttachForgeToBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachForgeToBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachForgeToBuildResponseObject); ok {
		if err := validResponse.VisitAttachForgeToBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListGroups operation middleware
func (sh *strictHandler) ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams) {
	var request ListGroupsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListGroups(ctx, request.(ListGroupsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListGroups")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListGroupsResponseObject); ok {
		if err := validResponse.VisitListGroupsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateGroup operation middleware
func (sh *strictHandler) CreateGroup(w http.ResponseWriter, r *http.Request) {
	var request CreateGroupRequestObject

	var body CreateGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateGroup(ctx, request.(CreateGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateGroupResponseObject); ok {
		if err := validResponse.VisitCreateGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteGroup operation middleware
func (sh *strictHandler) DeleteGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request DeleteGroupRequestObject

	request.GroupID = groupID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteGroup(ctx, request.(DeleteGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteGroupResponseObject); ok {
		if err := validResponse.VisitDeleteGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ShowGroup operation middleware
func (sh *strictHandler) ShowGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request ShowGroupRequestObject

	request.GroupID = groupID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ShowGroup(ctx, request.(ShowGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ShowGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ShowGroupResponseObject); ok {
		if err := validResponse.VisitShowGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateGroup operation middleware
func (sh *strictHandler) UpdateGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request UpdateGroupRequestObject

	request.GroupID = groupID

	var body UpdateGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateGroup(ctx, request.(UpdateGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateGroupResponseObject); ok {
		if err := validResponse.VisitUpdateGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteGroupFromMod operation middleware
func (sh *strictHandler) DeleteGroupFromMod(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request DeleteGroupFromModRequestObject

	request.GroupID = groupID

	var body DeleteGroupFromModJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteGroupFromMod(ctx, request.(DeleteGroupFromModRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteGroupFromMod")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteGroupFromModResponseObject); ok {
		if err := validResponse.VisitDeleteGroupFromModResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListGroupMods operation middleware
func (sh *strictHandler) ListGroupMods(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupModsParams) {
	var request ListGroupModsRequestObject

	request.GroupID = groupID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListGroupMods(ctx, request.(ListGroupModsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListGroupMods")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListGroupModsResponseObject); ok {
		if err := validResponse.VisitListGroupModsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachGroupToMod operation middleware
func (sh *strictHandler) AttachGroupToMod(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request AttachGroupToModRequestObject

	request.GroupID = groupID

	var body AttachGroupToModJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachGroupToMod(ctx, request.(AttachGroupToModRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachGroupToMod")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachGroupToModResponseObject); ok {
		if err := validResponse.VisitAttachGroupToModResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PermitGroupMod operation middleware
func (sh *strictHandler) PermitGroupMod(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request PermitGroupModRequestObject

	request.GroupID = groupID

	var body PermitGroupModJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PermitGroupMod(ctx, request.(PermitGroupModRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PermitGroupMod")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PermitGroupModResponseObject); ok {
		if err := validResponse.VisitPermitGroupModResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteGroupFromPack operation middleware
func (sh *strictHandler) DeleteGroupFromPack(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request DeleteGroupFromPackRequestObject

	request.GroupID = groupID

	var body DeleteGroupFromPackJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteGroupFromPack(ctx, request.(DeleteGroupFromPackRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteGroupFromPack")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteGroupFromPackResponseObject); ok {
		if err := validResponse.VisitDeleteGroupFromPackResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListGroupPacks operation middleware
func (sh *strictHandler) ListGroupPacks(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupPacksParams) {
	var request ListGroupPacksRequestObject

	request.GroupID = groupID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListGroupPacks(ctx, request.(ListGroupPacksRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListGroupPacks")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListGroupPacksResponseObject); ok {
		if err := validResponse.VisitListGroupPacksResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachGroupToPack operation middleware
func (sh *strictHandler) AttachGroupToPack(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request AttachGroupToPackRequestObject

	request.GroupID = groupID

	var body AttachGroupToPackJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachGroupToPack(ctx, request.(AttachGroupToPackRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachGroupToPack")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachGroupToPackResponseObject); ok {
		if err := validResponse.VisitAttachGroupToPackResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PermitGroupPack operation middleware
func (sh *strictHandler) PermitGroupPack(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request PermitGroupPackRequestObject

	request.GroupID = groupID

	var body PermitGroupPackJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PermitGroupPack(ctx, request.(PermitGroupPackRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PermitGroupPack")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PermitGroupPackResponseObject); ok {
		if err := validResponse.VisitPermitGroupPackResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteGroupFromUser operation middleware
func (sh *strictHandler) DeleteGroupFromUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request DeleteGroupFromUserRequestObject

	request.GroupID = groupID

	var body DeleteGroupFromUserJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteGroupFromUser(ctx, request.(DeleteGroupFromUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteGroupFromUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteGroupFromUserResponseObject); ok {
		if err := validResponse.VisitDeleteGroupFromUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListGroupUsers operation middleware
func (sh *strictHandler) ListGroupUsers(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupUsersParams) {
	var request ListGroupUsersRequestObject

	request.GroupID = groupID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListGroupUsers(ctx, request.(ListGroupUsersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListGroupUsers")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListGroupUsersResponseObject); ok {
		if err := validResponse.VisitListGroupUsersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachGroupToUser operation middleware
func (sh *strictHandler) AttachGroupToUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request AttachGroupToUserRequestObject

	request.GroupID = groupID

	var body AttachGroupToUserJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachGroupToUser(ctx, request.(AttachGroupToUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachGroupToUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachGroupToUserResponseObject); ok {
		if err := validResponse.VisitAttachGroupToUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PermitGroupUser operation middleware
func (sh *strictHandler) PermitGroupUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	var request PermitGroupUserRequestObject

	request.GroupID = groupID

	var body PermitGroupUserJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PermitGroupUser(ctx, request.(PermitGroupUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PermitGroupUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PermitGroupUserResponseObject); ok {
		if err := validResponse.VisitPermitGroupUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListMinecrafts operation middleware
func (sh *strictHandler) ListMinecrafts(w http.ResponseWriter, r *http.Request, params ListMinecraftsParams) {
	var request ListMinecraftsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListMinecrafts(ctx, request.(ListMinecraftsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListMinecrafts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListMinecraftsResponseObject); ok {
		if err := validResponse.VisitListMinecraftsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateMinecraft operation middleware
func (sh *strictHandler) UpdateMinecraft(w http.ResponseWriter, r *http.Request) {
	var request UpdateMinecraftRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateMinecraft(ctx, request.(UpdateMinecraftRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateMinecraft")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateMinecraftResponseObject); ok {
		if err := validResponse.VisitUpdateMinecraftResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteMinecraftFromBuild operation middleware
func (sh *strictHandler) DeleteMinecraftFromBuild(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID) {
	var request DeleteMinecraftFromBuildRequestObject

	request.MinecraftID = minecraftID

	var body DeleteMinecraftFromBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteMinecraftFromBuild(ctx, request.(DeleteMinecraftFromBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteMinecraftFromBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteMinecraftFromBuildResponseObject); ok {
		if err := validResponse.VisitDeleteMinecraftFromBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListMinecraftBuilds operation middleware
func (sh *strictHandler) ListMinecraftBuilds(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID, params ListMinecraftBuildsParams) {
	var request ListMinecraftBuildsRequestObject

	request.MinecraftID = minecraftID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListMinecraftBuilds(ctx, request.(ListMinecraftBuildsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListMinecraftBuilds")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListMinecraftBuildsResponseObject); ok {
		if err := validResponse.VisitListMinecraftBuildsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachMinecraftToBuild operation middleware
func (sh *strictHandler) AttachMinecraftToBuild(w http.ResponseWriter, r *http.Request, minecraftID MinecraftID) {
	var request AttachMinecraftToBuildRequestObject

	request.MinecraftID = minecraftID

	var body AttachMinecraftToBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachMinecraftToBuild(ctx, request.(AttachMinecraftToBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachMinecraftToBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachMinecraftToBuildResponseObject); ok {
		if err := validResponse.VisitAttachMinecraftToBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListMods operation middleware
func (sh *strictHandler) ListMods(w http.ResponseWriter, r *http.Request, params ListModsParams) {
	var request ListModsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListMods(ctx, request.(ListModsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListMods")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListModsResponseObject); ok {
		if err := validResponse.VisitListModsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateMod operation middleware
func (sh *strictHandler) CreateMod(w http.ResponseWriter, r *http.Request) {
	var request CreateModRequestObject

	var body CreateModJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateMod(ctx, request.(CreateModRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateMod")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateModResponseObject); ok {
		if err := validResponse.VisitCreateModResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteMod operation middleware
func (sh *strictHandler) DeleteMod(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request DeleteModRequestObject

	request.ModID = modID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteMod(ctx, request.(DeleteModRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteMod")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteModResponseObject); ok {
		if err := validResponse.VisitDeleteModResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ShowMod operation middleware
func (sh *strictHandler) ShowMod(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request ShowModRequestObject

	request.ModID = modID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ShowMod(ctx, request.(ShowModRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ShowMod")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ShowModResponseObject); ok {
		if err := validResponse.VisitShowModResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateMod operation middleware
func (sh *strictHandler) UpdateMod(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request UpdateModRequestObject

	request.ModID = modID

	var body UpdateModJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateMod(ctx, request.(UpdateModRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateMod")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateModResponseObject); ok {
		if err := validResponse.VisitUpdateModResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteModAvatar operation middleware
func (sh *strictHandler) DeleteModAvatar(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request DeleteModAvatarRequestObject

	request.ModID = modID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteModAvatar(ctx, request.(DeleteModAvatarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteModAvatar")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteModAvatarResponseObject); ok {
		if err := validResponse.VisitDeleteModAvatarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateModAvatar operation middleware
func (sh *strictHandler) CreateModAvatar(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request CreateModAvatarRequestObject

	request.ModID = modID

	if reader, err := r.MultipartReader(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode multipart body: %w", err))
		return
	} else {
		request.Body = reader
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateModAvatar(ctx, request.(CreateModAvatarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateModAvatar")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateModAvatarResponseObject); ok {
		if err := validResponse.VisitCreateModAvatarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteModFromGroup operation middleware
func (sh *strictHandler) DeleteModFromGroup(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request DeleteModFromGroupRequestObject

	request.ModID = modID

	var body DeleteModFromGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteModFromGroup(ctx, request.(DeleteModFromGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteModFromGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteModFromGroupResponseObject); ok {
		if err := validResponse.VisitDeleteModFromGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListModGroups operation middleware
func (sh *strictHandler) ListModGroups(w http.ResponseWriter, r *http.Request, modID ModID, params ListModGroupsParams) {
	var request ListModGroupsRequestObject

	request.ModID = modID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListModGroups(ctx, request.(ListModGroupsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListModGroups")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListModGroupsResponseObject); ok {
		if err := validResponse.VisitListModGroupsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachModToGroup operation middleware
func (sh *strictHandler) AttachModToGroup(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request AttachModToGroupRequestObject

	request.ModID = modID

	var body AttachModToGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachModToGroup(ctx, request.(AttachModToGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachModToGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachModToGroupResponseObject); ok {
		if err := validResponse.VisitAttachModToGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PermitModGroup operation middleware
func (sh *strictHandler) PermitModGroup(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request PermitModGroupRequestObject

	request.ModID = modID

	var body PermitModGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PermitModGroup(ctx, request.(PermitModGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PermitModGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PermitModGroupResponseObject); ok {
		if err := validResponse.VisitPermitModGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteModFromUser operation middleware
func (sh *strictHandler) DeleteModFromUser(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request DeleteModFromUserRequestObject

	request.ModID = modID

	var body DeleteModFromUserJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteModFromUser(ctx, request.(DeleteModFromUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteModFromUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteModFromUserResponseObject); ok {
		if err := validResponse.VisitDeleteModFromUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListModUsers operation middleware
func (sh *strictHandler) ListModUsers(w http.ResponseWriter, r *http.Request, modID ModID, params ListModUsersParams) {
	var request ListModUsersRequestObject

	request.ModID = modID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListModUsers(ctx, request.(ListModUsersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListModUsers")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListModUsersResponseObject); ok {
		if err := validResponse.VisitListModUsersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachModToUser operation middleware
func (sh *strictHandler) AttachModToUser(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request AttachModToUserRequestObject

	request.ModID = modID

	var body AttachModToUserJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachModToUser(ctx, request.(AttachModToUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachModToUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachModToUserResponseObject); ok {
		if err := validResponse.VisitAttachModToUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PermitModUser operation middleware
func (sh *strictHandler) PermitModUser(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request PermitModUserRequestObject

	request.ModID = modID

	var body PermitModUserJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PermitModUser(ctx, request.(PermitModUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PermitModUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PermitModUserResponseObject); ok {
		if err := validResponse.VisitPermitModUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListVersions operation middleware
func (sh *strictHandler) ListVersions(w http.ResponseWriter, r *http.Request, modID ModID, params ListVersionsParams) {
	var request ListVersionsRequestObject

	request.ModID = modID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListVersions(ctx, request.(ListVersionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListVersions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListVersionsResponseObject); ok {
		if err := validResponse.VisitListVersionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateVersion operation middleware
func (sh *strictHandler) CreateVersion(w http.ResponseWriter, r *http.Request, modID ModID) {
	var request CreateVersionRequestObject

	request.ModID = modID

	var body CreateVersionJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateVersion(ctx, request.(CreateVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateVersion")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateVersionResponseObject); ok {
		if err := validResponse.VisitCreateVersionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteVersion operation middleware
func (sh *strictHandler) DeleteVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	var request DeleteVersionRequestObject

	request.ModID = modID
	request.VersionID = versionID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteVersion(ctx, request.(DeleteVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteVersion")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteVersionResponseObject); ok {
		if err := validResponse.VisitDeleteVersionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ShowVersion operation middleware
func (sh *strictHandler) ShowVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	var request ShowVersionRequestObject

	request.ModID = modID
	request.VersionID = versionID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ShowVersion(ctx, request.(ShowVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ShowVersion")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ShowVersionResponseObject); ok {
		if err := validResponse.VisitShowVersionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateVersion operation middleware
func (sh *strictHandler) UpdateVersion(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	var request UpdateVersionRequestObject

	request.ModID = modID
	request.VersionID = versionID

	var body UpdateVersionJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateVersion(ctx, request.(UpdateVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateVersion")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateVersionResponseObject); ok {
		if err := validResponse.VisitUpdateVersionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteVersionFromBuild operation middleware
func (sh *strictHandler) DeleteVersionFromBuild(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	var request DeleteVersionFromBuildRequestObject

	request.ModID = modID
	request.VersionID = versionID

	var body DeleteVersionFromBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteVersionFromBuild(ctx, request.(DeleteVersionFromBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteVersionFromBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteVersionFromBuildResponseObject); ok {
		if err := validResponse.VisitDeleteVersionFromBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListVersionBuilds operation middleware
func (sh *strictHandler) ListVersionBuilds(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID, params ListVersionBuildsParams) {
	var request ListVersionBuildsRequestObject

	request.ModID = modID
	request.VersionID = versionID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListVersionBuilds(ctx, request.(ListVersionBuildsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListVersionBuilds")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListVersionBuildsResponseObject); ok {
		if err := validResponse.VisitListVersionBuildsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachVersionToBuild operation middleware
func (sh *strictHandler) AttachVersionToBuild(w http.ResponseWriter, r *http.Request, modID ModID, versionID VersionID) {
	var request AttachVersionToBuildRequestObject

	request.ModID = modID
	request.VersionID = versionID

	var body AttachVersionToBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachVersionToBuild(ctx, request.(AttachVersionToBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachVersionToBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachVersionToBuildResponseObject); ok {
		if err := validResponse.VisitAttachVersionToBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListNeoforges operation middleware
func (sh *strictHandler) ListNeoforges(w http.ResponseWriter, r *http.Request, params ListNeoforgesParams) {
	var request ListNeoforgesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListNeoforges(ctx, request.(ListNeoforgesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListNeoforges")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListNeoforgesResponseObject); ok {
		if err := validResponse.VisitListNeoforgesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateNeoforge operation middleware
func (sh *strictHandler) UpdateNeoforge(w http.ResponseWriter, r *http.Request) {
	var request UpdateNeoforgeRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateNeoforge(ctx, request.(UpdateNeoforgeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateNeoforge")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateNeoforgeResponseObject); ok {
		if err := validResponse.VisitUpdateNeoforgeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteNeoforgeFromBuild operation middleware
func (sh *strictHandler) DeleteNeoforgeFromBuild(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID) {
	var request DeleteNeoforgeFromBuildRequestObject

	request.NeoforgeID = neoforgeID

	var body DeleteNeoforgeFromBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteNeoforgeFromBuild(ctx, request.(DeleteNeoforgeFromBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteNeoforgeFromBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteNeoforgeFromBuildResponseObject); ok {
		if err := validResponse.VisitDeleteNeoforgeFromBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListNeoforgeBuilds operation middleware
func (sh *strictHandler) ListNeoforgeBuilds(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID, params ListNeoforgeBuildsParams) {
	var request ListNeoforgeBuildsRequestObject

	request.NeoforgeID = neoforgeID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListNeoforgeBuilds(ctx, request.(ListNeoforgeBuildsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListNeoforgeBuilds")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListNeoforgeBuildsResponseObject); ok {
		if err := validResponse.VisitListNeoforgeBuildsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachNeoforgeToBuild operation middleware
func (sh *strictHandler) AttachNeoforgeToBuild(w http.ResponseWriter, r *http.Request, neoforgeID NeoforgeID) {
	var request AttachNeoforgeToBuildRequestObject

	request.NeoforgeID = neoforgeID

	var body AttachNeoforgeToBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachNeoforgeToBuild(ctx, request.(AttachNeoforgeToBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachNeoforgeToBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachNeoforgeToBuildResponseObject); ok {
		if err := validResponse.VisitAttachNeoforgeToBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListPacks operation middleware
func (sh *strictHandler) ListPacks(w http.ResponseWriter, r *http.Request, params ListPacksParams) {
	var request ListPacksRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListPacks(ctx, request.(ListPacksRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListPacks")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListPacksResponseObject); ok {
		if err := validResponse.VisitListPacksResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreatePack operation middleware
func (sh *strictHandler) CreatePack(w http.ResponseWriter, r *http.Request) {
	var request CreatePackRequestObject

	var body CreatePackJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreatePack(ctx, request.(CreatePackRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePack")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreatePackResponseObject); ok {
		if err := validResponse.VisitCreatePackResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeletePack operation middleware
func (sh *strictHandler) DeletePack(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request DeletePackRequestObject

	request.PackID = packID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeletePack(ctx, request.(DeletePackRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeletePack")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeletePackResponseObject); ok {
		if err := validResponse.VisitDeletePackResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ShowPack operation middleware
func (sh *strictHandler) ShowPack(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request ShowPackRequestObject

	request.PackID = packID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ShowPack(ctx, request.(ShowPackRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ShowPack")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ShowPackResponseObject); ok {
		if err := validResponse.VisitShowPackResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdatePack operation middleware
func (sh *strictHandler) UpdatePack(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request UpdatePackRequestObject

	request.PackID = packID

	var body UpdatePackJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdatePack(ctx, request.(UpdatePackRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdatePack")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdatePackResponseObject); ok {
		if err := validResponse.VisitUpdatePackResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeletePackAvatar operation middleware
func (sh *strictHandler) DeletePackAvatar(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request DeletePackAvatarRequestObject

	request.PackID = packID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeletePackAvatar(ctx, request.(DeletePackAvatarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeletePackAvatar")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeletePackAvatarResponseObject); ok {
		if err := validResponse.VisitDeletePackAvatarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreatePackAvatar operation middleware
func (sh *strictHandler) CreatePackAvatar(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request CreatePackAvatarRequestObject

	request.PackID = packID

	if reader, err := r.MultipartReader(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode multipart body: %w", err))
		return
	} else {
		request.Body = reader
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreatePackAvatar(ctx, request.(CreatePackAvatarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePackAvatar")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreatePackAvatarResponseObject); ok {
		if err := validResponse.VisitCreatePackAvatarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListBuilds operation middleware
func (sh *strictHandler) ListBuilds(w http.ResponseWriter, r *http.Request, packID PackID, params ListBuildsParams) {
	var request ListBuildsRequestObject

	request.PackID = packID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListBuilds(ctx, request.(ListBuildsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListBuilds")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListBuildsResponseObject); ok {
		if err := validResponse.VisitListBuildsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateBuild operation middleware
func (sh *strictHandler) CreateBuild(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request CreateBuildRequestObject

	request.PackID = packID

	var body CreateBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateBuild(ctx, request.(CreateBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateBuildResponseObject); ok {
		if err := validResponse.VisitCreateBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteBuild operation middleware
func (sh *strictHandler) DeleteBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	var request DeleteBuildRequestObject

	request.PackID = packID
	request.BuildID = buildID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteBuild(ctx, request.(DeleteBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteBuildResponseObject); ok {
		if err := validResponse.VisitDeleteBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ShowBuild operation middleware
func (sh *strictHandler) ShowBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	var request ShowBuildRequestObject

	request.PackID = packID
	request.BuildID = buildID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ShowBuild(ctx, request.(ShowBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ShowBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ShowBuildResponseObject); ok {
		if err := validResponse.VisitShowBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateBuild operation middleware
func (sh *strictHandler) UpdateBuild(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	var request UpdateBuildRequestObject

	request.PackID = packID
	request.BuildID = buildID

	var body UpdateBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateBuild(ctx, request.(UpdateBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateBuildResponseObject); ok {
		if err := validResponse.VisitUpdateBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteBuildFromVersion operation middleware
func (sh *strictHandler) DeleteBuildFromVersion(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	var request DeleteBuildFromVersionRequestObject

	request.PackID = packID
	request.BuildID = buildID

	var body DeleteBuildFromVersionJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteBuildFromVersion(ctx, request.(DeleteBuildFromVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteBuildFromVersion")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteBuildFromVersionResponseObject); ok {
		if err := validResponse.VisitDeleteBuildFromVersionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListBuildVersions operation middleware
func (sh *strictHandler) ListBuildVersions(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID, params ListBuildVersionsParams) {
	var request ListBuildVersionsRequestObject

	request.PackID = packID
	request.BuildID = buildID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListBuildVersions(ctx, request.(ListBuildVersionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListBuildVersions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListBuildVersionsResponseObject); ok {
		if err := validResponse.VisitListBuildVersionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachBuildToVersion operation middleware
func (sh *strictHandler) AttachBuildToVersion(w http.ResponseWriter, r *http.Request, packID PackID, buildID BuildID) {
	var request AttachBuildToVersionRequestObject

	request.PackID = packID
	request.BuildID = buildID

	var body AttachBuildToVersionJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachBuildToVersion(ctx, request.(AttachBuildToVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachBuildToVersion")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachBuildToVersionResponseObject); ok {
		if err := validResponse.VisitAttachBuildToVersionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeletePackFromGroup operation middleware
func (sh *strictHandler) DeletePackFromGroup(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request DeletePackFromGroupRequestObject

	request.PackID = packID

	var body DeletePackFromGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeletePackFromGroup(ctx, request.(DeletePackFromGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeletePackFromGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeletePackFromGroupResponseObject); ok {
		if err := validResponse.VisitDeletePackFromGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListPackGroups operation middleware
func (sh *strictHandler) ListPackGroups(w http.ResponseWriter, r *http.Request, packID PackID, params ListPackGroupsParams) {
	var request ListPackGroupsRequestObject

	request.PackID = packID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListPackGroups(ctx, request.(ListPackGroupsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListPackGroups")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListPackGroupsResponseObject); ok {
		if err := validResponse.VisitListPackGroupsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachPackToGroup operation middleware
func (sh *strictHandler) AttachPackToGroup(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request AttachPackToGroupRequestObject

	request.PackID = packID

	var body AttachPackToGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachPackToGroup(ctx, request.(AttachPackToGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachPackToGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachPackToGroupResponseObject); ok {
		if err := validResponse.VisitAttachPackToGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PermitPackGroup operation middleware
func (sh *strictHandler) PermitPackGroup(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request PermitPackGroupRequestObject

	request.PackID = packID

	var body PermitPackGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PermitPackGroup(ctx, request.(PermitPackGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PermitPackGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PermitPackGroupResponseObject); ok {
		if err := validResponse.VisitPermitPackGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeletePackFromUser operation middleware
func (sh *strictHandler) DeletePackFromUser(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request DeletePackFromUserRequestObject

	request.PackID = packID

	var body DeletePackFromUserJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeletePackFromUser(ctx, request.(DeletePackFromUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeletePackFromUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeletePackFromUserResponseObject); ok {
		if err := validResponse.VisitDeletePackFromUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListPackUsers operation middleware
func (sh *strictHandler) ListPackUsers(w http.ResponseWriter, r *http.Request, packID PackID, params ListPackUsersParams) {
	var request ListPackUsersRequestObject

	request.PackID = packID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListPackUsers(ctx, request.(ListPackUsersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListPackUsers")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListPackUsersResponseObject); ok {
		if err := validResponse.VisitListPackUsersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachPackToUser operation middleware
func (sh *strictHandler) AttachPackToUser(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request AttachPackToUserRequestObject

	request.PackID = packID

	var body AttachPackToUserJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachPackToUser(ctx, request.(AttachPackToUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachPackToUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachPackToUserResponseObject); ok {
		if err := validResponse.VisitAttachPackToUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PermitPackUser operation middleware
func (sh *strictHandler) PermitPackUser(w http.ResponseWriter, r *http.Request, packID PackID) {
	var request PermitPackUserRequestObject

	request.PackID = packID

	var body PermitPackUserJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PermitPackUser(ctx, request.(PermitPackUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PermitPackUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PermitPackUserResponseObject); ok {
		if err := validResponse.VisitPermitPackUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ShowProfile operation middleware
func (sh *strictHandler) ShowProfile(w http.ResponseWriter, r *http.Request) {
	var request ShowProfileRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ShowProfile(ctx, request.(ShowProfileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ShowProfile")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ShowProfileResponseObject); ok {
		if err := validResponse.VisitShowProfileResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateProfile operation middleware
func (sh *strictHandler) UpdateProfile(w http.ResponseWriter, r *http.Request) {
	var request UpdateProfileRequestObject

	var body UpdateProfileJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateProfile(ctx, request.(UpdateProfileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateProfile")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateProfileResponseObject); ok {
		if err := validResponse.VisitUpdateProfileResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// TokenProfile operation middleware
func (sh *strictHandler) TokenProfile(w http.ResponseWriter, r *http.Request) {
	var request TokenProfileRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.TokenProfile(ctx, request.(TokenProfileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "TokenProfile")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(TokenProfileResponseObject); ok {
		if err := validResponse.VisitTokenProfileResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListQuilts operation middleware
func (sh *strictHandler) ListQuilts(w http.ResponseWriter, r *http.Request, params ListQuiltsParams) {
	var request ListQuiltsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListQuilts(ctx, request.(ListQuiltsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListQuilts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListQuiltsResponseObject); ok {
		if err := validResponse.VisitListQuiltsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateQuilt operation middleware
func (sh *strictHandler) UpdateQuilt(w http.ResponseWriter, r *http.Request) {
	var request UpdateQuiltRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateQuilt(ctx, request.(UpdateQuiltRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateQuilt")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateQuiltResponseObject); ok {
		if err := validResponse.VisitUpdateQuiltResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteQuiltFromBuild operation middleware
func (sh *strictHandler) DeleteQuiltFromBuild(w http.ResponseWriter, r *http.Request, quiltID QuiltID) {
	var request DeleteQuiltFromBuildRequestObject

	request.QuiltID = quiltID

	var body DeleteQuiltFromBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteQuiltFromBuild(ctx, request.(DeleteQuiltFromBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteQuiltFromBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteQuiltFromBuildResponseObject); ok {
		if err := validResponse.VisitDeleteQuiltFromBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListQuiltBuilds operation middleware
func (sh *strictHandler) ListQuiltBuilds(w http.ResponseWriter, r *http.Request, quiltID QuiltID, params ListQuiltBuildsParams) {
	var request ListQuiltBuildsRequestObject

	request.QuiltID = quiltID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListQuiltBuilds(ctx, request.(ListQuiltBuildsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListQuiltBuilds")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListQuiltBuildsResponseObject); ok {
		if err := validResponse.VisitListQuiltBuildsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachQuiltToBuild operation middleware
func (sh *strictHandler) AttachQuiltToBuild(w http.ResponseWriter, r *http.Request, quiltID QuiltID) {
	var request AttachQuiltToBuildRequestObject

	request.QuiltID = quiltID

	var body AttachQuiltToBuildJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachQuiltToBuild(ctx, request.(AttachQuiltToBuildRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachQuiltToBuild")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachQuiltToBuildResponseObject); ok {
		if err := validResponse.VisitAttachQuiltToBuildResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListUsers operation middleware
func (sh *strictHandler) ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams) {
	var request ListUsersRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListUsers(ctx, request.(ListUsersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListUsers")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListUsersResponseObject); ok {
		if err := validResponse.VisitListUsersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateUser operation middleware
func (sh *strictHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
	var request CreateUserRequestObject

	var body CreateUserJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateUser(ctx, request.(CreateUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateUserResponseObject); ok {
		if err := validResponse.VisitCreateUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteUser operation middleware
func (sh *strictHandler) DeleteUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request DeleteUserRequestObject

	request.UserID = userID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteUser(ctx, request.(DeleteUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteUserResponseObject); ok {
		if err := validResponse.VisitDeleteUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ShowUser operation middleware
func (sh *strictHandler) ShowUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request ShowUserRequestObject

	request.UserID = userID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ShowUser(ctx, request.(ShowUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ShowUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ShowUserResponseObject); ok {
		if err := validResponse.VisitShowUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateUser operation middleware
func (sh *strictHandler) UpdateUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request UpdateUserRequestObject

	request.UserID = userID

	var body UpdateUserJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateUser(ctx, request.(UpdateUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateUserResponseObject); ok {
		if err := validResponse.VisitUpdateUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteUserFromGroup operation middleware
func (sh *strictHandler) DeleteUserFromGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request DeleteUserFromGroupRequestObject

	request.UserID = userID

	var body DeleteUserFromGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteUserFromGroup(ctx, request.(DeleteUserFromGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteUserFromGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteUserFromGroupResponseObject); ok {
		if err := validResponse.VisitDeleteUserFromGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListUserGroups operation middleware
func (sh *strictHandler) ListUserGroups(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserGroupsParams) {
	var request ListUserGroupsRequestObject

	request.UserID = userID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListUserGroups(ctx, request.(ListUserGroupsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListUserGroups")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListUserGroupsResponseObject); ok {
		if err := validResponse.VisitListUserGroupsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachUserToGroup operation middleware
func (sh *strictHandler) AttachUserToGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request AttachUserToGroupRequestObject

	request.UserID = userID

	var body AttachUserToGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachUserToGroup(ctx, request.(AttachUserToGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachUserToGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachUserToGroupResponseObject); ok {
		if err := validResponse.VisitAttachUserToGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PermitUserGroup operation middleware
func (sh *strictHandler) PermitUserGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request PermitUserGroupRequestObject

	request.UserID = userID

	var body PermitUserGroupJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PermitUserGroup(ctx, request.(PermitUserGroupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PermitUserGroup")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PermitUserGroupResponseObject); ok {
		if err := validResponse.VisitPermitUserGroupResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteUserFromMod operation middleware
func (sh *strictHandler) DeleteUserFromMod(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request DeleteUserFromModRequestObject

	request.UserID = userID

	var body DeleteUserFromModJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteUserFromMod(ctx, request.(DeleteUserFromModRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteUserFromMod")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteUserFromModResponseObject); ok {
		if err := validResponse.VisitDeleteUserFromModResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListUserMods operation middleware
func (sh *strictHandler) ListUserMods(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserModsParams) {
	var request ListUserModsRequestObject

	request.UserID = userID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListUserMods(ctx, request.(ListUserModsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListUserMods")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListUserModsResponseObject); ok {
		if err := validResponse.VisitListUserModsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachUserToMod operation middleware
func (sh *strictHandler) AttachUserToMod(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request AttachUserToModRequestObject

	request.UserID = userID

	var body AttachUserToModJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachUserToMod(ctx, request.(AttachUserToModRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachUserToMod")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachUserToModResponseObject); ok {
		if err := validResponse.VisitAttachUserToModResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PermitUserMod operation middleware
func (sh *strictHandler) PermitUserMod(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request PermitUserModRequestObject

	request.UserID = userID

	var body PermitUserModJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PermitUserMod(ctx, request.(PermitUserModRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PermitUserMod")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PermitUserModResponseObject); ok {
		if err := validResponse.VisitPermitUserModResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteUserFromPack operation middleware
func (sh *strictHandler) DeleteUserFromPack(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request DeleteUserFromPackRequestObject

	request.UserID = userID

	var body DeleteUserFromPackJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteUserFromPack(ctx, request.(DeleteUserFromPackRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteUserFromPack")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteUserFromPackResponseObject); ok {
		if err := validResponse.VisitDeleteUserFromPackResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListUserPacks operation middleware
func (sh *strictHandler) ListUserPacks(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserPacksParams) {
	var request ListUserPacksRequestObject

	request.UserID = userID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListUserPacks(ctx, request.(ListUserPacksRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListUserPacks")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListUserPacksResponseObject); ok {
		if err := validResponse.VisitListUserPacksResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AttachUserToPack operation middleware
func (sh *strictHandler) AttachUserToPack(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request AttachUserToPackRequestObject

	request.UserID = userID

	var body AttachUserToPackJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AttachUserToPack(ctx, request.(AttachUserToPackRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AttachUserToPack")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AttachUserToPackResponseObject); ok {
		if err := validResponse.VisitAttachUserToPackResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PermitUserPack operation middleware
func (sh *strictHandler) PermitUserPack(w http.ResponseWriter, r *http.Request, userID UserID) {
	var request PermitUserPackRequestObject

	request.UserID = userID

	var body PermitUserPackJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PermitUserPack(ctx, request.(PermitUserPackRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PermitUserPack")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PermitUserPackResponseObject); ok {
		if err := validResponse.VisitPermitUserPackResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w9227cuJK/Imj3adFOJzM5i4Wf1smM5wRnnDhXLDAwBrTEdnMiiT0UZcfH8L8veJXU",
	"EiWKUlvdbT4lbvFSrCpWFYtVxYcwwukGZzCjeXj6EG4AASmkkPC/zgq6fotjeMl+ZT/EMI8I2lCEs/CU",
	"fw4iHMNwESL2w98FJPfhIsxACsPTUH7KozVMAetO7zfs95wSlN2Ej48LPsQlwbcohsQ0SxagGGYUrRAk",
	"wQqTgK5hANjcG9lTzb8BdF1OX/lK4N8FIjAOTykpYAdIi/DHCfwB0k3Cfr1BdF1chxLOzxTQTlTkrIEB",
	"F+pbFzLeFCiJTRME1+xrFRWYBHlS3LQvnrf+E8Xui+cjnLwK2a83+ESOy2F89wtrfA6uCYqM8K74Z2uA",
	"RfNREIshGiALOCXMmNxAM8jsqz3ErPU4gNkITXjZrwLc3wguNkZwb9hXa3B561Hg8hEa4HIYBbgXKIMR",
	"AStqBDlVLazB1j1Gga5HaYCvYZZLwOYdmGL7/Zficbsvxc29d4HlznsP8aqTkTPZwBpc1WEUzGqQBuAK",
	"XgH9JYi+GyHfgOi7NdSs8SiI2QANaBl8CtIblN38jlJk4mjRIkhYE4PkV99KkGK4AkVCw9NXL18uFIAo",
	"o/AGki0IX718qeH4sFrlsAcQzNsYINEfW0DpA4SB8bFAiXlr/82+WpOOtx5FOz5Cg3gcRkG9zxCQaP2R",
	"4cAAtGgRKDS16m3epEdxf8aEvsVJkWamiTChjDwRb2SaChNqMdEHYraV1DyYVKyibS6Q31qYIAR5FC5C",
	"mBVpePqH/IvNEF4tuonBGz0uwq+52Y4LihwSawZhjUfxx18xhlvMwaATvPENkhzhzAjqrfhuDa1sPwpg",
	"OUaDpSWsDPBHMTjM6RscI8iNdG6RyTZvcHzPfotwRmFG2X/BZpOgCLCVLf/K2fIeKgBtCN5AQuVQKY6b",
	"UDJgsiJJwDWDUqzoxwlOEYXpht6Lnx4XCnzXAR6rePuDg1KOWbIfvv4LRjR8ZO3rRPuyhtJGVsSLAQUB",
	"xUFEIKCQETCGCeRmeJ1Ej4vwLW/DcTkSiaUh24qJFrvUFsNaQ/cNLHWt7bh/gVvgTvcEUJjTSv9rjBMI",
	"MusBUphicu8OQM1C7EFN1dqzHV90dYWualn1AFcxk2xH3xTXCYpGIF/r4R7YlF61HZfACKcpzGIYO0P3",
	"OGjX13e7eY/z88rIPT6OJbgacReTVjgRZ0NbnFzgsVIPFHSNiTtOaitwHgRnbJnue3UUWUfvxRzFM3HV",
	"IryD1zlyx50tW7IjtC1TsnPYrPt0PEEPgST8xG1LE2ZBj5UUEUW3sHbuEEtwRDKIU5TVhluBJHcfD6YA",
	"Je5UWxVJMpLtQJ7fYcL15gqTFFB+3JA/LhxHZeepMXDZshM/5Nmy0zTHlpl3ebFJMKhTi63/pCCJI7Vs",
	"cd1+0GlDtzhrTHG84cbWGOaOvk90RORDLSRAtidEeSvRZjKyA2KxiU0YZJa5R6C8IxmOP252X+D4F4I3",
	"u3BTtDkQrgYZy1XbpMgSlH3vWsclJOlO1rEIN5CkdguUbd3Xybpz73T7OpkJNgHB2nm2lR2HLaVmu/TQ",
	"jF87jCeaYS22VJN7zoFstbX20I2ZaRPQjeny/iXxVsPWUjMSeujGXcoT0K2dPIshi3SiW22tZrr9jm9Q",
	"dlbQ9Wj+HGI9dhqGbTjgLSs2qi0uIgK5Kx0kOcMDKOia/RkZtIX203mNW7kzH651L3B8dgsoaDu0pUVC",
	"0QYQumR8csKGZT/DLMIxWyFjIJTASq8v8oYwBTdw+V/hIlxDEMtYIdnkJEb5BudIOXLMt1l8tUYnupxY",
	"c/A1ygC/xWqyqLXjAXBMcJEjTPZ2hHGpM4H05Nu/f1eJZlcD1lH37ZnFp1rLBNLTtBZbtSf6D5SfzbWa",
	"xecFjvdX6bGFWKo8uY7DVHiNdZrppe46vHwvg3WGi3dm03r5rr2YNgKeoWyvJTxfia2I16s5VBnfslqz",
	"0GCr3V8pz5diKebVSg5TzjdXaqYZvzj2Ul6Gxw0X8Z9gjAiM6ARHQ4q/w6yfI0Qz23URCV/Au9mc7b7y",
	"tfpQGx9q40NtDjvUxiy1xB5/jqE2fTjxoTY+1ObJQ236mNKH2jx9qE0vTQhmp+SRZPHRLOMoJohgTbRJ",
	"46PGBkT5AKjZA6D6+MUHQE0aANWB7hySvXb7cbaxdfvp1Ryq269ltWYXElvtnkYO8XXYBQ7JVRxi3FBj",
	"ld202t+oIb4Qy6AhtZLDjBlqrtRMM6WEvJNW6ROTm9aUP8jnzjc4ywUaziI26DlACYx/JUSc1q1R+p8E",
	"rsLT8D+WZW2WpfiaL99jilaya9sqxJwMavgDRgWFAeCw8MIpBOa4IBHkFU0SAkF8f0YpiNZPDeUnCUiA",
	"8gAIQAIgIWHAvQHx2zJg6Glh+5oJBwv6N4yDO0TXwR3B2U01gkmC+Emk4s5F4A0gOQxkPnCo6sd8knw4",
	"GUB8VNOGiSEFKMk5dwGxbTQkUqzkThAZxIoFoAtZcaFqjqKM/vfrsK3EgayJYNdYiacuKJjKYG0ppiCx",
	"HFeKHb5UJtRyq6VK/IalsQwIAfct9zkMkoUuRKHLQOhpbcTjWRDhJIFCmOBVXVTmmuiTUXsgMppYODg+",
	"sCWbRI8L0fQGreSD7BPFxIVeX3cB/E4pvFdUq+as5CX1piDcHiDQQfyVDDCD4BPUyMNaTtBebSIGVS8K",
	"eaPns4XKALuScs94Aynqz7F/OOrDSirVFHTQXqyuZfMJhzJ9igdsSrWktn058+7h63AhmM4ay8NqLtV+",
	"U22wPTeQxtq82yLy9HQTwLkTTvRXlJv8eCipY3M8vFGE1HldR8RDQ+R1kcugait+085+d4EtJnTnIdFf",
	"UW4yqg3cc096xpt+I8slO1OBE+BdRiHJQPIZkltIntb19BmnMEASgCDnEASQg8AhuwUJir/g7zCbyyV2",
	"AzNIpK+WQ8P+L+JZVYrl5ALwrKDrL2KKJmi/SYBiGR7L/YnwxwYRHlMAw0au46E6UHRoaN9sermHfaLY",
	"ysrMa5R8vieLGnVnOF1osuRhNf118l2vR7Yzfcr007CSmDmXIjUcUAaeiixQdNhaV+efKl7aBRdZ809Y",
	"Zoc+tXiZndguJnMrk+/eYFY5sIpnZqDVAGl9XJ4K5aOoJRcfqkGlsll6rWPV7qDNqXoSdI2Kz9eYqpJ2",
	"BltK0URQA9P5Y0UyTGtxIgwoHazxxGEivJi9BEnDIIE6x0U2F5oYQCs2f1grEDC57VIObWfCVDL0w2rm",
	"+lxGsMmDe6RRAyPs4DJHP1eU2wk32fNRWEmh32v1sKuIoeHmcDu7794e1rUCNO/sPcHsEXsIt0D6/kcm",
	"lE2/dcW4xspvBSEwo2UqldjNEiL+Qt8UHKFe+xtAPPU+4C4IWILjQrPa64YcVWUZjWcRYcdz5fvA4jjZ",
	"u5NMpdBHSbnne4YpifT0BxhOCk6ET3BFYL5+2ssfOWnn5c8nmGIKv2bgFiCe4PDUpwY2fVA5YSEaaFj4",
	"K2pFFME8v4B5Dm7gkwF2mQCUBbmYPEjl7I+LkGN73ku8DPKLT0ZImcejr+hnOMx0hAfsUbiDzSqe5DBT",
	"Zh7mYZmVt9deWqM3+6Bo5uzVVdmHeVjJyjuiQ4T5dDY3ydwPHTr9UBNtcpEtl9LvMcg4NAqOo7HEhrsA",
	"5jj+65P/NxGOg/BswUE6IKiSMvcNErS634k5IYZuA+kCUsBzS/GqfMteRylVs3HnOusZU8sWh3ZvXHmV",
	"tAsMveAnOCA2M+fk7JOzYbkqC7/qbUnzCTM3D5Nd7LfLXiRhhmWpZZF+rk8zzXpQ/PiZ/wnodr0WeEJR",
	"KnLbQfwhS+633mUbmMqvi412D2dbfHQRVmRqY1UiQz/e/aqqRYSGLUz3bFvbG5XfvKUocAwTproI3BCY",
	"w0z6lYR/ccr1O+Re7rj4qnUK065KtYoR+9mmnEE8LX4sJV4HRXoeRmHYIfEWOy4mO+BecJrCs9Z+2n0u",
	"U7sIRYWvMZKO6SZE+Yv7b6QwbZfH30rT0U4sa3W8GFW+gre2IADvIGTOFPJ/PGaHW9u6h8VyZSe24C3V",
	"qhFWG+5qi87BN02dBr3Pte7rpbRUk7vQwK4aZ5xwnHRHnSvsNFGsBHA/hnnLfUJwTSfOUe94WhpJ/DZI",
	"9JvKpOwlka75tyMS7Zrnx1ULnpQav0lUtlPjAsf2BAlkab/JiTIsxZa3thDovIPcYNYn/xTbqMYLLBWj",
	"KrCn3wZX753ArEgrz5+ImrmLEN9ltRdfplSPbXUzhdaSi7ra4orgAsdGzriUFqQla6gagofHG4NMZRB9",
	"txidNT8k/lDLajDIpaBqg0Muqgqrl0NK9XY8Vo3otRcS/qKC3ialLAV8m2gf+xCEDMa2z3Sc5qCxF+9P",
	"zMOVB/1uxRQHxAkeWlC7ql03ltxquatUSsIuRN/8+C5I0qcMv3763Qn7wZlCXIMI7yv+tl4aaOecP1K3",
	"qo/3JX6aiK5efjeQzePWUBSo0sT8oo/X68gDkMXqQpzfPm0jXzSzvwbTQ7XdGadl8GAToS1iigJa5JXW",
	"6oKuhylr2GjBlrXJ3Gos22nLalbU4oBZeOYHefZL15jM7AqxbdnKqxsXdcMQ3aFvVAaKFRFk24Xx2R3D",
	"KtUGqL6wY9G0oOthUVpnBV2Hj0ZkC6FqS9Qp2Gr294DGBERPgkVbp6RrVO8kQLoHnU40/S4ebdqUO3tG",
	"qTbBy1FKkGnp0ybERDqajRSrJYg1ZFmM8k0C7i2CVBZhTNCtmLTfEolwZtXQPkKmghe1lAZiPqrr616s",
	"iItuf45oRfFHiZwGfr/mlkynngrfr+fqvIYdr2FtFZwX8jZC/mveLsg079luNi7mdyLPNhVl0/jIt8/D",
	"jq44qkgKzsT6WjFlfxtdpnQd6A1X3yWUuHVa1C+jrnYUw2OfRiTaWqyVNW+J21G9K0i72mIQ4+24sp6t",
	"+WNXd+PP4up6Hq5oXotznjB4/vWJxpoldnYn/myurOfhi5brcM4YJjddxTnd7iMHSZBTUkS0IJDxSb7G",
	"dxXvuPSZN1hlhWDS/hKn0eFd1YAVsNqAHhB9aoo7nSQtQFpmFvGc50iUDHAOs7MWpbM/eDyhIdQRllrF",
	"6wA+CFodnDKB689xkRGTqMz4H71a8Jd/DPA8CZP6UO/Ed+U0l9wTnLc6nNjSYVQQRO8/s80lmOQNyMXO",
	"4BuO7w3+i+6+ppSbuW8gIELyly3FT42m/4RAnjTYOT9ciz/VJg7/7+Ts8t3Jv+B92RNsEPubJ8ChbIUV",
	"+4KIo1kel8PvCUQ5heR/7+D1Gm02CL6IYTnwv+TnUKKYA5SfLpeq3wtYhM0Uu8t3QQxXKEP62VQ10CJI",
	"QQZuIA8b4O5W/rka35OgCMqESQnF2QZEa3jy04uXNThOl8u7u7sXgH99gcnNUnbNl7+/e/vr+8+/si4v",
	"1jRNwgpNFSjBhw3Mzi7fhZWY+/DVi5cvXp6AZLMGr3iW5AZmYIPC0/Bn9iUUW4XTeclOlssE3wjXywaL",
	"nCMmL7hGeheHp+K9BHlEkznT6nngNhldNkFsFaoz77L9QO5PL1+ah5HtlvX3Gh4X4WubXtsPs/J+r6z6",
	"Nd6cfVyE/7CZs+1VjuoOC0//uFqEeZGmgNwzpijomk0UAQpVgYLg+r72xuwipOAmZ5YP9wJcsfEE2Wql",
	"zm5gG+VQTnVxtdAF983SbF3rOYc0WotcdlU7aLuGmXk5BMaIQLG12xnxk2zhyovV/u7sWK88tGt2bD6n",
	"sitm/AQpQfAWBgSCRJY4AismZDRluojHa1wZOVHWwNKUG4r07cJdM6KvgjAOE9u4ZemG4BquMIEBorLE",
	"VxfL3+o85lakiTRnZ5xtFbXYB5QJkMSZCtF7VZgFlHKQKVuR/G1G24MSJ4/LCCTJtTxmt+LwrWxQuVna",
	"AAJSSLng/KN9TWUTXsNDdb5kP4ePC6tOnymgcFCPtzhWHa62CP7zy//Zqr5A4Q+65HZBrezC9gGjo4qZ",
	"qlxW1hx5/fL1RLMojNXLUL9+9dNE45flXLiFBhL0b1hehJYMO8FU79pfuuqQpIrnytfZKS+zsUIZjKvX",
	"tRYMrorUmAUr/z4le++O95QCZohhKKkSbNe8NydDSCLxNZMKDuxYoqzIYDTy5EvQg6n/GQISrT8WkNwb",
	"iG+labYfoubk/Lm/X0vd/ul0TZsxKgANdLGVEt8SyVfcL9SC5a/8hK/zWofjaKuA5lwoYn1/trG3WuuR",
	"1jEscDIcxSVTLx90+ZDHZVmhKoYJFBGbdSL8wn8XM5wTnKrE/WFML/pX+X3gOaLyar77MaKNH1zPEc58",
	"JIVub9fKQxalGu+fsPZQyHQ7+2uWoOx7AGS5hRXBaQC2GK99a/cIUFFsbRxDLRyErkUfTOhbnBRpNqjL",
	"BzLEar0ENyi7+R2liA7s84GXsRqvQraq3c3B3JNrHyHW9Hs1TO/bMWu7E0RsKtH/C/YScH8l4FlCIIjv",
	"G1Lw9U8WnbfrZE7HmQIeLT0t2ZHrbJXMZRaj4p2ouczQ+jNh+2uF8hfO2iwkjuA+G1RmgXkT1GiC9uFX",
	"M/PyQRX3GmB+sh4jrE/WfYzo1S8aesm7P7ZnleNaN3S3yHQ1PCu85O1Od53xfMzOXj7tNDpZK2eb08s9",
	"b3FWLM4eTmQqukz4M0pP8drKBAanF4XLrZdr9sh8BklSMe9uFM0Vz4jIfLP0esuD1VQM+WDJU+nuLnp4",
	"92miBtwlz7xiQOAxAEEG73SexjYNy32/fFDpAI/9Rrki7jAxICuouW8ZR4Vyxiu3izvM+VTKRGQVBAhA",
	"kG9ghFYoMtLWYAV/XuO7mejXsisP2e6zokGHa2EiKgyUr5W5D1y+ull280pl6UGxYJ1W0bxUxQ4s5PM5",
	"wanI2nlaBlMlVH8heOMPD3M6TVIsXSYDVYQ29S+wg5ukyj/eTeKuKGsPJB6+skwS/pxgzUXSoTY7HCMc",
	"O1/wnLLtEpLUy7ZDdYwwudjNfW1GG6M50nLRs97BqNX9MPl4+hIkqUhfGmb16SpTlmafzMmdgUHZzN7w",
	"m9vw4zUPR1l+/LVfb/rNZPrV31o+CttPZG5OZvzNK+G8Dj5k828jk0Xc7T/Pfd4CHG4Bcr5zNQH1w+OW",
	"JqAshzYDi7KZvQk4twnIk9tHmYD83X5vAs5kAnLsH5cJyEXYdCbgvBLOK+FDNgG5dBxlAnru8ybgcBNQ",
	"VEC0MgFrz58aNbUugzRbGkgJwf6ngmhY29IVSoT3xG1US0/5tBBTWog1rmvMvnyoPmpvnyaiZ3NPFdFD",
	"jBDQegwfOr1fKSMNbjRu/H5R65g+ss1f/nQ0Tt88mzQSe97tOjXpUVxTSrx89OenltQSW+7kal5GL5pl",
	"rEvAmReTbWJyuuixHSaXpILeml9w3JtYImJvHNNKLvAIoXOBY59SolNKxNMOdcqpPb58EK8IWKSSuIRS",
	"XeDYp5FMnUbSRs+OFJIZ6NbYf0eSPNKO+S4HxHjcOyWNHLr0PI6EESvBuwSVF3J75K9+4vWpd7OYeDBX",
	"HKMglr4zCgh3DFcrmBrEQ7eJNA1Nh57u1LyjpIQjV3hZEX7dJBjEvMSzPSs1RUdZCKBXdJwTnLqlMY7m",
	"ND6tjzOZ28vKmUV4WQdYkPKs71hPouQd70N11b2Tlp/YkwATIbhq3tMhylP6SXH8Bc8p0/zd/iF7RoU8",
	"NHOeOaxE0d+znQ8pGXAyFAxXxpTY2XiW4cTSxHMKdhrNlj6QeL8CiYfbd24hxN68G2/ePYvwYUfjbj5p",
	"5nXsMQQNu1h2nue8XTcqVNjOrNOhll1BFt/KeEyvmJ9UMSvMH5diLsM5FPuJlwYdbi7KZ7mfUlLW5naX",
	"lXIAf3MxMrJEP6huZCKz4Fs+yP/ZRZ+M57d+4SHn8BErU0es9PNJR/zKgVC+VaYcSdyLDf06omBmoqBT",
	"5IzXLfsUQTOZgrFOT5LkG5Gc9KRMq9jVB+nvVRJTS4B9nxO2Ssn8CbnOHxDHqPtjS21ip8SW1CYzP3f5",
	"cCWOnNOYvCT1nl/3dCcTzzKLIYO4/9HG97LRbAn7GoD9z9dXoLalkGtk9xwT1Bg+Wb8jWd8S0VUmXz6o",
	"/w2yhNVM7qawGmGEVFZDeLG8XwbuNhuatnuvcHW0d7dYyxuxoxTMs0nQt2XbLqtWjeFq1nqp6I3VhrFq",
	"x5hMq+sK80bR6lYR3AvIFmJOWd57h7e5G0lxxTLs794bXFka2fEOlvV2lzyst8/Q1/eoG0GKLfLp3b58",
	"YP/Y3ZM6Fbzmtar9refEt57tVO246ZyFds2teCSXlib0d3ggJiGA07Xj4YvT47hwtJbE1mn7jDaOOd5T",
	"bG2fuW+Tub9FdpsAuAnpOlBilDOPkxg+fX9n6fut/NQmRUpnrPE45+ghqzCZ9445ic9jvNstz4zSPyYi",
	"a4y2UocAdPN+jZR9landhR/v7uXeyEOrvA/o4B+zwFs+8H/tjrSjGa1fZPAp/Al46hNwP4t0nIYPgewt",
	"kuRITs82pOs4Sc9BPKeDt1cl+3L0nkif1DLrLBTLOcGpa4D6k/Ir7z86PN1HQoyPhNBR6SIW4lrKOjvV",
	"po90zsmdzlznz4HuSv44E0J1Gmg1TMLIz11RERxJX7CXpD564omiJ5QU5vETBp5tsxhsi2YylnSvmjmB",
	"j9fXzdy3upmDzrAqFMexdKb3304RvPNMimcO89+KLcPQ41o/cyrp5kveHEUFzUEOIlFpSbOA5z1fbmlU",
	"GU17X5FlKU1l+DlVApuAO301zf2qpulk9bkV1PRG3xRG37Moqelu8s0p17zSPYa6mo72nmc8b+2NLK7Z",
	"YewRvEIJXOYwWRnj6XiUvWjolGUu++5jRpBcfxBDClCSB3jFIxI3kOQ4A0kAoggXGa0iTyKiLyi+gi+3",
	"2HYxwIhg1TasP7eEIbkf7nFBAnyXaXqjbIVJyqdspW11b1D8HWbGzfGFfR2zO/gA+7U3PkFKELyFAciC",
	"IkuYSQrjABR0HQhkmFD2d4ES2hmX+5G1mK02iJh9/wuDcDjbilUIBPfIHt7b1wPpqAfSi1/NzMsH/s+g",
	"GiB8dPcCILz7COON9/dJ7vtV+qPGca0bultkOuYzVHnJ+0bcdcazqfXRz6ddrhLe27XEh5d73ldSKe7R",
	"x4lMReu7CaPwdPMoe0HYQsYpHcQ7TNEqJMUVv7C/e9OypJPNMbOK9XaXOay3L+uhM6QKQYot8undvnxg",
	"/9jlQDm5Trnf0yc1TZzU1E7VjkSmWWjX3IpHkphkQn+HF2ESAji5Pg9fnB5HbpG1JLaODma0cY8OHstc",
	"OSQ+OnjfooMHKQZl0TtGB1cYyDtDnBXkM4kONqrMDv8HQ49rdPBU0s3f2R9FdPAgi01Ei2gW8Lzn40VG",
	"RQfbW34pjgfYfRc4noM3L3Dsbb65bb4UxyMsvgsce3tvHnuPof64rD0mtCay9eaTaF7XHrKdx6Shu5Xn",
	"uc5beMMsPMZvLvadfjjBzsBzqgU9AWeyeb2JN7eJx5hlhI3n9gSHN/KmMPKmfLNjT6w8LromMvPmlGte",
	"5R6yocdlorul5xnP23pDbT3Ocr3GHusJo4Iges956p8QxJCEp39cMdXzBgJS+QvkKOJ/XLFebH7BiAVJ",
	"wtNwTekmP10uKbl/8T2BKKeQvIDFEmzQ8vZV+Hj1+P8BAAD//6tq0HwTugEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
